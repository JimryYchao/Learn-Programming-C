## C 程序构建基块

- [C 程序构建基块](#c-程序构建基块)
  - [1. 基本概念](#1-基本概念)
    - [1.1. 源文件和源程序](#11-源文件和源程序)
    - [1.2. 预处理指令与杂注](#12-预处理指令与杂注)
    - [1.3. 声明与定义](#13-声明与定义)
    - [1.4. 程序执行和 Main](#14-程序执行和-main)
    - [1.5. 范围与存储期](#15-范围与存储期)
    - [1.6. 链接](#16-链接)
    - [1.7. 名称空间](#17-名称空间)
    - [1.8. 对象对齐](#18-对象对齐)
    - [1.9. 编码](#19-编码)
    - [1.10. 未定义行为](#110-未定义行为)
  - [2. 词法元素](#2-词法元素)
    - [2.1. 标记、空白字符](#21-标记空白字符)
    - [2.2. 关键字](#22-关键字)
    - [2.3. 操作符与标点符号](#23-操作符与标点符号)
  - [3. 常量](#3-常量)
    - [3.1. 整数常量](#31-整数常量)
    - [3.2. 浮点常量](#32-浮点常量)
    - [3.3. 枚举常量](#33-枚举常量)
    - [3.4. 字符常量](#34-字符常量)
    - [3.5. 布尔常量和空指针常量](#35-布尔常量和空指针常量)
  - [4. 存储类说明符](#4-存储类说明符)
    - [4.1. auto](#41-auto)
    - [4.2. constexpr](#42-constexpr)
    - [4.3. extern](#43-extern)
    - [4.4. register](#44-register)
    - [4.5. static](#45-static)
    - [4.6. thread\_local](#46-thread_local)
    - [4.7. typedef](#47-typedef)
    - [4.8. 试探性定义](#48-试探性定义)
  - [5. 类型说明符](#5-类型说明符)
    - [5.1. Void](#51-void)
    - [5.2. Integer](#52-integer)
    - [5.3. Char](#53-char)
    - [5.4. Bool](#54-bool)
    - [5.5. Float-point](#55-float-point)
    - [5.6. Enum](#56-enum)
    - [5.7. Struct](#57-struct)
    - [5.8. Union](#58-union)
    - [5.9. Bit Field](#59-bit-field)
    - [5.10. Array](#510-array)
    - [5.11. Pointer](#511-pointer)
    - [5.12. String](#512-string)
  - [6. 类型推断](#6-类型推断)
  - [7. 类型限定符](#7-类型限定符)
    - [7.1. const](#71-const)
    - [7.2. volatile](#72-volatile)
    - [7.3. restrict](#73-restrict)
    - [7.4. \_Atomic](#74-_atomic)
    - [7.5. 限定声明的结构成员](#75-限定声明的结构成员)
  - [8. 复杂声明解释](#8-复杂声明解释)
    - [8.1. 抽象声明符](#81-抽象声明符)
    - [8.2. 解释复杂的声明符](#82-解释复杂的声明符)
    - [8.3. 不完整类型](#83-不完整类型)
    - [8.4. 复合文本](#84-复合文本)
  - [9. 类型初始化](#9-类型初始化)
    - [9.1. 初始化标量类型](#91-初始化标量类型)
    - [9.2. 初始化聚合类型](#92-初始化聚合类型)
    - [9.3. 初始化字符串](#93-初始化字符串)
    - [9.4. 空初始化器](#94-空初始化器)
  - [10. 表达式与操作符](#10-表达式与操作符)
    - [10.1. 表达式计算](#101-表达式计算)
    - [10.2. 常量表达式](#102-常量表达式)
    - [10.3. 算数运算符](#103-算数运算符)
    - [10.4. sizeof](#104-sizeof)
    - [10.5. typeof, typeof\_unqual](#105-typeof-typeof_unqual)
    - [10.6. alignas, alignof](#106-alignas-alignof)
    - [10.7. 类型转换](#107-类型转换)
    - [10.8. 关系运算符](#108-关系运算符)
    - [10.9. 逻辑运算符](#109-逻辑运算符)
    - [10.10. 三目运算符](#1010-三目运算符)
    - [10.11. 顺序运算符](#1011-顺序运算符)
    - [10.12. 按位运算符](#1012-按位运算符)
    - [10.13. 移位运算符](#1013-移位运算符)
    - [10.14. 替用运算符 (iso646.h)](#1014-替用运算符-iso646h)
    - [10.15. 不求值表达式](#1015-不求值表达式)
    - [10.16. 泛型选择](#1016-泛型选择)
    - [10.17. 静态断言](#1017-静态断言)
  - [11. 语句](#11-语句)
    - [11.1. 空语句](#111-空语句)
    - [11.2. while](#112-while)
    - [11.3. for](#113-for)
    - [11.4. do-while](#114-do-while)
    - [11.5. if-else](#115-if-else)
    - [11.6. switch](#116-switch)
    - [11.7. goto](#117-goto)
    - [11.8. continue](#118-continue)
    - [11.9. break](#119-break)
    - [11.10. return](#1110-return)
  - [12. 函数](#12-函数)
    - [12.1. 函数声明](#121-函数声明)
    - [12.2. 函数定义](#122-函数定义)
    - [12.3. 可变参数列表](#123-可变参数列表)
    - [12.4. 内联函数](#124-内联函数)
    - [12.5. 变长数组参数](#125-变长数组参数)
    - [12.6. 限定数组形参](#126-限定数组形参)
    - [12.7. 函数递归](#127-函数递归)
    - [12.8. 函数与指针](#128-函数与指针)
  - [13. 属性说明符](#13-属性说明符)
    - [13.1. 标准属性](#131-标准属性)
    - [13.2. 属性测试](#132-属性测试)
    - [13.3. nodiscard 弃值表达式警告](#133-nodiscard-弃值表达式警告)
    - [13.4. deprecated 弃用](#134-deprecated-弃用)
    - [13.5. fallthrough 贯穿抑制警告](#135-fallthrough-贯穿抑制警告)
    - [13.6. maybe\_unused 抑制对未使用实体的警告](#136-maybe_unused-抑制对未使用实体的警告)
    - [13.7. noreturn 函数不会返回](#137-noreturn-函数不会返回)
    - [13.8. unsequenced 和 reproducible 函数类型标准属性](#138-unsequenced-和-reproducible-函数类型标准属性)
  - [14. 预处理器与预处理指令](#14-预处理器与预处理指令)
    - [14.1. 空预处理指令](#141-空预处理指令)
    - [14.2. 条件包含与条件求值](#142-条件包含与条件求值)
    - [14.3. 源文件包含](#143-源文件包含)
    - [14.4. 二进制资源包含](#144-二进制资源包含)
    - [14.5. 宏替换](#145-宏替换)
    - [14.6. 取消宏定义](#146-取消宏定义)
    - [14.7. 文件名与行信息](#147-文件名与行信息)
    - [14.8. 诊断指令](#148-诊断指令)
    - [14.9. 实现定义行为控制](#149-实现定义行为控制)
    - [14.10. 预定义宏](#1410-预定义宏)
    - [14.11. 预定义变量](#1411-预定义变量)


---
### 1. 基本概念
#### 1.1. 源文件和源程序

**源程序** 可以分为一个或多个 “源文件” 或 “翻译单元”。**翻译单元** 的组件是包括函数定义和标识符声明的外部声明，包括 ```#include``` 引用的头文件、库文件等。编译器编译每个翻译单元，并将生成的对象链接成为可执行文件的程序。
源程序是指令、杂注、声明、定义、语句块和函数的集合。C 预处理实际上是用包含的头文件内容替换 ```#include``` 指令，编译器源代码文件和所有的头文件都看成是一个包含信息的单独文件。这个文件被称为 **翻译单元**（translation unit）。

>---
#### 1.2. 预处理指令与杂注

**预处理指令** 指示 C 预处理器在编译之前先对程序的文本执行特定操作。

```c
#define		#endif		#ifdef		#line
#elif		#error		#ifndef		#pragma
#else		#if			#include	#undef
```

**杂注** 指示编译器在编译时执行特定操作，杂注随编译器的不同而不同。使用 ```#pragma``` 来设置要对程序执行的优化。有关杂注参考预处理指令 ```#pragma```。

>---
#### 1.3. 声明与定义

**声明** 在特定变量、函数或类型及其特性之间建立关联。声明指定了可访问标识符的位置和时间（标识符的链接）。

**定义** 将建立与声明的关联，同时也会导致为类型分配存储。

**标识符** 可以表示：
- 标准特性、特性前缀或特性名称；
- 对象或函数；
- 结构或联合或枚举的成员或标记；
- `typedef` 命名类型；
- 标签名称；
- 宏名称或宏参数。

相同的标识符可以表示程序种不同点的不同实体。枚举的成员称为枚举常量。不再进一步考虑宏名称和宏参数，因为在程序转换的语义阶段之前，源文件中出现的任何宏名称都将替换为构成其宏定义的预处理标记序列。

>---
#### 1.4. 程序执行和 Main

每个 C 程序都有必须命名为 ```main``` 的主函数，```main``` 函数充当程序执行的起点。程序可以因为各种原因在程序的其他点上终止，但它通常在 ```main``` 的结尾处停止执行。

```c
int main(int argc, char *argv[ ], char *envp[ ]);
/* main 的宽字符版本，程序使用 Unicode 编程模型 */
int wmain(int argc, wchar_t *argv[ ], wchar_t *envp[ ]);
/* 简易版 */
int main(void);
void main(void);
```

- ```argc``` 表示从命令行传递到程序的实参的数量。由于程序名被视为实参，因此 ```argc``` 的值至少有一个。
- ```argv``` 是一个指针数组（包含 ```argc+1``` 个指针），首元素为程序名称，顺次是命令行传递的字符串参数。
- ```envp``` 参数是以 ```null``` 结尾的字符串的数组，这些字符串表示在用户的环境变量中设置的值。
- ```return```：若使用返回语句，则返回值会用作隐式调用 ```exit()``` 的参数。值零和 ```EXIT_SUCCESS``` 指示成功终止，值 ```EXIT_FAILURE``` 指示不成功终止。
- 参数 `argc` 和 `argv` 以及 `argv` 数组指向的字符串应可由程序修改，并在程序启动和程序终止之间保留其最后存储的值。

在程序启动时，初始化所有静态存储期对象后调用 ```main``` 函数。它指明执行于宿主环境（即在操作系统中）的程序入口点。任何独立程序 （引导程序、操作系统核心等）的入口点的名称和类型是实现定义的。
- 主函数的双参数形式允许从执行环境传递任意的多字节字符串（常称作命令行参数）。
- 若宿主环境不能一同提供大写和小写字母，则转换命令行参数为小写。
- ```argv``` 所指的数组大小至少是 ```argc+1``` ，并保证末元素 ```argv[argc]``` 为空指针（一般表示命令行输入终止）。

>---
#### 1.5. 范围与存储期

标识符的 **可见性** 确定其可以引用的程序部分，即其 **范围**（scope，作用域）。标识符 **仅在其范围包含的程序部分中可见**。```static```、```extern``` 存储类型符标记类型的链接方式，用于确定类型在其范围内的可见性。

- **文件范围**：带文件范围的标识符的声明符或类型说明符显示在任何块或参数列表的外部，并且在其声明后可从翻译单元的任何位置进行访问（全局或外部）。
- **函数范围**：标签是唯一一种具有函数范围的标识符。通过在语句中使用标签来隐式声明标签。标签名称在函数中必须是唯一的。
- **块范围**：带块范围的标识符的声明符或类型说明符显示在块中或函数定义中的形参声明列表中，它仅从其声明或定义的点到包含其声明或定义的块的结尾可见。
- **函数原型范围**：带函数原型范围的标识符的声明符或类型说明符显示在函数原型（不函数声明的一部分）中的参数声明列表中。其范围在函数声明符的末尾终止。

范围（作用域）和链接描述了标识符的可见性。存储期描述了通过这些标识符访问的对象的存储期（又称生命周期）。对象的 **生命周期** 是程序执行过程中保证为其保留存储的值。**标识符的存储持续时间决定其生命周期**。具有 **全局存储期** 的类型将在程序执行期间始终存在，由于函数只能声明在文件范围，因此所有的函数都具有全局存储期。

一般进入块范围或函数范围时，创建的对象具有 **局部存储期**，离开范围后，对象将消失。可以在块范围内声明 ```static``` 内部静态变量，将具有全局存储期。

> *存储期类别*

- **静态存储期**：在程序的执行期间一直存在（文件作用域变量具有静态存储期，```static``` 表示变量的内部链接属性）。
- **线程存储期**：用于并发程序设计，程序执行可被分为多个线程（线程存储期的对象，从被声明时到线程结束一直存在，关键字 ```_Thread_local``` 声明一个对象时，每个线程都获得该变量的私有备份）。
- **自动存储期**：块作用域的变量通常都具有自动存储期（进入块时，为这些变量分配内存；离开块区域时，这些局部变量会被释放，```static``` 表示块变量拥有静态存储期，从程序被载入到程序结束期间都存在。其他函数可以通过该存储区的地址间接访问该对象）。
- **动态分配存储期**：目标程序或操作系统运行阶段动态地为源程序中的量分配存储空间，动态存储分配包括 **栈式** 或 **堆** 两种分配方式。
- **线程存储期**：每个线程拥有其自身的相异对象。若执行访问此对象的表达式的线程，不是执行其初始化的线程，则行为是实现定义的。所有声明为 ```_Thread_local``` 的对象拥有此存储期。

>---
#### 1.6. 链接

标识符名称可引用不同范围内的各个标识符。在不同的范围内或在同一范围内多次声明的标识符可以通过创建 **链接** 的方式来引用同一标识符或函数。

- **外部链接**：```extern``` 声明、文件范围内的非 ```static``` 声明均具有外部链接。每个具有外部链接的特定标识符的声明都表示相同的对象或函数。
- **内部链接**：```static``` 或 `constexpr` 声明的对象、`static` 函数具有内部链接。在同一个翻译单元种，每个具有内部链接的标识符声明都表示相同的对象或函数。
- **无链接**：通常声明为除对象或函数以外的任何项的标识符、函数参数的标识符、无存储类说明符的块范围标识符均具有无链接属性，在同级别范围内二次声明将产生重定义错误。无链接的标识符的每个声明都表示一个唯一的实体。
> *存储期与可见性摘要*

| 级别         | 项             | 说明符           | 存储期 | 链接方式 | 可见性                     |
| :----------- | :------------- | :--------------- | :----- | :------- | :------------------------- |
| **文件范围** | 变量定义       | static           | Global | Internal | 此项所在源文件的剩余部分 |
|              | 变量声明       | extern           | Global | external | 此项所在源文件的剩余部分 |
|              | 函数原型或定义 | static           | Global | Internal | 单个源文件                 |
|              | 函数原型       | extern           | Global | external | 源文件的剩余部分           |
| **块范围**   | 变量声明       | extern           | Global | internal | 块                         |
|              | 变量定义       | static           | Global | internal | 块                         |
|              | 变量定义       | auto 和 register | Local  | internal | 块                         |

>---
#### 1.7. 名称空间

如果在翻译单元中的任何一点上都可以看到特定标识符的多个声明，则句法上下文会消除引用不同实体的用法的歧义。因此，各种类别的标识符都有单独的名称空间。编译器设置 **名称空间** 来区分用于各种项的标识符。每个名称空间中的名称必须是唯一的以避免冲突，但相同的名称可出现在多个名称空间中。

> *C 中使用的名称空间*

**语句标签**：命名的语句标签是语句的一部分。语句标签的使用始终与 ```goto``` 关键字相关联。语句标签不必与其他名称或其他函数中的标签名称有所不同。

**结构、联合和枚举标记**：这些标记是结构、联合和枚举类型说明符的一部分，如果存在，总是紧跟在保留字 ```struct```、```union``` 或 ```enum``` 后面。标记名称必须不同于具有相同可见性的所有其他结构、枚举或联合标记。

**结构或联合的成员**：成员名称分配在与各结构和联合类型关联的名称空间中（同一标识符可以同时为任意数量的结构或联合的组件名称），成员的名称在结构或联合中必须是唯一的。

**标准属性和属性前缀**：通过属性说明符的语法或属性标记的名称消除歧义。

**属性前缀令牌中的尾随标识符**：每个属性前缀都有一个单独的名称空间，用于它引入的实现定义的属性。通过属性前缀和尾随标识符令牌消除歧义。

**普通标识符**：所有其他名称都属于一个包含变量、函数（包括形参和局部变量）和枚举常量的名称空间。

**typedef 名称**： typedef 名称不能用作同一作用域内的标识符。

```c
/* student 在各自的名称空间内具有唯一性 */
struct student {
   char student[20];
   int class;
   int id;
} student;

printf("%d", student.id);  // [.] 调用 student 成员
```

>---
#### 1.8. 对象对齐

完整的对象类型具有对齐要求，这些要求可以分配该类型对象的地址施加了限制。对齐方式是实现定义的整数值，表示可以分配给定对象的连续地址之间的字节数。对象类型对该类型的每个对象都施加了对齐要求，可以使用 `alignas` 请求更为严格的对齐。

基本对齐是小于等于 `alignof(max_align_t)` 的有效对齐。所有存储持续时间的对象的实现都应支持基本对齐。以下类型的对齐要求应为基本对齐：
- 所有原子、限定或非限定的基本类型、枚举类型、指针类型；
- 其元素类型具有基本对齐要求的所有数组类型；
- 指定为完整对象类型的所有类型；
- 其包含元素具有基本对齐要求的类型，并且其元素均不具有指定非基本对齐方式的对齐说明符的所有结构或联合类型。

扩展对齐由大于 `alignof(max_align_t)` 的对齐表示。是否支持任何扩展对齐方式以及支持这些对齐方式的存储持续时间是实现定义的。具有扩展对齐要求的类型是过度对齐类型。

可以使用 `alignof` 表达式查询完整类型的对齐要求。类型 `char`、`signed char` 和 `unsigned char` 应具有最弱的对齐要求。

比较对齐方式是有意义的，并提供了明显的结果：
- 当两个对齐方式的数值相等时，它们相等。
- 当两个对齐方式的数值不相等时，它们会有所不同。
- 当一个对齐方式大于另一个对齐方式时，它表示更严格的对齐方式。

>---
#### 1.9. 编码

文本编码是执行字符集的字符到字符常量或字符串文本中的值的实现定义的映射，它应支持从所有基本执行字符集值到实现定义的编码的映射。它可能包含多字节字符序列。

宽文本编码是执行字符集的字符到 `wchar_t` 字符常量或 `wchar_t` 字符串文本中的值的实现定义的映射，它应支持从所有基本执行字符集值到实现定义的编码的映射。如果实现未定义 `__STDC_MB_MIGHT_NEQ_WC__`，则映射应生成与所有基本执行字符集值的文本编码相同的值。一个或多个值可以映射到执行字符集的一个或多个值。

>---
#### 1.10. 未定义行为

UB（Undefined Behavior），表示程序的该行为没有限制。**未定义行为** 有数组索引越界、有符号整数溢出、空指针解引用、在表达式中超过一次修改标量而其中无顺序点、通过不同类型的指针访问对象等。编译器不要求诊断未定义行为。

```c
/* 有符号溢出 */
int foo(int x) {
    return x+1 > x; // 真或为有符号溢出导致的 UB
}

/* 越界访问 */
int table[4] = {0};
int exists_in_table(int v)
{
    // 在最初的 4 个迭代中返回真或因为越界访问的 UB
    for (int i = 0; i <= 4; i++) {
        if (table[i] == v) return 1;
    }
    return 0;
}

/* 未初始化标量 */
_Bool p; 	// 未初始化局部变量
if(p) 		// 访问未初始化标量是 UB
    puts("p is true");
if(!p) 		// 访问未初始化标量是 UB
    puts("p is false");

/* 非法标量 */
int f(void) {
	_Bool b = 0;
    unsigned char* p =(unsigned char*)&b;
    *p = 10;
    // 从 b 读取现在是 UB
    return b == 0;
}

/* 空指针解引用 */
int foo(int* p) {
    int x = *p;
    if(!p) return x; // 为上述 UB ，或绝不采用此分支
    else return 0;
}
int bar() {
    int* p = NULL;
    return *p;       // 无条件 UB
}

/* 访问传递给 realloc 的指针 */
#include <stdio.h>
#include <stdlib.h>
int main(void) {
    int *p = (int*)malloc(sizeof(int));
    int *q = (int*)realloc(p, sizeof(int));
    *p = 1; // 访问传递给 realloc 的指针是 UB
    *q = 2;
    if (p == q) // 访问传递给 realloc 的指针是 UB
        printf("%d%d\n", *p, *q);
}

/* 无副效应的无限循环 */
while(1){
	;
}
```

> *其他行为*

**未指定行为**：容许二种或多种行为，且不要求实现规范每种行为。例如，求值顺序、同样的字符串字面量是否有别，等。每个未指定行为导致一组合法结果之一，并且可以在同一程序中重复时产生不同结果。

**实现定义行为**：在未指定行为之上，实现规范了如何选择。例如，字节中的位数，或有符号整数右移是算术还是逻辑。

**本地环境限定行为**：依赖于当前选择的本地环境的实现定义行为。

---
### 2. 词法元素

#### 2.1. 标记、空白字符

C 编译器识别的基本元素是 **标记**（令牌），包括有关键字、标识符、常量、字符串、运算符、标点符号等。

空白字符包括有空格 ```' '```、水平制表符 ```'\t'```、换行符 ```'\n'```、回车符 ```'\r'```、换页符 ```'\f'``` 和垂直制表符 ```'\v'```。标记由空白符和其他标记分隔（划分边界），在分析代码时，编译器将忽略空白字符。

标识符为程序中的变量、类型、函数和标签提供名称，名称在拼写和大小写上必须与任何关键字都不同。标识符的首字符不可以是数字字符。

```go
/* 有效标识符 */  // 注释
_Identifier
Identifier
Identifier123
```

>---
#### 2.2. 关键字

| Keyword       | Description                                          |
| :------------ | :--------------------------------------------------- |
| `alignas`       | `_Alignas`，设置类型的对齐属性                                   |
| `alignof`       | `_Alignof`，获取类型的对齐属性                                   |
| `auto`          | 自动类型声明                                         |
| `bool`          | `_Bool`，声明布尔类型                                         |
| `break`         | 跳出当前循环或分支                                   |
| `case`          | switch 语句的 case 分支                              |
| `char`          | 字符类型                                             |
| `const`         | 只读类型声明限定                                     |
| `constexpr`     | 常量表达式                                                    |
| `continue`      | 结束当前循环，进入下一轮                             |
| `default`       | switch 语句的默认分支                                |
| `do`            | do 循环体                                            |
| `double`        | 双精度浮点类型                                       |
| `else`          | if 语句 的 else 分支                                 |
| `enum`          | 枚举类型                                             |
| `extern`        | 外部类型引用声明                                     |
| `false`         | 布尔值，假                                           |
| `float`         | 单精度浮点类型                                       |
| `for`           | for 循环                                             |
| `goto`          | 无条件跳转语句                                       |
| `if`            | if 条件分支                                          |
| `inline`        | 内联函数                                             |
| `int`           | 整数类型                                             |
| `long`          | 长整数类型                                           |
| `nullptr`       | 空指针字面值                                         |
| `register`      | 寄存器存储类型声明                                   |
| `restrict`      | 参数引用类型声明限定                                 |
| `return`        | 函数返回语句                                         |
| `short`         | 短整数类型声明                                       |
| `signed`        | 声明有符号数值类型                                   |
| `sizeof`        | 计算数据类型或变量所占字节数                         |
| `static`        | 静态类型声明限定                                     |
| `static_assert` | `_Static_assert`，静态断言                                             |
| `struct`        | 结构类型                                             |
| `switch`        | switch 条件分支语句                                  |
| `thread_local`  | `_Thread_local`，线程本地存储声明                                     |
| `true`          | 布尔值，真                                           |
| `typedef`       | 类型别名声明                                         |
| `typeof`        | 获得变量或函数的类型                             |
| `typeof_unqual` | 无限制 typeof                                                    |
| `union`         | 联合或共用体类型                                     |
| `unsigned`      | 声明无符号数值类型                                   |
| `void`          | 无类型                                               |
| `volatile`      | 易变声明，声明的变量类型在程序执行过程中可被隐式改变 |
| `while`         | while 循环                                           |
| `_Atomic`       | 声明原子类型                                         |
| `_BitInt`       | 位精确整数                                                     |
| `_Complex`      | 声明复数类型                                         |
| `_Decimal128`   | 128 位十进制数                                       |
| `_Decimal32`    | 32 位十进制数                                        |
| `_Decimal64`    | 64 位十进制数                                        |
| `_Generic`      | 泛型编程                                             |
| `_Imaginary`    | 虚数类型                                             |
| `_Noreture`     | 应用方的函数不返回调用方                             |

>---
#### 2.3. 操作符与标点符号

```c
[    ]    (    )    {    }    .    ->
++   --   &    *    +    -    ~    !
/    %    <<   >>   <    >    <=   =>   ==   !=   ^    |    &&   ||
?    :    ::   ;    ...
=    *=   /=   %=   +=   -=   <<=  >>=  &=   ^=   |=
,    #    ##
```

> *二元符*

```c
<:   :>   <%   %>   %:   %:%:
// 等效于
[    ]    {    }    #    ##
```

---
### 3. 常量

常量包含有整数常量、浮点常量、枚举常量、字符常量和预定义常量。每一个常量都包含一个类型，常量的值必须在其类型的可表示值范围内。

>---
#### 3.1. 整数常量

```c
0b'1010'0101            // 二进制
076543210               // 八进制

0x'abcdef
0X'ABCDEF0123456789   // 十六进制 
```

整数常量的类型是可以表示其值的相应列表中的第一个。

| Suffix                           | 十进制                                                            | 八进制、十六进制或二进制                                                                                    |
| :------------------------------- | :---------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------- |
| none                             | `int`<br>`long int`<br>`long long int`                            | `int`<br>`unsigned int`<br>`long int`<br>`unsigned long int`<br>`long long int`<br>`unsigned long long int` |
| `u`,`U`                       | `unsigned int`<br>`unsigned long int`<br>`unsigned long long int` | `unsigned int`<br>`unsigned long int`<br>`unsigned long long int`                                           |
| `l`, `L`                       | `long int` <br>`long long int`                                    | `long int`<br>`unsigned long int`<br>`long long int`<br>`unsigned long long int`                            |
| `ul`, `uL`, `Ul`, `UL`     | `unsigned long int`<br>`unsigned long long int`                   | `unsigned long int`<br>`unsigned long long int`                                                             |
| `ll`, `LL`                     | `long long int`                                                   | `long long int`<br>`unsigned long long int`                                                                 |
| `ull`, `Ull`, `uLL`, `ULL` | `unsigned long long int`                                          | `unsigned long long int`                                                                                    |
| `wb`, `WB`                     | `_BitInt(N)`，其中宽度 N 是大于 1 的可以容纳值和符号位的最小 N    | `_BitInt(N)`，其中宽度 N 是大于 1 的可以容纳值和符号位的最小 N                                              |
| `u`, `U` & `wb`,`WB`      | `unsigned _BitInt(N)`，其中宽度 N 是大于 0 的可以容纳值的最小 N   | `unsigned _BitInt(N)`，其中宽度 N 是大于 0 的可以容纳值的最小 N                                             |

```c
-3wb        /* Yields an _BitInt(3) that is then negated; two value bits, one sign bit */
-0x3wb      /* Yields an _BitInt(3) that is then negated; two value bits, one sign bit */
3wb         /* Yields an _BitInt(3); two value bits, one sign bit */
3uwb        /* Yields an unsigned _BitInt(2) */
-3uwb       /* Yields an unsigned _BitInt(2) that is then negated, resulting in wraparound */
```

>---
#### 3.2. 浮点常量

无后缀的浮点常量具有 `double` 类型，如果后缀是浮点后缀，则它具有类型：

| Suffix       | Type          | Description    |
| :----------- | :------------ | :------------- |
| `f`, `F`   | `float`       | 单精度浮点数   |
| `l`, `L`   | `long double` | 长双精度浮点数 |
| `df`, `DF` | `_Decimal32`  | 32 位十进制数  |
| `dd`, `DD` | `_Decimal64`  | 64 位十进制数  |
| `dl`, `DL` | `_Decimal128` | 128 位十进制数 |

浮点后缀 `df`、`dd`、`dl`、`DF`、`DD` 或 `DL` 不能用于十六进制浮点常量。浮点常量有一个有效部分，后面可能跟一个指数部分和一个指定其类型的后缀。有效数部分的组成部分可以是包括整数部分和小数部分的数字序列。在确定常数值时，忽略数字分隔符 `'`。指数部分的分量可以是 e、E、p、P，后跟由可选带符号的数字序列组成的指数。整数部分或分数部分必须存在；对于十进制浮点常量，分数或指数部分必须存在。

有效数部分被解释为（十进制或十六进制）有理数；指数部分中的数字序列被解释为十进制整数。对于十进制浮点常量，指数表示有效数部分要缩放的 10 的幂。对于十六进制浮点常量，指数表示有效数部分要缩放的 2 的幂。对于十进制浮点常量，以及当 `FLT_RADIX` 不是 2 的幂时的十六进制浮点常量，结果要么是最接近的可表示值，要么是与最接近的可表示值紧邻的较大或较小的可表示值，以实现定义的方式选择。对于十六进制浮点常量，当 `FLT_RADIX` 为 2 的幂时，结果将正确舍入。

浮点常量被转换为内部格式，就像在编译时一样。浮点常数的转换在执行时不应引发异常条件或浮点异常。同一源形式的所有浮点常量应转换为具有相同值的相同内部格式。

>---
#### 3.3. 枚举常量

对于没有固定基础类型的枚举，声明为枚举常量的标识符具有 `int` 类型或枚举类型。声明为具有固定基础类型的枚举的枚举常量的标识符具有关联的枚举类型。枚举常量可以在表达式（或常量表达式）中使用，只要可以使用整数类型的值。

```c
enum Week {
	Sunday = 0,
	Monday,
	Tuesday,
	Wednesday,
	Thursday,
	Friday,
	Saturday,
};
```

>---
#### 3.4. 字符常量

整数字符常量是用单引号括起来的一个或多个多字节字符的序列。UTF-8  `char8_t` 字符常量以 `u8` 为前缀，`wchar_t` 字符常量以 `L` 为前缀，UTF-16 `char16_t` 字符常量以 `u` 为前缀，UTF-32 `char32_t` 字符常量以 `U` 为前缀。`wchar_t`、`char16_t`、`char32_t` 字符常量统称为宽字符常量。序列的元素是源字符集的任何成员；它们以实现定义的方式映射到执行字符集的成员。

UTF-8、UTF-16 或 UTF-32 字符常量不得包含多个字符。该值应分别用单个 UTF-8、UTF-16 或 UTF-32 代码单元表示。

```c
char8_t c8 = u8'A';     // UTF-8
char c = 'A';           
wchar_t wc = L'A';      // 宽字符
char16_t c16 = u'A';    // UTF-16
char32_t c32 = U'A';    // UTF-32

wchar_t mwc = L'123';   // 多字节字符
```

八进制转义序列以反斜杠开头后跟最多三个八进制数字的序列被视为整数字符常量的单个字符或宽字符常量的单个宽字符的构造的一部分。在十六进制转义序列中，`\x` 后跟最多四位的十六进制数字被视为整数字符常量的单个字符或宽字符常量的单个宽字符的构造的一部分。在通用字符名中，`\u` 后面的四位十六进制数字被视为整数字符常量的单个字符或宽字符常量的单个宽字符的构造的一部分。

```c
char oct = '\65';
char hex = '\xff';
char uni = '\u00f4';
```

>---
#### 3.5. 布尔常量和空指针常量

`true` 和 `false`  是 `bool` 类型的常量，其中 `false` 的值为 0，`true` 的值为 1。`nullptr` 表示空指针常量。

```c
bool f = false;           
bool t = true;
void* p = nullptr;
```

---
### 4. 存储类说明符

```c
auto
constexpr
extern
register
static
thread_local
typedef
```

在声明中最多可以给定一个存储类说明符，除了：
- `thread_local` 可以和 `static` 或 `extern` 一起出现；
- `auto` 可以和除 `typedef` 之外的其他项一起出现；(C23)
- `constexpr` 可以和 `auto`、`register` 或 `static` 一起出现。

存储类说明符指定标识符和声明功能的各种属性：
- 存储持续时间：块范围的 `static`、`thread_local`、`auto`、`register`
- 链接：`extern`、`static`、文件范围的 `constexpr` 、`typedef`
- 值：`constexpr`
- 类型：`typedef`

>---
#### 4.1. auto

```auto``` 存储类说明符声明具有本地生存期的自动变量。只能声明在内部级别（函数体范围）。自动类型变量不会自动初始化（栈存储不存在垃圾回收），直接使用未定义的自动类型变量是未定义行为。
对于内部级别的静态类型，不能用自动类型进行初始化（因为自动类型的地址是不确定的）。

如果要从初始值设定项推断类型，则 `auto` 只能出现在具有文件范围的标识符的声明说明符中，或与其他存储类说明符一起出现。

如果 `auto` 与另一个存储类说明符一起出现，或者如果它出现在文件作用域的声明中，那么在确定存储持续时间或链接时将忽略它。在这种情况下，它仅表示可以推断声明的类型。

>---
#### 4.2. constexpr

使用 `constexpr` 声明的对象或其任何成员的对象（即使是递归的）不能具有原子类型、可变修改类型或 `volatile` 或 `restrict` 限定修饰的类型。`constexpr` 声明为定义，并且具有初始值设定项。初始值设定项的字符串文本中的任何常量表达式或任何字符的值都应在相应的目标类型中可完全表示。`constexpr` 在声明后值不可变。

使用 `constexpr` 声明的对象或子对象：
- 具有指针、整数或算数类型，则它的任何显式初始化设定项应分别是为 null、整数常量表达式或算数常量表达式。
- 具有实数浮点类型，则初始值设定项应具有整数或实数浮点类型。
- 具有虚数类型，则初始值设定项应具有虚数类型。
- 具有十进制浮点类型，则声明的对象应具有十进制浮点类型，并且转换应保留初始值设定项的量。
- 如果初始值设定项具有实数类型或 NaN 值，则初始值设定项类型的非限定版本和声明的对象的相应实数类型应兼容。

```c
struct s { void *p; };
constexpr struct s A = { nullptr };
constexpr struct s B = A;
/* 尽管表达式 A.p 不是一个空指针常量，而只是一个空指针，
但 B 的初始化中唯一的显式初始化项是 A，而不是 A.p，
因此该初始化没有违反约束。 */
```

使用存储类说明符 `constexpr` 声明的对象在翻译时其值永久固定。如果尚不存在，则将 `const` 限定隐式添加到对象的类型中。声明的标识符被视为相应类型的常量表达式。

在块范围中声明的对象，使用存储类说明符 `constexpr` 且不带 `static`，具有自动存储持续时间，标识符没有链接，并且对象的每个实例都有一个唯一的地址，可通过 `&`（如果未使用 `register` 说明符声明）获得（如果有）。文件范围中的此类对象具有静态存储持续时间，相应的标识符具有内部链接，并且每个看到相同文本定义的翻译单元都实现具有不同地址的单独对象。

使用 `constexpr` 说明符声明的标识符可以在常量表达式中使用其值；使用 `constexpr` 说明符声明的对象存储其初始值设定项的确切值，不支持隐式值更改。

```c
constexpr int K = 47;
enum{
    A = K,              // Valid, constant init
};
constexpr int L = K;    // Valid, constexpr init
static int b = K + 1;   // Valid, static init
int array[K];           // Not VLA

constexpr static unsigned short array[] = {
    3000,   // valid, fits in unsigned short range
    300000, // constraint violation if short is 16-bit
    -1      // constraint violation, target type is unsigned
};

struct S {
    int x, y;
};
constexpr struct S s = {
    .x = INT_MAX,   // valid
    .y = UINT_MAX,  // constraint violation
};
```

`constexpr` 对象的约束旨在翻译时强制检查可移植性：

```c
constexpr unsigned int minusOne = -1;         // constraint violation
constexpr unsigned int uint_max = -1U;        // ok
constexpr double onethird       = 1.0/3.0;    // possible constraint violation
constexpr double onethirdtrunc  = (double)(1.0/3.0);     // ok
constexpr _Decimal32 small      = DEC64_TRUE_MIN * 0;    // constraint violation
```

与字符串文本 `"\xFF"` 元素的 `char` 类型相关的实现定义行为可能会导致在翻译时违反约束

```c
constexpr char string[]            = { "\xFF", };   // ok
constexpr char8_t u8string[]       = { u8"\xFF", }; // ok
constexpr unsigned char ucstring[] = { "\xFF", };   // possible constraint violation
// 如果 char 能表示负数，且宽度为 8，上面的代码等效于
constexpr char string[]            = { -1, 0, };    // ok
constexpr char8_t u8string[]       = { 255, 0, };   // ok
constexpr unsigned char ucstring[] = { -1, 0, };    // constraint violation
// 如果 char 不能表示负数，则等效于
constexpr char string[]            = { 255, 0, };    // ok
constexpr char8_t u8string[]       = { 255, 0, };    // ok
constexpr unsigned char ucstring[] = { 255, 0, };    // ok
```

使用 `constexpr` 说明符声明的标识符可以在常量表达式中使用其值：

```c
constexpr int K = 47;
enum {
    A = K;
}
constexpr int L = K;
static int b = K + 1;
int array[K];   // 非 VLA
```

>---
#### 4.3. extern

```extern``` 存储类说明符声明对在其他位置类型声明的引用。在外部级别中引用声明之后，该引用声明将在剩余的翻译单元内均可见。
```extern``` 限定从未声明的类型，表明该声明是具有外部链接属性的，那么此定义可见于构成程序的任何翻译单元中。可以在文件范围和函数体范围内声明 ```extern``` 类型。

具有块范围的函数的标识符声明不应具有除 `extern` 之外的显式存储类说明符。

<br>

#### 4.4. register

```register``` 限定变量的存储类为寄存器类型，变量通常储存在计算机内存中，寄存器变量储存在 CPU 的寄存器中，访问速度要比内存中的变量更快。当被编辑器忽略时，自动转换为自动类型。
寄存器类型无法获取地址，因此无法利用地址运算符，即使变为自动类型。

```c
int main(void){
    register int num = 1;       // 指定该变量储存在 CPU 寄存器中
}
void Fun(register int num);     // 指定形参储存方式
```

>---
#### 4.5. static

```static``` 限定类型的声明仅在当前范围内可见，且存储期是静态的（全局生存）。可以限制变量和函数的链接方式。可以在文件范围和函数体范围内声明 ```static``` 类型。
静态类型仅在首次进入所在范围时初始化，且仅在该声明的范围内私有永久存储，无论是内部级别或外部级别。

```c
static int num;         // 文件范围中内部链接静态存储持续时间
int foo(){
    static int local_num = num;     // 块范围中静态存储持续时间
}
```

>---
#### 4.6. thread_local

`thread_local` 声明的变量类型具有线程存储期，不能用于函数类型的声明。如果 `thread_local` 出现在任何对象的声明中，则该说明符应出现在该对象的每份声明中。当声明具有块范围的对象时，则需要与 ```static``` 或 ```extern``` 之一组合以决定其链接。线程对象在启动线程时开始初始化。

>---
#### 4.7. typedef

使用 ```typedef``` 声明为已由 C 定义的类型或用户自定义类型构造更短和更有意义的名称。`typedef` 声明不会创建类型，而是创建现有类型的同义词或可通过其他方式指定的类型的名称。

当使用 ```typedef``` 名称作为类型说明符时，可以将其与特定的类型说明符组合，但不可以将其与其他类型说明符组合。可接受的修饰符包括 ```const``` 和 ```volatile```。

`typedef` 与通常标识符（例如枚举项、变量或函数）共享命名空间。

如果使用除 `typedef` 以外的存储类说明符声明聚合（结构或数组等）或联合对象，则存储类说明符生成的属性（链接除外）也适用于对象的成员，包括递归地适用于任何聚合或联合成员对象。

```c
typedef void fv(int);
typedef void (*pfv)(int);

void (*signal(int, void(*) (int)))(int);
// use fv
fv* signal(int, fv*);
// use pfv
pfv signal(int, pfv);
```

> *typedef 实例*

```c
// 定义声明
typedef struct{
	int count;
	float cost;
} book;
// 声明类型对象
book mbook = {.count = 10,.cost = 10* 1.5f};

// const 说明
typedef char* const ConstString;	// 指向常量字符串的指针
ConstString str = "HelloWorld";
typedef const char* ConstpStr;		// 指向字符串的常量指针
```

> *typedef 声明 VLA 数组*


如果 `typedef` 名称指定了可变修改的类型，则它应该具有块范围。每次按执行顺序到达 `typedef` 名称的声明时，都会计算与可变长度数组声明符和 `typeof` 运算符关联的任何数组大小表达式。`typedef` 声明不会引入新类型，而只会引入所指定类型的同义词。

对 VLA 的 ```typedef``` 只能出现在块作用域内，数组长度会在每次控制流经过 ```typedef``` 声明时求值。

```c
void F(int n){
    typedef int Array[n];	// Array 是 VLA ，其长度为 n ，现在求值
    n += 1;
    Array a; 				// a 的长度是 +=1 前的 n
    int b[n]; 				// a 和 b 长度不同
}
```


>---
#### 4.8. 试探性定义

试探性定义是没有初始化器的外部声明，且要么没有存储类说明符或拥有说明符 `static`。
试探性定义是可能或可能不表现为定义的声明。若在同一翻译单元的前方或后方能找到实际的外部定义，则试探性定义仅表现为声明；若在同一翻译单元中无定义，则试探性定义表现为将对象零初始化的实际定义。

 ```c
int i1 = 1;     	// 定义，外部链接
int i1;         	// 试探性定义，表现为声明，因为 i1 已定义
extern int i1;  	// 声明，引用前面的定义

extern int i2 = 3; 	// 定义，外部链接
int i2;            	// 试探性定义，表现为声明，因为 i2 已定义
extern int i2;     	// 声明，引用到前面的外部链接定义
```

不同于 ```extern``` 声明（如果前一声明已建立标识符链接，```extern``` 声明不更改链接属性），试探性定义可以与同一标识符另一声明的链接不一致。若同一标识符的二个声明均在作用域内且拥有不同链接，则行为未定义。

```c
static int i4 = 2; 	// 定义，内部链接
int i4;            	// 未定义行为：链接与前一行不一致
extern int i4;    	// 声明，引用到内部链接定义

static int i5; 		// 试探性定义，内部链接
int i5;        		// 未定义行为：链接与前一行不一致
extern int i5; 		// 引用到前者，其链接为内部
```

拥有内部链接的试探性定义必须拥有完整类型。

```c
static int i[];     // ERROR：试探性 static 声明中不允许出现不完整类型
int i[];            // 试探性声明，等价于 int i[1] = {0}; 除非在此文件之后重定义声明
```

---
### 5. 类型说明符

```c
void
char
short
int
long
float
double
signed
unsigned
_BitInt( constant-expression )
bool
_Complex
_Decimal32
_Decimal64
_Decimal128
atomic-type-specifier
struct-or-union-specifier
enum-specifier
typedef-name
typeof-specifier
```

除了类型推断，任何声明中的声明说明符中，以及每个成员声明和类型声明的说明符限定符列表中，都应至少给出一个类型说明符。

```c
void
char
signed char
unsigned char
short / signed short / short int / signed short int
unsigned short / unsigned short int
int / signed / signed int
unsigned / unsigned int
long / signed long / long int / signed long int
unsigned long / unsigned long int
long long / signed long long /long long int / signed long long int
unsigned long long / unsigned long long int
_BitInt( constant-expression ) / unsigned _BitInt( constant-expression )
unsigned _BitInt( constant-expression )
float 
double
long double
_Decimal32
_Decimal64
_Decimal128
bool
float _Complex
double _Complex
long double _Complex
atomic type specifier
struct or union specifier
enum specifier
typedef name
typeof specifier
```

如果实现不支持复数类型，则不使用 `_Complex`；如果实现不支持十进制浮点类型，则不使用 `_Decimal32`、`_Decimal64`、`_Decimal128`。

关键字 `_BitInt` 的常量表达式应为整数常量表达式 N，用于指定类型的宽度。`unsigned _BitInt` 类型的宽度应大于等于 1，`signed _BitInt` 类型的宽度应大于 2。N 的值小于等于 `BITINT_MAXWIDTH`。


> *定义变量*

```c
/* 声明整型 */
<signed/unsigned> <char/short/int/long/long long> Integer;
enum EnumType;

/* 声明浮点型 */
<float/double/long double> Double

/* 声明指针 */
<type *> p;
int* pInt = &num;
```

>---
#### 5.1. Void

```void``` 有三种用途：指定为函数返回类型、为未采用参数的函数指定一个参数类型列表、指定一个指向未指定类型的指针。
```void*``` 能用作指向未指定的类型的指针，除 ```char*``` 外转换成其他类型的指针需要强制类型转换。

```c
void foo(void){
    void* p;
}
```

>---
#### 5.2. Integer


```c
// 1. short >>> 16 bits
    short int num1;
    short num2;
// 2. int   >>> 16/32 bits
    signed int num1;
    int num2;
// 3. long(L)  >>> 32 bits
    long int num1;
    long num2;
// 4. long long(LL) >>> 64 bits
    long long int num1;
    long long num2;
// 5. unsigned
    unsigned int ui;
    unsigned u;  // U 后缀
    unsigned short us;
    unsigned long ul; // UL 后缀
```

> *整型进制转换*

```c
printf("%d");       // 显示十进制数字
printf("%o");       // 以八进制显示数字
printf("%x");       // 以十六进制显示数字
// 显示进制数字前缀
printf("%#o");      // %#o、%#x、%#X,
```

> *整型可移植: ```stdint.h```*

- C99 新增了两个头文件 ```stdint.h``` 和 ```inttypes.h```，以确保 C 语言的类型在各系统中的功能相同。
* 在 ```stdint.h``` 头文件中，```int32_t``` 表示 32 位的有符号整数类型：
  - 在 32 位 ```int``` 的系统中，```int32_t``` 作为 ```int``` 的别名。
  - 在 ```int``` 为 16 位、```long``` 为 32 位的系统会把 ```int32_t``` 作为 ```long``` 的别名。
- 使用 ```int32_t``` 类型编写程序，并包含 ```stdint.h``` 头文件时，编译器会把 ```int``` 或 ```long``` 替换成与当前系统匹配的类型。

```c
// 1. 精确宽度整数类型
typedef signed char             int8_t;
typedef short                   int16_t;
typedef int                     int32_t;
typedef long long               int64_t;
typedef unsigned char           uint8_t;
typedef unsigned short          uint16_t;
typedef unsigned int            uint32_t;
typedef unsigned long long      uint64_t;
// 2. 至少有指定宽度的最小整数类型
typedef signed char             int_least8_t;
typedef short                   int_least16_t;
typedef int                     int_least32_t;
typedef long long               int_least64_t;
typedef unsigned char           uint_least8_t;
typedef unsigned short          uint_least16_t;
typedef unsigned int            uint_least32_t;
typedef unsigned long long      uint_least64_t;
// 3. 最快最小宽度类型
typedef signed char             int_fast8_t;
typedef int                     int_fast16_t;
typedef int                     int_fast32_t;
typedef long long               int_fast64_t;
typedef unsigned char           uint_fast8_t;
typedef unsigned int            uint_fast16_t;
typedef unsigned int            uint_fast32_t;
typedef unsigned long long      uint_fast64_t;
// 4. 系统的最大整数类型
typedef long long               intmax_t;
typedef unsigned long long      uintmax_t;
```

`int_least8_t` 是可容纳 8 位有符号整数值的类型中宽度最小的类型的一个别名。如果某系统的最小整数类型是 16 位，可能不会定义 ```int8_t``` 类型。该系统仍可使用 ```int_least8_t``` 类型，但可能把该类型转换为 16 位的整数类型。
`int_fast8_t` 被定义为系统中对 8 位有符号值而言运算最快的整数类型的别名。
C99 定义了最大的有符号整数类型 ```intmax_t```，可储存任何有效的有符号整数值。类似地，```unitmax_t``` 表示最大的无符号整数类型。这些类型有可能比 ```long long``` 和 ```unsigned long``` 类型更大。

>---
#### 5.3. Char

`char` 用于储存字符，技术层面本质是整数类型。```wchar_t``` 是 ```char``` 的宽字符版本。计算机使用数字编码来处理字符，用特定的整数表示特定的字符（常用编码 ASCII）。
常规 ```char``` 字符类型的宽度为 8 位，代表执行字符集；宽字符常量的宽度为 16 位，用于指定扩展执行字符集的成员，多字节字符是由一个或多个字节的序列构成的字符，常用于日文、中文等字符集字符表示。宽字符使用 L 前缀标明字符类型。

 ```c
// 声明字符类型
	char c = 'A';
// char 小整数
	unsigned char c_num = 1;
	signed char c_num = -2;
// 宽字符
	wchar_t CN_Str = L'宽';
```

转义序列被视为单个字符，是有效的字符常量。通常用于指定操作。

```
\a      警报
\b      退格
\f      换页
\n      换行
\r      回车
\t      水平制表符
\v      垂直制表符
\\      反斜杠
\'      单引号
\"      双引号
\?      问号
\o nn   八进制表示法的 ASCII 字符
\x hh   十六进制表示法的 ASCII 字符
\x hhhh 十六进制表示法的 Unicode 字符
```

> *双标符（替用记号）与三标符*

```c
// 双标符
{	<%		}	%>
[	<:		]	:>
# 	%:		##	%:%:

// 三标符
{	??<		}	??>
[	??(		]	??)
#	??=		\	??/
^	??'		|	??!
~	??-

//---------------------------
%:include <stdlib.h>
%:include <stdio.h>
%:include <iso646.h>

int main(int argc, char** argv)
??<
    if (argc > 1 and argv<:1:> not_eq NULL)
    <%
       printf("Hello%s\n", argv<:1:>);
    %>

    return EXIT_SUCCESS;
??>
```

>---
#### 5.4. Bool


```bool``` 类型布尔值；1 表示 ```true```，0 表示 ```false```。```_Bool``` 类型实际上是一种整数类型，仅占用 1 bit。

```c
bool t = true;    // 1
bool f = false;    // 0
```

>---
#### 5.5. Float-point

`float` 类型必须至少能表示 6 位有效数字，且取值范围至少为 10<sup>-37</sup>～10<sup>+37</sup>。
`double` 双精度浮点类型，最小取值范围与 ```float``` 相同，最少能表示 10 位有效数字，占用大小 64 位，32 位表示指数部分，32 位表示非指数部分。```double``` 的值至少有 13 位有效数字。
当浮点值出现上溢（overflow）时，```printf``` 数值会显示为 ```inf``` 或 ```infinity```。下溢时（underflow），可能会发生精度丢失。关于浮点数的未定义行为，例如被 0 除，将返回 ```NaN```。

```c
// 1. 单精度浮点数
   	float num1 = 3.14f;
// 2. 双精度浮点数
   	double num2 = 3.1415;
// 3. 长浮点数, 至少与 double 精度相同
	long double num3 = 3.14L;
// 4. 有效浮点数声明
	3.14, .2, 4e16, .8e55, 99.
```

> *十六进制浮点数（C99）*

- 0x 作为十六进制前缀，用 p 和 P 代替 e 和 E，用 2 的幂代替 10 的幂（P 计数法）。
- 并非所有的编译器都支持 C99 的这一特性。

```c
double num = 0xa.1fp10;
/*
	a   ---- 10
	.1f ---- 1/16 + 15/256
	p10 ---- 2^10
*/
0xa.1fp10 = (10 + 1/16 + 15/256) * 2^10 = 10364.0
```

>---
#### 5.6. Enum

枚举（enumerated type）由一组命名整数常量构成，它定义了一组已命名的整数标识符。所有的枚举类型都具有基础类型，基础类型可以使用枚举类型说明符显式指定，并且枚举项的值是其固定的基础类型；若未显式指定，则基础类型是枚举的兼容类型，该类型是 `char` 或标准或扩展的有符号或无符号整数类型。

枚举项关联常量值默认从 0 开始, 后面的成员依次递增；指定常量值时，顺次项依次递增。枚举项可以进行自增自减运算。

```c
enum DAY{
    saturday, // 0
    sunday = 0,
    monday,  // 1
    tuesday, // 2
    wednesday,
    thursday,
    friday
} workday;
```

对于具有固定基础类型的枚举，定义枚举常量值的整数常量表达式应可在该固定基础类型中表示。枚举常量的值不能超过其基础类型的范围，递增的成员枚举值不能溢出基础类型值的最大值。对于没有固定基础类型的枚举，定义枚举常量值的表达式应为整数常量表达式。

具有固定基础类型的枚举声明：

```c
enum Month : unsigned char
{
    Jan = 1, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec
}

enum E1: short;
enum E1{
    /* ... */
}
```

>---
#### 5.7. Struct

“结构声明” 用于为类型命名和指定一系列可具有不同类型的变量值（称为结构的 “成员” 或 “字段”），描述了一个组织布局。结构的声明有模板声明与类型声明，模板声明可以不含有标记。结构不能包含其自身的实例，但可以包含指向自身实例的指针。
当两个结构变量的类型相同，可以将一个结构赋值给另一个结构（与简单数据结构相同的行为，数组不可以）。

```c
#include <stdio.h>
struct book{
	const char * Name;
	int cost;
};
int main(void){
// 1. 外部声明
	struct book myBook;
	myBook.Name = "Ychao";
	myBook.cost = 99;
// 2. 块初始化
	struct book myBook2 = {
		"Ychao",99,
	};
// 3. 指定初始化器
	struct book mBook3 ={
		.Name = "Ychao",
		.cost = 99,
	};
// 4. 无标识符结构变量
	struct{
		const char * Name;
		int cost;
	} MBook = {
		.Name = "Ychao",
		.cost = 99,
	};
}
```

嵌套结构可以访问，就像它们是在文件范围级别声明的一样。

```c
// 嵌套结构
struct a{
    int x;
    struct b
    {
      int y;
    } var2;
} var1;
// 合法声明
struct a var3;
struct b var4;
/*-------- 匿名结构 -------*/
struct{
    int x;
    int y;
} mystruct;
```

具有多个命名成员的结构的最后一个成员可以是具有不完整的数组类型，这样的数组成员称为 **灵活数组** 成员。这样的结构（以及任何包含这种结构的联合）不应是结构的成员或数组的元素。在大多数情况下，将忽略灵活数组成员。`sizeof` 运算符在计算结构的大小时会忽略灵活数组成员。

通过结构访问该灵活数组就好像该成员被替换为具有相同元素类型的最长数组，该数组不会使结构体大于被访问的对象；该数组的偏移量应保持该灵活数组成员的偏移量，即使它与替换数组的偏移量不同。如果这个数组没有元素，则访问该数组元素或生成一个指针，行为未定义。

```c
struct Sample
{
    int len;
    int arr[];
};
struct Sample *Init(int len);
struct Sample *Init(int len)
{
    struct Sample *rt = calloc(1, sizeof(struct Sample) + sizeof(int [len]));
    rt->len = len;
    return rt;
}
int main(void)
{
    struct Sample *parr = Init(10);

    for (size_t i = 0; i < parr->len; i++)
        parr->arr[i] = i * i;

    printf("%d", parr->arr[parr->len - 1]);
    free(parr);
}

// 对于 struct Sample {int len; int arr[];};
struct Sample *s1 = malloc(sizeof(struct Sample) + 32);
struct Sample *s2 = malloc(sizeof(struct Sample) + 22);
// 假设 malloc 成功分配，s1 和 s2 的行为相当于
struct {int len; int arr[8];} *s1;
struct {int len; int arr[5];} *s2;
```



对于 `*s1 = *s2` 赋值，仅复制成员 `len`；如果任何数组元素位于结构的第一个 `sizeof(struct Sample)` 字节内，则它们被设置为不确定表示形式，该表示形式可能与源数组元素的表示形式副本一致，也可能不一致。

> *结构成员的填充与对齐:*

结构成员按其声明顺序进行存储，第一个成员的内存地址最低，最后一个成员的内存地址最高。

> *结构体的对齐步骤：*

结构体各成员对齐 ➡ 结构体总体对齐。

> *结构体对齐规则：*

第一个数据成员存放的地址为结构体变量偏移量为 0 的地址处。
其他结构体成员自身对齐时，存放的地址为 min { 有效对齐值为自身对齐值，对齐系数 } 的最小整数倍的地址处（其中，自身对齐值表示成员的自身大小；**对齐系数** 指宏定义 pack 指定值或机器位数）。
总体对齐时，结构体字节大小为 min { 所有成员中自身对齐值最大的，对齐系数 } 的整数倍。

> *对齐系数：*

对齐系数：宏 ```#pragma pack(N)``` 指定的值，N 一定是 2 的幂次方，1、2、4 等。
默认指定对齐值：32 位 Linux 主机的默认对齐值为 4；64 位为 8；AMR CPU 默认指定对齐值为 8。
`#pragma pack(N)` 每个特定平台上的编译器都有自己的默认 “对齐系数”（也叫对齐模数），可以自定义为编译器指定对齐系数。

> *对齐实例：*

 ```c
//此代码在 64 位 Linux 下编写，默认系数为 8
typedef struct _st_struct1
{
	char 	a;		// 1
	short   b;		// 2
	int		c;		// 4
} st_struct1;

printf("%ld\n",sizeof(st_struct1)); // size = 8
/* PS
1. a 是 char 类型，占 1 个字节，第一个数据成员，放在结构体变量偏移量为 0 的地址处
2. b 是 short 类型，占 2 个字节，b 的有效对齐值为 min{2, 8}=2；
   依次查看 2 的整数倍地址是否可以存放 2 个字节；
   	【2×0 = 0】 此地址处已经存放 a
   	【2×1 = 2】 此地址为空，可以将 b 存放在地址偏移量为 2 和 3 处.
3. c 是 int 类型，占 4 个字节，c 的有效对齐值为 4
   对齐到 4 的整数倍地址，即地址偏移量为 4 处.在内存中存放的位置为 4,5,6,7

4. 结构体总对齐字节大小为 min{4, 8}=4 的整数倍，此时内存中共占 8 个字节，正好是 4 的整数倍，所以 sizeof(st_struct1) = 8
*/

//此代码在 64 位 Linux 下编写
typedef struct _st_struct2
{
	char    a; // 地址位 0
	int     c; // 地址位 4
	short   b; // 地址位 8
} st_struct2;

printf("%ld\n",sizeof(st_struct2));	// size = 12
```

> *指定对齐值实例：*

使用 ```#pragma pack(N)``` 设置结构体边界时，最好使用一次 ```#pragma unpack()```， 否则在它之后定义的所有结构体都会按 N 字节对齐。

```c
//此代码在64位Linux下编写
#pragma pack(1)
/*
    对齐遵循始终寻址为 1 的倍数的地址，根据对齐规则，总体的结构体大小为 7
*/

typedef struct _st_struct3
{
 	char    a;  // 地址位 0
	int     c;  // 地址位 1
	short   b;  // 地址位 5
} st_struct3;

printf("%ld\n", sizeof(st_struct3)); // 7

#pragma unpack()
// 恢复系统默认的对齐特性
```

> *把结构内容保存在文件中：*

由于结构可以储存不同类型的信息，所以它是构建数据库的重要工具。数据库文件可以包含任意数量的此类数据对象。储存在一个结构中的整套信息被称为记录（record），单独的项被称为字段（field）。

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAXTITL 40
#define MAXAUTL 40
#define MAXBKS 10 /* 最大书籍数量 */
char *s_gets(char *st, int n);
struct book /* 建立 book 模板 */
{
    char title[MAXTITL];
    char author[MAXAUTL];
    float value;
};
int main(void)
{
    struct book library[MAXBKS]; /* 结构数组 */
    int count = 0;
    int index, filecount;
    FILE *pbooks;
    int size = sizeof(struct book);
// 1. fopen 二进制读写 a 模式
    if ((pbooks = fopen("book.dat", "a+b")) == NULL)
    {
        fputs("Can't open book.dat file\n", stderr);
        exit(1);
    }
// 2. 定位到文件开始
    rewind(pbooks);
// 3. 预先 fread 读取 book.dat 中的二进制数据 (library: 并输出)
    while (count < MAXBKS && fread(&library[count], size, 1, pbooks) == 1)
    {
    // 读取 book 并赋值给 library 数组中的结构体
        if (count == 0)
            // 打印当前 book 中的数据
            puts("Current contents of book.dat:");
        printf("%s by %s: $%.2f\n", library[count].title,
                library[count].author, library[count].value);
        count++;
    }
    filecount = count;
    // 验证当前 book 容量是否满
    if (count == MAXBKS)
    {
        fputs("The book.dat file is full.", stderr);
        exit(2);
    }
// 4. 输入数据并保存在 book.dat 中
    puts("Please add new book titles.");
    puts("Press [enter] at the start of a line to stop.");
    while (count < MAXBKS && s_gets(library[count].title, MAXTITL) != NULL && library[count].title[0] != '\0')
    {
        puts("Now enter the author.");
        s_gets(library[count].author, MAXAUTL);
        puts("Now enter the value.");
        scanf("%f", &library[count++].value);
	    while (getchar() != '\n')
            continue; /* 清理输入行 */
        if (count < MAXBKS)
            puts("Enter the next title.");
    }
// 5. 输入结束输出 book.dat 内容
    if (count > 0)
    {
        puts("Here is the list of your books:");
        for (index = 0; index < count; index++)
            printf("%s by %s: $%.2f\n", library[index].title,
                    library[index].author, library[index].value);
        fwrite(&library[filecount], size, count - filecount,
                pbooks);
    }
    else
        puts("No books? Too bad.\n");
    puts("Bye.\n");
    fclose(pbooks);
    return 0;
}
char *s_gets(char *st, int n)
{
    char *ret_val;
    char *find;
    ret_val = fgets(st, n, stdin);
    if (ret_val)
    {
        // 查找换行符
        find = strchr(st, '\n');
        // 如果地址不是 NULL，
        if (find)
            // 在此处放置一个空字符
            *find = '\0';
        else
            // 清理输入行
            while (getchar() != '\n')
                continue;
    }
    return ret_val;
}
```

>---
#### 5.8. Union

“联合声明” 指定一组变量值和（可选）一个命名联合的标记。变量值称为联合的 “成员”，并且可以具有不同的类型，能在同一个内存空间中储存不同的数据类型（不是同时储存）。联合的字节大小与成员中的最大字节数相同。使用联合未初始化的成员时的行为是不确定的（存在精度损失问题），应使用被初始化的成员对象。

联合可以具有位域，但不能包含不完整类型、类型 ```void``` 或函数类型。成员不可以是联合的实例，但可以声明联合类型的指针。


> *联合的存储*

- 与联合变量关联的存储是联合的最大成员所需的存储。
- 在存储较小的成员时，联合变量可以包含未使用的内存空间。
- 所有成员都存储在同一内存空间中并以相同的地址开始。每次将值赋给不同的成员时，都会重写存储的值。

> *联合的声明与初始化*

```c
// 声明
union sign
{
    int svar;
    unsigned uvar;
};	// size = 4

// 初始化
union sign digit = {99}; 	// 默认初始化第一个元素
union sign digit2 = digit;	// 用另一个联合初始化
union sign val = {.uvar = 100};	// 指定初始化器
```

> *联合常嵌套在一个结构中*

```c
struct x
{
    int type_tag;
    union
    {
      int x;
      float y;
    };
};
```


>---
#### 5.9. Bit Field

除了结构或联合的成员的声明符外，结构声明符也可以是指定数目的位，称为 “位域”。其长度从字段名称的声明符到冒号。位域被解释为整型类型。

在 ANSI C 标准下，位字段的类型只能是 ```unsigned int```、```signed int``` 和 ```int``` 的一种（包括 ```char```、```short```），C99 和 C11 新增了 ```_Bool``` 类型的位字段。

位字段通过一个结构声明来建立，该结构声明为每个字段提供标签，并确定该字段的宽度。指定位域宽度的表达式应为整数常量表达式，其非负值不超过省略冒号和表达式时指定的类型对象的宽度。如果值为零，则声明中不应有声明符。


```c
struct{
	unsigned int first:4	// 表明该字段占用的 bit
	unsigned int second:2
	unsigned int third:8
} BitDomain[10]
/*
	first 位字段占用 4 个位
	三个位字段保存在一个 int 大小的内存单元中
	单个 BitDomain 元素只是用其中的 14 位
	数组对象使用了 （10 * sizeof int）大小的内存空间
 */

// 具有位域的联合
union{ 		
	unsigned int a:1;
	unsigned int b:4;
	int value;
} BitUnion;	// size = 4
```

在 ANSI C 标准下，```sizeof``` 不能操作 `BitDomain` 的位字段，带有位字段的结构提供一种记录设置的方便途径，位字段的储存顺序自低位到高位方向。
ANSI C 标准规定，位域的宽度不能超过它所依附的数据类型的长度。通俗地讲，成员变量都是有类型的，这个类型限制了成员变量的最大长度。例如 `int` 位字段的最大长度不能超过 32 位。
为位字段赋值，不能超过字段可容纳的范围，例如 `BitDomain.first` 的大小为 4 bits，它的赋值范围为 0~2<sup>4</sup>-1。

```c
struct{
	unsigned int first : 4; // 表明该字段占用的 bit
	unsigned int second : 2;
	unsigned int third : 8;
} BitDomain = {
	.first = 0b0010,
	.second = 0b10,
	.third = 0b10100101
};
```

声明的总位数超过一个 ```unsigned int``` 的大小时，会自动溢出到下一个 ```unsigned int``` 类型的存储位置。
一个字段不允许跨越两个 ```unsigned int``` 之间的边界，编译器会自动移动跨界的字段，从而保持 ```unsigned int``` 之间的边界对齐。

```c
struct
{
    unsigned int first : 9;
    unsigned int second : 7;
    unsigned int may_straddle : 30;
    unsigned int last : 18;
} Bits;

printf("%zd", sizeof Bits); // 防止跨越，将为 12 B
```

> *位字段的填充和对齐*

- 使用一个宽度为 0 的未命名字段迫使下一个字段与下一个整数对齐。
- 当未命名字段宽度大于 0 时，会使两个字段之间产生一个不可访问的未命名位字段填充。

```c
struct {
	unsigned int field_0;   // 成员 field_0 没有限制，占用 4B;
	unsigned int field_1 : 1 ;
	unsigned int : 2 ;      // 2 位的填充
	unsigned int field_2 : 1 ;
	unsigned int : 0 ;      // 迫使下一个位字段与 int 边界对齐
	unsigned int field_3 : 1 ;
} BitDomain;
```

> *位域的存储*

- 当相邻成员的类型相同时，如果它们的位宽之和小于类型的 ```sizeof``` 大小，那么后面的成员紧邻前一个成员存储，直到不能容纳为止。
- 当它们的位宽之和大于类型的 ```sizeof``` 大小，那么后面的成员将从新的存储单元开始，其偏移量为类型大小的整数倍。
- 当相邻成员的类型相同时，成员之间会趋向紧凑排列；当不同时，顺位成员会进行偏移存储，并遵循结构体的对齐原则。

>---
#### 5.10. Array

“数组声明” 将命名数组并指定其元素的类型，其特征是元素的类型相同。数组类型的变量被视为指向数组首元的指针。
一般地，声明数组时需要指定数组的长度，初始化器初始化数组时，元素数目不能超过声明数组的长度；当初始化列表中的值少于数组元素个数时，编译器会把剩余的元素都初始化为类型默认值。C 数组不允许声明零长度数组，试探性声明的数组默认为具有一个数值为 0 的类型数组。

```c
// 1. 数组的声明包括数据类型与数组大小
	int IntArr[COUNT];
// 2. 初始化
	int Arr[5] = {0,1,2,3,4};           // 初始化器传统方式
	char Str[] = "This is a String";    // 自动确定长度
	int Arr[5] = {[2] = 2};             // 指定初始化器

//------ 试探性声明 ------
int[] a;  // 行为被暂认为是 a = {0}

// 3. 多维数组
int Arr[length0][length1];
int Arr[3][3][3][3];  //......多维数组
int Array[4][4] = {
	{1,2,3,4},
    {10,20,30,40},
    {100,200,300,400},
    {0,0,0,0}
}
int arr[2][3] = {1,2,3,4,5,6};  // 顺序初始化
```

`Arr [ 可选类型限定符/static ]` 只能出现在具有数组类型的函数参数的声明中，并且只能出现在最外层的数组类型派生中。

```c
int fun1(int a, int arr[static a]);
int fun2(int arr[restrict const static 5]);
```

如果数组标识符被声明为具有可变修改的类型，则它应该是一个普通的标识符，没有链接，且具有块作用域或函数原型作用域。如果标识符声明为具有静态或线程存储持续时间的对象，则它不应具有可变长度数组类型。

> *结构中的灵活数组成员（C99）*

- C99 新增了一个特性：灵活数组成员（flexible array member），该结构的最后一个成员具有一些特性。
- 该数组不会立即存在，使用这个灵活数组成员可以编写合适的代码，就好像它确实存在并具有所需数目的元素一样。

```c
struct flex{
	int count;
	double average;
	double scores[];
// 灵活数组成员, 要求不声明大小, 必须是最后一个, 结构中至少有一个非灵活数组成员
}
```

- 声明一个 ```struct flex``` 类型的结构变量时，不能用 ```flex.scores``` 做任何事，因为没有给这个数组预留存储空间。
- C99 意图声明一个指向 ```struct flex``` 的指针, 然后用 ```malloc``` 分配足够的空间, 以存储 ```struct flex``` 结构的常规内容与灵活数组成员所需的额外空间。
- 不可以将带有灵活数组的结构赋值给同类型结构变量。

```c
struct flex * pf;
pf = malloc(sizeof(struct flex) + 5 * sizeof(double));
// 分配一个内含 5 个 double 类型的数组的 flex
```

> 可变长度数组（VLA）

可变修改（VM）类型的所有有效声明都位于块作用域或函数原型作用域。使用 `thread_local`、`static`、`extern` 存储类说明符声明的数组对象不能具有可变长度数组类型（VLA）类型。使用 `static` 存储类说明符声明的对象可以具有 VM 类型（即指向 VLA 类型的指针）。最后，只能使用 VM 类型声明普通标识符，因此，具有 VM 类型的标识符不能是结构或联合的成员。

```c
extern int n;
int A[n];                       // invalid: file scope VLA
extern int (*p2)[n];            // invalid: file scope VM
int B[100];                     // valid: file scope but not VM
void fvla(int m, int C[m][m]);  // valid: VLA with prototype scope
void fvla(int m, int C[m][m])   // valid: adjusted to auto pointer to VLA
{
    typedef int VLA[m][m];      // valid: block scope typedef VLA
    struct tag
    {
        int (*y)[n];            // invalid: y not ordinary identifier
        int z[n];               // invalid: z not ordinary identifier
    };
    int D[m];                   // valid: auto VLA
    static int E[m];            // invalid: static block scope VLA
    extern int F[m];            // invalid: F has linkage and is VLA
    int(*s)[m];                 // valid: auto pointer to VLA
    extern int(*r)[m];          // invalid: r has linkage and points to VLA
    static int(*q)[m] = &B;     // valid: q is a static block pointer to VLA
}
```

未指定绑定的 `arr[*]` 可以在数组大小表达式中使用，但不能直接作为参数声明的抽象声明符嵌套序列的一部分：

```c
void f1(int [*]);                       // valid
void f2(int (*)[sizeof(int (*)[*])]);   // invalid
```

>---
#### 5.11. Pointer

“指针声明” 可命名指针变量并指定该变量所指向的对象的类型。声明为指针的变量保留了一个内存地址；可以为任何基本、结构或联合类型、函数、数组和其他指针对象创建关联指针。

指针的默认类型是 ```void*```，声明为指向 ```void``` 的指针的变量可用于指向任何类型的对象。除 ```char*``` 类型外，```void``` 指针转换为其他类型的指针时需要类型强制转换。
指针类型可以是 ```const``` 和 / 或 ```volatile```，分别指定指针不能被程序本身修改，或指针可以被超出程序的控制范围的某进程以合法方式修改。

在同一 CPU 架构下，不同类型的指针变量所占用的存储单元是相同的，但存放数据的变量因数据的类型不同，所占用的存储空间长度也不同。指针描述了数据在内存中的位置，标示了一个占据存储空间的实体，其特点是可对存储数据的变量地址进行操作。
创建一个指针时，系统只分配了储存指针本身的内存，并未分配储存数据的内存。在使用指针之前，必须先用已分配的地址初始化它。之后才可以进行解引用的操作。

```c
// 【&】地址运算符用于获取类型的内存地址
// 【*】解引用运算符用于获取指针变量指向地址的值
int number = 10;
int *pN = &number;

int rt = *pN;	// 10

// ---- 不可解引用未初始化的指针 ----
int * pt;	// 未初始化的指针，其值不确定
*pt = 5; 	// ERROR：未定义行为
```

> *按字节寻址系统（如 PC）*

- 变量的名称、地址和变量的值之间关系密切，指针获取变量的机器码地址，变量保存数据的类型，数据的类型决定了值在内存中的字节大小，在该内存位置保存变量的值。
- 普通变量把值作为基本量，把地址作为通过 ```&``` 运算符获得的派生量；而指针变量把地址作为基本量，把值作为通过 ```*``` 运算符获得的派生量。
- 一元 `&` 地址运算符的操作数必须是函数指数符、`[]` 或一元 `*` 操作符的结果，也可以是指定非位域且未使用 `register` 存储类说明符声明的对象的值。一元 `*` 运算符的操作数应是指针类型。

> *指针与地址的关系*

- 指针的值是它所指向对象的地址。地址的表示方式依赖于计算机内部的硬件。
- 许多计算机（包括 PC 和 Mac）都是按字节编址，意思是内存中的每个字节都按顺序编号。
- 一个较大对象的地址（如 ```double``` 类型的变量）通常是该对象第一个字节的地址。
- 在指针前面使用 ```*``` 运算符可以得到该指针所指向对象的值。
- 指针加 1，指针的值递增它所指向类型的大小（以字节为单位）。

> *指针基本操作*

```c
#include <stdio.h>
int main(void)
{
	int urn[5] = { 100, 200, 300, 400, 500 };
	int* ptr1, * ptr2, * ptr3;
	ptr1 = urn;				// 把一个地址赋给指针
	ptr2 = &urn[2];			// 把一个地址赋给指针
	printf("pointer value, dereferenced pointer, pointer address : \n");
// 1. 解引用指针，以及获得指针的地址
	printf("ptr1 = %p, *ptr1 = %d, &ptr1 = %p\n", ptr1, *ptr1, &ptr1);
	printf("ptr2 = %p, *ptr2 = %d, &ptr2 = %p\n", ptr2, *ptr2, &ptr2);
// 2. 指针加法
	ptr3 = ptr1 + 4;
	printf("\nadding an int to a pointer:\n");
	printf("ptr1 + 4 = %p, *(ptr1 + 4) = %d\n", ptr1 + 4, *(ptr1 + 4));
// 3. 递增指针
	ptr1++;
	printf("\nvalues after ptr1++:\n");
	printf("ptr1 = %p, *ptr1 = %d, &ptr1 = %p\n", ptr1, *ptr1, &ptr1);
// 4. 递减指针
	ptr2--;
	printf("\nvalues after ptr2--:\n");
	printf("ptr2 = %p, *ptr2 = %d, &ptr2 = %p\n", ptr2, *ptr2, &ptr2);
	--ptr1; // 恢复为初始值
	++ptr2; // 恢复为初始值
	printf("\nPointers reset to original values:\n");
	printf("ptr1 = %p, ptr2 = %p\n", ptr1, ptr2);
// 5. 一个指针减去另一个指针
	printf("\nsubtracting one pointer from another:\n");
	printf("ptr2 = %p, ptr1 = %p, ptr2 - ptr1 = %td\n", ptr2, ptr1, ptr2 - ptr1);
// 6. 一个指针减去一个整数
	printf("\nsubtracting an int from a pointer:\n");
	printf("ptr3 = %p, ptr3 - 2 = %p\n", ptr3, ptr3 - 2);

	return 0;
}
/*
	pointer value, dereferenced pointer, pointer address :
	ptr1 = 010FFC9C, *ptr1 = 100, &ptr1 = 010FFC90
	ptr2 = 010FFCA4, *ptr2 = 300, &ptr2 = 010FFC84

	adding an int to a pointer:
	ptr1 + 4 = 010FFCAC, *(ptr1 + 4) = 500

	values after ptr1++:
	ptr1 = 010FFCA0, *ptr1 = 200, &ptr1 = 010FFC90

	values after ptr2--:
	ptr2 = 010FFCA0, *ptr2 = 200, &ptr2 = 010FFC84

	Pointers reset to original values:
	ptr1 = 010FFC9C, ptr2 = 010FFCA4

	subtracting one pointer from another:
	ptr2 = 010FFCA4, ptr1 = 010FFC9C, ptr2 - ptr1 = 2

	subtracting an int from a pointer:
	ptr3 = 010FFCAC, ptr3 - 2 = 010FFCA4
*/
```

> *指向结构或联合的指针*

- 像指向数组的指针比数组本身更容易操控（如, 排序问题），指向结构的指针通常比结构本身更容易操控，在函数中传递结构指针比传递结构本身效率更高。对于指向结构或联合的指针，使用 `->` 访问指向对象的成员。
- 在一些早期的 C 实现中，结构不能作为参数传递给函数，但是可以传递指向结构的指针。
- 一些用于表示数据的结构中包含指向其他结构的指针。

```c
struct book{
	int cost;
} bp;
struct book * pbook = &bp;
pbook->cost = 99;		// -> 访问指针关联结构成员，等价于 bp.cost

pbook->cost = (*pbook).cost = bp.cost
```

> *结构中的字符数组和字符指针*

```c
// 1. 字符串数组作为成员
struct name{
	char first[LEN];
	char last[LEN];
};
// 2. 字符指针作为成员
struct pname{
	char * first;
	char * last;
};
struct name veep = {"Talia", "Summers"};
struct pname treas = {"Brad", "Fallingjaw"};
```

- name 结构将两个固定大小的数组用于储存姓名, 字符串储存在结构内部。
- pname 结构保存了两个指针变量, 它使用的是储存在别处的字符串 (字符串常量或数组中的字符串)。
- 由于 pname 中的指针是未初始化的变量, 因此地址可以是任何值, 为其赋值可能会修改掉原有的程序数据, 直接赋值操作可能会导致程序的崩溃。
- 因此，如果要用结构储存字符串，用字符数组作为成员比较保险。用指向 ```char``` 的指针也行，但是误用会导致严重的问题，可以预先使用 ```malloc``` 分配空闲内存。

> *指针和数组的关系*

- 数组标识符实质上指向了数组首元素的地址。数组内相邻元素地址对应关系：```&arr[n+1] = &arr[n]+1```。
- 指针类型加 1 表示增加一个存储单元，对于组数表示下一个元素地址，而不是表示下一个字节地址，因此这就要求指针与指向对象类型相对应（例如，`pti` 的类型是 ```short``` 类型，```pti + 1```，其值每次递增 2 字节）。
- 在数组中，定义 ```arr[n]``` 的含义是 ```*(arr + n)``` （其中 ```arr = &arr[0]```）。

```c
int arr[10] = {99};
if (arr == &arr[0])
{
	// arr 值等于 &arr[0]
	printf("\n%d",*arr);	// 99
}

int *pArr = arr;
// 等价于
int *pArr = &arr[0];
```

> *指针表示法与数组表示法*

- 处理数组的函数实际上用指针作为参数，但是在编写这样的函数时，可以选择是使用数组表示法还是指针表示法。
- 对于 ```int Arr[Size]``` 数组，```*(Arr+i)``` 与 ```Arr[i]``` 等价，但指针表示法（尤其与增量运算符一起使用时）更接近于机器语言，编译时能够生成效率更高的代码。

> *指向多维数组的指针*


```c
int main(void) {
	int(Arr[2])[3] = {		// 二维数组
		{1,2,3},
		{2,3,4}
	};
	int Arr1[] = { 1,2,3,4 };

	int* pr[2] = { Arr1, &Arr1[1] };	// pr 是一个包含两个指针元素的数组

	int(*pr1)[3] = Arr;				// pr1 指向一个内含两个 int 类型值的数组

	for (size_t i = 0; i < 2; i++)
	{
		printf("%p\n", pr1[i]);
		printf("%p\n", Arr[i]);
	}
}

// 对于 ```Arr[n][m][i][l]...``` 数组

int Arr[a][b][c][d];
int(*pr)[b][c][d] = Arr;

Arr[0][0][0][0] = ****pr = pr[0][0][0][0];
```

>---
#### 5.12. String

字符串字面量是用双引号括起来的零个或多个多字节字符的序列，用于表示以 `\0` 结尾的字符串的字符序列。UTF-8 字符串字面量以 `u8` 为前缀，`wchar_t` 字符串字面量以 `L` 为前缀，UTF-16 字符串字面量以 `u` 为前缀，UTF-32 字符串字面量以 `U` 为前缀。`wchar_t`、`char16_t`、`char32_t` 字符串字面量统称为宽字符串字面量。

```c
char8_t* s8 = u8"Hello";
char* s = "Hello";
wchar_t * ws = L"Hello";
char16_t * s16 = u"Hello"; 
char32_t * s32 = U"Hello"; 
```

如果相邻字符串文字标记的序列包括带前缀的字符串文字标记，则带前缀的标记应全部具有相同的前缀（或没有前缀）。

```c
"a" "b" L"c"
"a" L"b" "c"
L"a" "b" L"c"
L"a" L"b" L"c"
// 等同于
L"abc"
```

> *字符串字面量的类型*

- 字符串字面量是具有 ```char``` 的类型数组（宽字符字符串是具有 ```wchar_t```  的类型数组）。
- 文本字符串的字符将按顺序存储在连续内存位置，```null``` 字符（```\0```）自动追加到每个字符串并标记该字符串的末尾。
- **编译器无法在两个不同的地址存储两个相同的字符串**，```/GF```（消除重复的字符串，编译器优化策略）强制编译器将相同字符串的单个副本置于可执行文件中。

```c
char *str1 = "Hello";
char *str2 = "Hello";

int main(void)
{
	printf("pStr1: %p\n",str1);
	printf("pStr2: %p\n",str2);
}
/*
pStr1: 0000000000404000
pStr2: 0000000000404000
*/
```

若要形成占用多行的字符串文本，则可以将两个字符串串联起来。为此，请键入反斜杠。

```c
/* 串联一 */
"Long strings can be bro\
ken into two or more pieces."
  >>> 等价于
"Long strings can be broken into two or more pieces."

/* 串联二 */
char *string = "This is the first half of the string, "
               "this is the second half";
```

ANSI C 兼容性要求编译器在串联后接受字符串中最多 509 个字符。
Microsoft C 允许的字符串的最大长度约为 2048 个字节，若字符串由多个双引号部分构成，对于串联的每个行，预处理器会将一个额外的字节添加到总字节数。若使用行继续符（```\```）代替双引号，则预处理器不会为每个行添加一个额外字符。

> *格式转换说明符*

```powershell
%a，%A      浮点数、十六进制数和p，P计数法（C99，C11）
%c          单个字符
%d          有符号十进制数
%e，%E      浮点数，e计数法
%f          浮点数，十进制
%g，%G      自动选择%f 或 %e
%i          有符号十进制整数
%o          无符号八进制整数
%p          指针
%s          字符串
%u          无符号十进制整数
%x，%X      无符号十六进制整数，使用十六进制数 0f，0F
%%          打印一个百分数符号 %
```

格式字符串中的转换说明一定要与后面的每个项相匹配，若忘记这个基本要求会导致严重的后果。如果只打印短语或句子，就不需要使用任何转换说明。

> *转换说明修饰符*

  在 ```%``` 和转换字符之间插入修饰符可修饰基本的转换说明。

```c
标记        -、+、空格、#、0，可以不使用标记或使用多个标记
数字        表示最小字段宽度

.数字       精度：%e、%E、%f 转换表示小数位位数
                %g、%G 转换表示有效数字的最大位数
                %s 转换表示待打印字符的最大数量
                整型转换，表示待打印数字的最小位数
                只使用 . 表示其后紧随一个0, %.f 等同于 %.0f;

h           与整型转换说明一起使用，表示 (unsigned) short int
hh          与整型转换说明一起使用，表示 signed char 或 unsigned char
j           与整型，表示 intmax_t 和 uintmax_t 类型
l           与整型，表示 (unsigned) long int
ll          与整型，表式 (unsigned) long long int
L           与浮点型，表示 long double
t           与整型，表示 ptrdiff_t (两个指针差值)
z           与整型，表示 size_t 类型，为 sizeof 返回类型
```

```%zd```  返回的类型规定为无符号整数，不同系统中，可能使用 ```%u```，```%lu```，```%llu```。

> *printf 中的标记*
 
 ```c
-       待打印项左对齐
+       显示数值符号，符号为正显示 +，符号为负显示 -
空格    有符号值若为正，在值前面显示前导空格；负则显示减号；+ 覆盖标记空格

%o          显示八进制前缀, 结果以 0 开始
%#x/%#X     显示十六进制前缀, 结果以 0x、0X 开始
%#g/%#G	    防止结果后面的 0 被删除(近似数)
0N          N 数值类型，用前导 0 代替空格填充字段宽度
整数        出现 - 左对齐标记或者指定精度，则忽略前导 0
```

> *格式输出案例*

- 字符宽度

```c
#include <stdio.h>
#define PAGES 959
int main(void)
{
    printf("*%d*\n", PAGES);
    printf("*%2d*\n", PAGES);
    printf("*%10d*\n", PAGES);
    printf("*%-10d*\n", PAGES);

    return 0;
}
/*
    *959*
    *959*
    *       959*
    *959       *
*/
```

- 一些浮点型修饰符的组合

```c
#include <stdio.h>
int main(void)
{
    const double RENT = 3852.99; // const变量
    printf("*%f*\n", RENT);
    printf("*%e*\n", RENT);
    printf("*%4.2f*\n", RENT);
    printf("*%3.1f*\n", RENT);
    printf("*%10.3f*\n", RENT);
    printf("*%10.3E*\n", RENT);
    printf("*%+4.2f*\n", RENT);
    printf("*%010.2f*\n", RENT);
    return 0;
}
/*
    *3852.990000*
    *3.852990e+03*
    *3852.99*
    *3853.0*
    *  3852.990*
    * 3.853E+03*
    *+3852.99*
    *0003852.99*
 */
```

- 一些格式标记

```c
#include <stdio.h>
int main(void)
{
    printf("%x %X %#x\n", 31, 31, 31);
    printf("**%d**% d**% d**%+d**\n", 42, 42, -42, 42);
    printf("**%5d**%5.3d**%05d**%05.3d**\n", 6, 6, 6, 6);
    return 0;
}
/*
    1f 1F 0x1f
    **42** 42**-42**+42**
    **    6**  006**00006**  006**
*/
```

- 字符串格式

```c
#include <stdio.h>
#define BLURB "Authentic imitation!"
int main(void)
{
	// 最小2宽度
    printf("[%2s]\n", BLURB);
	// 最小24宽度
    printf("[%24s]\n", BLURB);
    // 最小24宽度, 5字符宽度
	printf("[%24.5s]\n", BLURB);
	// 左对齐,最小24宽度,5字符宽度
    printf("[%-24.5s]\n", BLURB);
    return 0;
}
/*
    [Authentic imitation!]
    [    Authentic imitation!]
    [                   Authe]
    [Authe                   ]
*/
```

> *转换说明参数传递机制*

参数传递机制因实现而异
- 就 ```printf("%ld %ld %ld %ld\n", n1, n2, n3, n4)```，对于 ```float``` n1、n2，系统仍会将 ```float (4B)``` 转换成 ```double (8B)``` 储存在 stack 中，n3、n4 紧随压入栈中。
- ```%ld``` 转换说明，取参数读取栈中数据应读取 4 字节的 ```long``` 类型，但将 n1 的前半部分作为第一个参数，后半部分作为第二个参数。因此出现 ```printf``` 读错了字节导致转换说明出错。

```c
float n1= 1.0f, n2 = 2.0f;
long  n3 = 3L, n4 = 4L;
printf("%ld %ld %ld %ld\n",n1, n2, n3, n4); // 0 0 3 4
```

---
### 6. 类型推断

推断类型的声明应包含 `auto` 关键字，对于作为对象的此类声明，初始化声明应具有 `direct-declarator = assignment-expression` 的形式。声明对象的推断类型是左值、数组到指针或函数到指针转换之后的赋值表达式的类型，并由额外的限定符限定。

```c
auto p = (struct {int x; } *)0;  // p 是 struct {int x;} * 
```

`auto` 与 `alignas` 组合： 

```c
auto alignas (struct s *) x = 0;   // 实现定义的行为
```

以下在文件范围定义：

```c
static auto a = 3.5;
auto p = &a;
// 解释为
static double a = 3.5;
double * p = &a;
```

推断类型的标识符的作用域仅在初始值设定项结束之后开始，因此赋值表达式不能使用标识符来引用声明的对象或函数。在初始值设定项中使用标识符是无效的，即使外部作用域中存在具有相同名称的实体也是如此。

```c
{
    double a = 7;
    double b = 9;
    {
        double b = b * b;   // undefined, uses uninitialized
                            // variable without address
        printf("%g\n", a);  // valid, uses "a" from outer scope, prints 7
        auto a = a * a;     // invalid, "a" from outer scope is not
                            // visible during initialization
    }
    {
        auto b = a * a;     // valid, uses "a" from outer scope
        auto a = b;         // valid, "a" from outer scope not visible now
        // ...
        printf("%g\n", a);  // valid, uses "a" from inner scope, prints 49
    }
    // ...
}
```

类型推断可用于捕获对类型泛型函数的调用的类型。它确保使用与参数 x 相同的类型。如果将 y 的类型显式指定为与 x 不同的类型，则不会强制执行不匹配的诊断。

```c
#include <tgmath.h>
auto y = cos(x);
```

具有推断类型的对象的定义在允许初始值设定项语法的所有上下文中都有效。特别是，它们可用于确保 for-loop 控制表达式的类型安全性。

```c
for (auto i = j; i < 2*j; ++i) {
    // ...
}
// 无论 j 类型的整数秩或符号，i 将具有 j 类型的非原子非限定版本
``` 

---
### 7. 类型限定符

```c
const
volatile
restrict
_Atomic
```

- `const` 类型限定符将对象声明为不可修改。
- `volatile` 类型限定符声明一个项，该项的值可由超出该项所在的程序控制范围的某个项（如并发执行的线程）合理更改 （易变的）。
- `restrict` 用于限定指针，出于优化策略，表明该指针是访问数据对象的唯一且初始的方式。但不限定其指向的内容。
- `_Atomic` 声明限定原子类型。

如果数组类型的规范包含任何类型限定符，则数组和元素类型都是限定的。如果函数类型的规范包含任何类型限定符，则行为是未定义的。

```c
// 合法声明
typedef volatile int VI;
const int ci;
// 非法声明
typedef int *i, volatile *vi;
float f, const cf;
```

>---
#### 7.1. const

```c
const int ci;
const int carri[size];
void Func(const int);	// 限定函数形参
```

`const` 指针声明时的注意点：

```c
// * 在 const 后，限定指针指向的值
int const *p_ci;        // 指向整型常量的指针
const int *p_ci;        // 指向整型常量的指针
// * 在 const 前，限定指针
int* const cp_i;        // 指向整型的常量指针
// const 双限定
const int* const cp_ci; // 指向整型常量的常量指针
```

如果通过非 `const` 限定类型的左值修改使用 `const` 限定类型定义的对象，行为未定义。
`const` 与非 `const` 指针间的转换：指向非 ```const``` 类型的指针能隐式转换成指向同一或兼容类型的 ```const``` 限定版本的指针。能用类型强制转换进行逆向转换。

```c
int* p = 0;
const int* cp = p;  // 添加限定符，int 隐式转换到 const int
p = cp;             // ERROR：舍弃限定符（const int 到 int）
p = (int*)cp;       // 强制转换
```

指向指向 ```T``` 指针的指针不可转换为指向指向 ```const T``` 指针的指针；对于要兼容的二个类型，其限定必须等同。

```c
char *p = 0;
const char **cpp = &p; 	// ERROR： char* 与 const char* 不是兼容类型
char * const *pcp = &p; // 添加限定符（ char * 到 char *const ）
```

> *`const` 两种声明方式*

```c
void Func(char* const c);
// 等价于
void Func(char c[const]);
```

>---
#### 7.2. volatile

`volatile` 类型说明符可用于提供对特定内存位置的可靠访问。如果尝试通过使用具有非易失性限定类型的左值来引用使用易失性限定类型定义的对象，则该行为是未定义的。

具有易失性限定类型的对象可能会以实现未知的方式进行修改，或者具有其他未知的副作用。因此，任何提及此类对象的表达都应严格按照抽象机器的规则进行求值。

`volatile` 限定告知计算机，代理（不是变量所在的程序）可以修改该变量的值，一般用于硬件地址以及在其他程序或同时运行的线程中共享数据。

```c
volatile int vol;
void f(double x[volatile], const double y[volatile]);
void f(double * volatile x, const double * volatile y);
```

一个非 ```volatile``` 值到 ```volatile``` 值的转换是无效果的。欲使用 ```volatile``` 语义访问非 ```volatile``` 对象，必须先将其地址转换成指向 ```volatile``` 类型的指针，再通过该指针访问该对象。

```c
int vol;
// 转变为易变对象
volatile int* pVol = &vol;
```

任何通过非 ```volatile``` 左值结果，对拥有 ```volatile``` 限定类型的对象尝试读或写会导致未定义行为。

```c
volatile int n = 1; // volatile 限定类型
int* p = (int*)&n;
int val = *p; // 未定义行为
```

`volatile` 限定的结构体或联合体类型，其成员会自动获取其所属类型的限定。以 ```volatile``` 类型限定符声明数组类型（通过使用 ```typedef``` ），数组类型无 ```volatile``` 限定，但其元素成员有。
`const volatile` 限定：一个项可以同时是 ```const``` 和 ```volatile```，在这种情况下，此项不能被它自己的程序以合法方式修改，但能被一些异步进程修改（例如系统时钟，硬件修改）。
 
 ```c
volatile const int loc;
const volatile int * ploc;
```

> *`volatile` 禁用优化策略*

```c
val1 = x;
//do...不使用 x 的代码
val2 = x;
```

一些编译器会将 x 的值保存在寄存器，当 val2 使用 x 时，并不会从原始内存位置的读取 x 的值，会从寄存器上读取 x，目的是为了程序优化（此过程称为高速缓存 caching）。
但如果其他的代理在 val1 与 val2 改变了 x 的值，编译器并不知道这类事发生，安全起见，使用 ```volatile``` 限定的变量不会采用高速缓存的方式读取 x 的值。

>---
#### 7.3. restrict

```restrict``` 关键字允许编译器优化某部分代码以更好地支持计算，只能用于指针，表明该指针是访问数据对象的唯一且初始的方式。它限定指针，而不是它指向的内容。若对标记为 ```restrict``` 的指针使用了别名，则结果是不确定的。通过 `register` 限定指针访问的对象与该指针具有特殊关联，要求对该对象的所有访问都直接或间接使用该指针的值。

 ```c
// 用于函数形参，限定仅能从 restrict 指针变量访问数据
void test(int* restrict first, int* restrict second, int* val)
{
    *first += *val;
    *second += *val;
}
// 将 union 成员标记为 restrict 告诉编译器在任何作用域中只有 z.x 或 z.y 可被访问
union z
{
    int* restrict x;
    double* restrict y;
};
```

文件作用域的 ```restrict``` 限定指针必须在程序运行期间指向单个数组的元素。文件作用域 ```restrict``` 指针对访问动态分配的全局数组很有用。

```c
/* 作用于文件作用域 */
float * restrict a, * restrict b;
float c[100];

int init(int n) {
   float * t = malloc(2*n*sizeof(float));
   a = t;      // a 引用前半
   b = t + n;  // b 引用后半
}
// 编译器可以从 restrict 限定符推断 a 、 b 和 c 都没有潜在的别名引用
// 如果使用 a，b，c 中的一个访问对象，并且该对象在程序中的任何未知被修改，则
// 永远不会使用另外两个中的任何一个来访问它。
```

以下示例中的函数参数声明：

```c
void f(int n, int * restrict p, int * restrict q){
    while(n--)
        *p++ = *q++;
}
// 每次执行函数期间，通过其中一个指针访问对象时，则不会同时通过另一个指针参数访问该对象

void g(void){
    extern int d[100];
    f(50, d+50, d);  // valid
    f(50, d+1, d);   // undefined behavior
}
// 第二次调用中 d[1] 到 d[49] 中的每个元素都通过 p 和 q 访问，如果 p 和 q 数组是不相交的数组，则行为是实现定义的。
```

`restrict` 指针之间赋值的规则不区分函数调用和等效的嵌套块。除了一个例外，只有在嵌套块中声明的受限指针之间的 “外部到内部” 赋值才定义了行为。

```c
{
    int * restrict p1;
    int * restrict q1;
    p1 = q1; // undefined behavior
    {
        int * restrict p2 = p1; // valid
        int * restrict q2 = q1; // valid
        p1 = q2; // undefined behavior
        p2 = q2; // undefined behavior
    }
}
```


> *`restrict` 优化策略*
        
```c
int* restrict restar = (int *) malloc(10 * sizeof(int));
// 指针 restar 是访问由 malloc() 所分配内存的唯一且初始化的方式

restar[0] += 5;
restar[0] += 3;
// 由于 restar 唯一指定访问方式, 编译器处于优化考虑, 会采用 restar[0] += 8 进行替换

//------------------- 一般模式 -------------------
int ar[10];
int * par = ar;

par[0] += 5;
ar[0] *= 2;
par[0] += 3;
/*
  par 未使用 restrict 限定, 编译器就必须假设最坏的方式(其他标识符可能已经改变该地址的值),
不能用 par[0] += 8 进行替换
*/
```

> *`restrict` 的两种声明方式*

```c
void Func(int* restrict n);
// 等价于
void Func(int n[restrict]);
```

>---
#### 7.4. _Atomic

```c
    _Atomic ( type-name )
```

如果实现不支持原子类型，则不应使用原子类型说明符。原子类型说明符中的类型名称不应引用数组类型、函数类型、原子类型或限定类型。

并发程序设计把程序执行分成可以同时执行的多个线程, 因此如何管理访问相同数据的不同线程，C11 通过包含可选的头文件 ```stdatomic.h```，提供了一些可选的（不是必须实现的）管理方法。

> *`_Atomic` 用作类型说明符或类型限定符*

- 当 ```_Atomic``` 用作类型说明符，指代新的原子类型；当用作类型限定符，指代类型名的原子版本。在此范围中，它可以与 ```const```、```volatile``` 及 ```restrict``` 混合使用（尽管不同于其他限定符，类型名的原子版本可能拥有不同的大小、对齐以及对象表示）。
- 若编译器定义了宏常量 ```__STDC_NO_ATOMICS__``` ，则不提供关键词 ```_Atomic```。

```c
    _Atomic const int *p1;  // p 是指向 _Atomic const int 的指针
    const atomic_int *p2;   // 同上
    const _Atomic(int) *p3; // 同上
```

> *原子类型解释说明：*

- 原子类型的对象是仅有的免除数据竞争的对象，即它们可以被两个线程共时修改，或先被一个修改再被另一个读取。
- 每个原子对象都拥有关联于其自身的修改顺序，即对该对象的完整修改顺序（若从某个线程的视角来看，对于某原子对象 M 的修改 A 发生先于同一原子对象 M 的修改 B，则在 M 的修改顺序中 A 的出现先于 B）。
- 不同线程可能会观测到不同原子对象有相异的修改顺序，对于所有原子运算，保证有四种连贯：
  - **写写连贯**：若原子对象 M 的修改操作 A 先发生于 M 的修改操作 B，则 M 的修改顺序中 A 出现早于 B。
  - **读读连贯**：若原子对象 M 的值计算 A 先发生于 M 的值计算 B ，且从 M 上的副作用 X 求得 A 值，则 B 所计算得的值要么是 X 所存储的值，要么是 M 上的副效应 Y 所存储的值，其中 Y 在 M 的修改顺序中出现后于 X。
  - **读写连贯**：若原子对象 M 的值计算 A 先发生于 M 上的操作 B ，则从 M 上的副效应 X 求得 A 值，这里 X 在 M 的修改顺序中出现先于 B 。
  - **写读连贯**：若在原子对象 M 上的副效应 X 先发生于 M 的值计算 B ，则求值 B 从 X，或从在 M 的修改顺序中出现后于 X 的副效应 Y 求得其值。

- 原子属性仅对左值表达式有意义。左值到右值转换（模仿从原子区域到 CPU 寄存器的内存读取）会把原子性及其他限定符剥去。

```c
#include <stdio.h>
#include <threads.h>
#include <stdatomic.h>

atomic_int acnt;
int cnt;

int f(void* thr_data)
{
    for(int n = 0; n < 1000; ++n) {
        ++cnt;
        ++acnt;
        // 对于此例，宽松内存顺序是足够的，例如
        // atomic_fetch_add_explicit(&acnt, 1, memory_order_relaxed);
    }
    return 0;
}

int main(void)
{
    thrd_t thr[10];
    for(int n = 0; n < 10; ++n)
        thrd_create(&thr[n], f, NULL);
    for(int n = 0; n < 10; ++n)
        thrd_join(thr[n], NULL);

    printf("The atomic counter is %u\n", acnt);
    printf("The non-atomic counter is %u\n", cnt);
}
/* 可能的输出
	The atomic counter is 10000
	The non-atomic counter is 8644
*/
```

>---
#### 7.5. 限定声明的结构成员

```c
struct s { int i; const int ci; };
struct s s;
const struct s cs;
volatile s vs;
```

各种成员具有以下类型：

```c
s.i         int
s.ci        const int
cs.i        const int
cs.ci       const int
vs.i        volatile int
vs.ci       volatile const int
```

---
### 8. 复杂声明解释
#### 8.1. 抽象声明符

- 抽象声明符是没有标识符的声明符，由一个或多个指针、数组或函数修饰符组成。
- 指针修饰符 `*` 始终在声明符中的标识符前面。
- 数组 `[ ]` 和函数 `()` 修饰符紧跟在标识符后面。
- 抽象声明符常表示函数原型的形参或返回类型。

```c
int             int 整型
int *           指针声明
int *[3]        指向 int 的 3 个指针组成的数组
int (*)[5]      指向 5 个 int 类型数组的指针
int (*)[*]      指向未指定数目的 int 类型的可变长度数组的指针
int *()         一个不带参数的函数，返回一个指向 int 的指针
int (*)(void)   指向不带参数并返回 int 的函数的指针
int (*const []) (unsigned int, ...)  
指向函数的未指定数目的常量指针的数组，每个函数都有一个参数，其类型是 unsigned int 以及未指定数
目的其他参数，并返回一个 int
```

>---

#### 8.2. 解释复杂的声明符

复杂声明符是由多个数组、指针或函数修饰符限定的标识，可以将数组、指针和函数修饰符的各种组合应用于单个标识符。通常 ```typedef``` 可用来简化声明。在解释复杂声明符时，方括号和圆括号（即，标识符右侧的修饰符）优先于星号（即，标识符左侧的修饰符）。方括号和圆括号具有相同的优先级并且都是从左到右关联。

> *解释复杂声明符的一般步骤*

1. 从标识符开始并直接查找方括号或圆括号（如果有）的右侧。
2. 解释这些方括号或圆括号，然后查找星号的左侧。
3. 如果在任何阶段遇到一个右圆括号，请返回并将规则 1 和 2 应用于圆括号内的所有内容。
4. 应用类型说明符。

> *解释复杂声明符*

```C
char *( *(*var)() )[10];
 ^   ^  ^ ^ ^   ^    ^
 7   6  4 2 1   3    5

/*
  1. 标识符 var 声明为
  2. 指向以下内容的指针
  3. 返回以下内容的函数
  4. 指向以下内容的指针
  5. 包含 10 个元素的数组，这些元素分别为
  6. 指向以下内容的指针
  7. char 值

TOTAL: 标识符 var 声明为 (指向 (返回 (指向 (包含 10 个元素的数组，
这些元素分别为 (指向 (char 值) 的指针) ) 的指针) 的函数) 的指针)
*/
```

> *复杂的声明符举例*

```c
int *var[5];		/* 声明为指向 int 的指针数组 */
int (*var)[5];		/* 声明为指向 int 数组的指针 */
long *var(long, long);		/* 声明为返回 long 指针的函数 */
long (*var)(long, long);	/* 声明为指向返回 long 的函数指针 */

struct both{
    int a;
    char b;
} (*var[5])(struct both, struct both);
/* 声明为指向返回结构 both 的函数的指针数组 */

struct both *var[5](struct both, struct both);
/* 非法：声明函数数组 */

unsigned int* (*const *name[5][10])(void);
/* 声明为指向常量指针的指针的二维数组，这些常量指针指向返回 unsigned int* 的函数 */

double (*var(double(*)[3]))[3];
/* 声明为返回指向包含 3 个 double 数组指针的函数，其形参是指向包含 3 个 double 数组的指针 */

union sign{
     int x;
     unsigned y;
} **var[5][5];
/* 声明为指向指针的指针二维数组，这些指针指向具有两个成员的联合的指针 */

union sign *(*var[5])[5];
/* 声明为一个五元素指针数组，数组元素指向联合的五元素指针数组 */
```

>---

#### 8.3. 不完整类型

**不完整类型** 是一种用于描述标识符但缺少确定该标识符的大小所需的信息的类型。不完整类型不能用于定义变量，但是用不完全类型定义指针或者引用是合法的。
“不完整类型” 可以是：尚未指定其成员的结构类型、联合类型或未指定其维度的数组类型。
在使用不完整类型前必须确保该类型被完成定义。```void``` 类型是无法完成的不完整类型，特殊用于函数的参数与函数返回等。

> *不完整类型应用于*

- 指向不完整类型的指针；
- 不完整类型的引用；
- 不完整类型的 ```typedef``` 名称；
- 返回不完整类型的函数和函数原型的抽象声明类型。

>---

#### 8.4. 复合文本

**复合文字** 为那些存储类型说明符的名称提供初始值设定项支持。类型名称应指定完整的对象类型或未知大小的数组，但不能指定可变长度的数组类型。复合文本与文件范围或块范围相关联。

```c
SC? typeof(T) Identifier = { IL };
// SC 存储类说明符可能为空
// IL 是一个初始值设定项列表
```

对于与函数原型范围关联的复合文本，类型被确定在块作用域中，并且不会创建任何对象；若它是复合文本常量，则在翻译时计算；若不是复合文本常量，则既不会计算整个复合文本，也不会计算任何初始值设定项。因为复合文本是匿名的，所以不能先创建然后再使用它，必须在创建的同时使用它。

对于数组，复合文本类似数组初始化列表，前面是用括号括起来的类型名。

```c
int arr[2] = {1,2};           // 常规数组声明
int *arr2 = (int[2]){1,2};    // 复合字面量
// (int[2])  即为数组复合字面量的类型名(匿名)
// 也可省略数组大小     即 (int[]){1,2}
// 多维复合字面量: (int[2][1]){{1},{2}}
```

对于结构或联合，带有名称的初始值设定项可以与复合文本组合，使用复合文本创建的结构对象可以传递给函数。

```c
struct S
{
    int value;
    int id;
};
struct S s1 = (struct S){.id = 10010, .value = 10};
struct S s2 = (struct S){10, 10086};

struct S* ps1 = &(struct S){.id = 1, .value = 100};
```

类型限定符修饰的复合文本。

```c
void func(volatile int arr[], const register char *strs);
int main(void)
{
    func((volatile int[]){1, 2, 3, 4, 5, 6}, (const char *){"Hello World!"});
}
```

复合文本一般是提供只临时需要的值的一种手段。复合字面量具有块作用域，这意味着一旦离开定义复合字面量的块，程序将无法保证该字面量是否存在。

---
### 9. 类型初始化

#### 9.1. 初始化标量类型

> *初始化任何类型的变量，遵循的下列规则*

- 在文件范围级别声明的变量可初始化，未显示初始化的外部级别变量将自动初始化为 0，指针类型分配为 ```null``` 指针（其值为 0）。
- 常数表达式可用于初始化使用 ```static``` 声明的任何全局变量。
- 使用 ```auto``` 或 ```register``` 存储类说明符声明的变量在每次执行控制传递给声明它们的块时进行初始化。
- 在 ```auto``` 或 ```register``` 变量的声明中省略初始值设定项，则变量的初始值是未定义的（栈存储的特征，它的值是包含之前定义的值的任何表达式，甚至是函数调用）。
- 外部变量声明和所有 ```static``` 变量（无论是外部还是内部变量）的初始值必须是常数表达式，```auto``` 变量的地址不能用作静态初始值设定项，因为它不是常量。
- 如果标识符的声明具有块范围，并且标识符具有外部链接，则该声明不能具有初始化（函数或结构、枚举、联合的模板声明）。

>---
#### 9.2. 初始化聚合类型

聚合类型是结构、联合或数组类型。如果聚合类型包含聚合类型的成员，则初始化规则将以递归方式进行。

> *聚合对象的初始化列表*

- 初始化列表是一个用逗号分隔的初始值设定项的列表，列表的每个初始值设定项是常量表达式或内嵌初始值设定项列表。
- 对于每个初始值设定项列表，常量表达式的值将按顺序赋给聚合变量的相应成员。
- 列表具有的值少于聚合类型时，聚合的其余成员会初始化为 0（指针为 ```null```）；列表具有的值多于聚合类型会导致错误。
- 未显式初始化的自动标识符的初始值是不确定的。

> *聚合类型初始时的规则*

- 结构的初始值设定项要么是同一类型的表达式，要么是其成员包含在大括号 ```{ }``` 中的初始值设定项的列表。未命名的位域成员是未初始化的。
- 如果数组的大小未知，则初始值设定项的数目将确定数组的大小。
- 初始化器列表不能为空。

> *嵌套的初始化设定项列表*

```c
int P[4][3] =
{
    { 1, 1, 1 },
    { 2, 2, 2 },
    { 3, 3, 3,},
    { 4, 4, 4,},
};
```

如果聚合成员没有嵌入的初始值设定项列表，则只会按顺序将值赋给子聚合的每个成员。

```c
int P[4][3] =
{
   1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4
};
```

> *联合的初始化设定项列表*

```c
union
{
    char x[2][3];
    int i, j, k;
} y = {
	{
        {'1'},
        {'4'}
    }
};
```

该联合的第一个元素是数组，因此该初始值设定项是聚合初始值设定项。初始值设定项列表 `{'1'}` 将值赋给数组的第一行。由于列表中仅显示一个值，因此，第一列中的元素将初始化为字符 1，而该行中的其余两个元素将初始化为值 0（默认值）。同样，`x` 的第二行的第一个元素将初始化为字符 4，而该行中的其余两个元素将初始化为值 0。

> *可以使用单个指示符从数组的两端 “分配” 空间*

```c
int a[A_MAX] = {
    1, 3, 5, 7, 9, [A_MAX-5] = 8, 6, 4, 2, 0
};
```

如果 `A_MAX` 大于 10，则中间会有一些零值元素；如果小于 10，则前 5 个初始值设定项提供的某些值将被后 5 个初始值设定项覆盖。

>---

#### 9.3. 初始化字符串

可以使用字符串文本（或宽字符串文本）初始化字符（或宽字符）的数组。

```c
char code[] = "abc";
// 等同于
char s[]  = {'a', 'b', 'c', '\0'};
```

标识符列表的长度值只能与要初始化的标识符的数量相同。如果指定短于字符串的数组大小，则会忽略多余字符。

```c
// 只有初始值设定项的前三个字符将分配给 code，字符 d 和字符串终止 null 字符将被丢弃
char code[3] = "abcd";
// 等同于
char s[3] = {'a', 'b', 'c'};
```

>---

#### 9.4. 空初始化器

对象声明的初始值设定项可以是空初始化器 `{}`，对象的值将初始化为全零位。

```c
int num = {};
int arr[10] = {};
struct s = {};
union u = {};
```

---
### 10. 表达式与操作符

“操作数” 是运算符作用于的实体。“表达式” 是用于执行以下操作的任意组合的一系列运算符和操作数：计算值、指定对象或函数、生成副作用（对数据对象或文件的修改）。

C 中的操作数包括常量、标识符、字符串、函数调用、下标表达式、成员选择表达式以及通过将操作数与运算符组合或将操作数括在括号中而形成的复杂表达式。

>---
#### 10.1. 表达式计算

涉及赋值、一元递增、一元递减或调用函数的表达式可能具有其计算附带的结果（副作用）。
“副作用” 是由表达式的计算引起的更改。只要表达式计算更改变量的值，就会出现副作用。所有赋值运算都具有副作用。

> *副作用*

表达式的计算顺序由特定实现定义，函数调用的参数可按任意顺序进行计算。

```c
add( i + 1, i = j + 2 );
/*
	表达式 i + 1 可以在 i = j + 2 前计算，
	或者 i = j + 2 可以在 i + 1 前计算，每种情况下的结果都不同
*/

x[i] = i++;
/*
	修改后的 x 值不可预知。 下标的值可以是 i 的新值或旧值。
	结果因编译器或优化级别而异
*/
```

> *C 序列点*

在表达式计算过程中，当达到 “序列点” 时，确保对序列点后面的任何内容执行计算之前已计算序列点前面的所有内容（包括任何副作用）。完全计算当前序列点时，在继续下一个序列点之前将完成当前的所有副作用。在连续的 “序列点” 之间，仅能通过表达式修改一次对象的值。

C 定义的序列点：
  - 逻辑 “与” 运算符 (```&&```) 的左操作数：左操作数结果为 ```false```，则不计算右操作数。
  - 逻辑 “或” 运算符 (```||```) 的左操作数：左操作数结果为 ```true```，则不计算右操作数。
  - 逗号运算符的左操作数：完全计算逗号运算符的左操作数，并在继续之前完成所有副作用。
  - 函数调用运算符：在输入函数前完成所有副作用。函数参数之间的计算顺序不确定。
  - 条件运算符的第一个操作数。
  - 完全初始化表达式的末尾。
  - 表达式语句中的表达式。
  - 选择语句（```if``` 或 ```switch```）中的控制表达式：完全计算该表达式，并在执行依赖于选择的代码之前完成所有副作用。
  - ```while``` 或 ```do``` 语句的控制表达式，```for``` 的三个表达式：下一个迭代之前。
  - ```return``` 语句中的表达式：完全计算该表达式，并在控制返回调用函数之前完成所有副作用。

>---
#### 10.2. 常量表达式

常量表达式将在编译时而不是运行时计算，并且可在可使用常量的任何位置使用。常量表达式的计算结果必须是位于该类型的可表示值范围内的常量。

常量表达式的操作数可以是整数常量、字符常量、浮点常量、枚举常量、类型强制转换、```sizeof``` 表达式和其他常量表达式。

>---
#### 10.3. 算数运算符

```c
// 1. 赋值运算符
	int num1 = 1;
	int num2,num3,num4;
	num2 = num3 = num4 = num1;
// 2. 加法运算符
	num2 = num2 + num1;
	num2 += num1;
// 3. 减法运算符
	num3 = num3 - num1;
	num3 -= num1;
// 4. 乘法运算符
	num4 = num4 * num1;
	num4 *= num1;
// 5. 除法运算符
	num5 = num5 / num1;
	num5 /= num1;
// 6. 取余运算符
	num6 = num6 % num1;
	num6 %= num1;
// 7. 递增递减运算符
	num7++;
	++num7;
	num7--;
	--num7;
```

- 递增递减运算符的操作数必须具有原子、限定或非限定的实数或指针类型，并且必须是可修改的左值。
- 每个操作数都应具有算数类型，`%` 运算符的操作数应为整数类型。如果任一操作数具有十进制浮点类型，则另一个操作数不应具有标准浮点类型、复数类型或虚数类型。整数除法的结果是代数商，小数部分被丢弃。

>---
#### 10.4. sizeof

```sizeof``` 运算符提供了存储操作数或表达式的类型的对象所需的存储空间量（以字节为单位），返回类型是 ```size_t```。`sizeof` 的操作数不能是函数类型或不完整类型的表达式。

 ```c
	size_t num_size = sizeof num;
	size_t num_size = sizeof(num);
	size_t i_size = sizeof(int);
	size_t i_size = sizeof int;
```

```sizeof``` 运算符的操作数是不求值的表达式（除非它们是 VLA） (C99 起)。例如 ```size_t n = sizeof(printf("%d", 4));``` 不会进行控制台输出。

>---
####  10.5. typeof, typeof_unqual

```c
typeof ( expression | type )
typeof_unqual ( expression | type )
```

`typeof` 和 `typeof_unqual` 表示 *typeof* 运算符。*typeof* 运算符不应应用于指定位域成员的表达式。可以将 *typeof* 运算符应用于表达式或类型名称：如果将 *typeof* 运算符应用于表达式，则它们将生成其操作数的类型。否则，它们将指定与类型名称相同的类型，并计算任何嵌套的 *typeof* 说明符。如果操作数的类型是可变修改的类型，则计算操作数。否则，不会计算操作数。

```c
struct S1 { int a; };
struct S2 { typeof(struct S1) s; };

int main(void)
{
    typeof(struct S2) s = { 10 };
    s.s.a++;
    printf("%d", s.s.a); // 11
}
```

`typeof_unqual` 运算符的结果是非原子非限定类型，`typeof` 运算符保留所有限定符。

```c
const _Atomic int purr = 0;
const int meow = 1;
const char* const animals[] = {
	"aardvark",
	"bluejay",
	"catte",
};
typeof_unqual(meow) main (int argc, char* argv[]) {
	typeof_unqual(purr) plain_purr;
	typeof(_Atomic typeof(meow)) atomic_meow;
	typeof(animals) animals_array;
	typeof_unqual(animals) animals2_array;
	return 0;
}
// 等价于
const _Atomic int purr = 0;
const int meow = 1;
const char* const animals[] = {
	"aardvark",
	"bluejay",
	"catte",
};
int main(int argc, char* argv[]) {
	int 			  plain_purr;
	const _Atomic int atomic_meow;
	const char* const animals_array[3];
	const char*       animals2_array[3];
	return 0; 
}
```

> *获取函数的返回类型*

```c
#include <stdio.h>
#include <stdlib.h>

double (*Func(double (*)[3]))[3];
double (*Func(double (*DArr)[3]))[3]
{
	double(*Arr)[3] = (double(*)[3])malloc(3 * sizeof(double *));
	for (size_t i = 0; i < 2; i++)
		for (size_t j = 0; j < 3; j++)
			Arr[i][j] = DArr[i][j] + 10.0;
	return Arr;
}

int main(void)
{
	static double arr[2][3] = {1.0, 2.1, 3.2, 1.1, 2.2, 3.3};
	double(*DArr)[3] = arr;
	typeof(Func(NULL)) rt;	// 反射获取函数的返回类型

	rt = Func(DArr);

	printf("%p\n", rt);

	for (size_t i = 0; i < 2; i++)
		printf("%p %.2f\n", rt[i], rt[i][0]);
	return 0;
}
```

> *在宏定义中动态获取相关结构体成员的类型*

```c
#define max(x, y) ({                \
    typeof(x) _max1 = (x);          \
    typeof(y) _max2 = (y);          \
    (void) (&_max1 == &_max2);      \
    _max1 > _max2 ? _max1 : _max2; })

int main(int argc, char *argv[])
{
	int a = 3;
	int b = 4;
	int r = max(a, b);

	printf("r:%d\n", r);
	return 0;
}
/* a,b 类型不一致时编译时将发出警告 */
```

> *带有 typeof 运算符的可变长度数组在执行时而不是在转换时执行操作*

```c
#include <stddef.h>

size_t vla_size(int n)
{
    typedef char vla_type[n + 3];
    vla_type b; 			// variable length array
    return sizeof(
        typeof_unqual(b)
		);  // execution-time sizeof, translation-time typeof operation
}
int main()
{
    return (int)vla_size(10); // vla_size returns 13
}
```

>---
####  10.6. alignas, alignof

对齐：C 的低级功能之一是能够指定内存中对象的精确对齐方式，以最大限度利用硬件体系结构。当数据存储在成倍数据大小的地址中时，CPU 会更有效地读取和写入内存。例如，如果数据存储在倍数为 4 的地址中，则会更有效地访问 4 字节整数。如果数据未对齐，则 CPU 需要执行更多地址计算工作来访问数据。
将常用数据与处理器的缓存行大小对齐，可以提高缓存性能，编译器通常在基于目标处理器和数据大小的自然边界上对齐数据。

> *alignas*

使用 ```alignas``` 或 ````_Alignas```` 来指定变量或用户定义类型的自定义对齐方式。它们可以应用于结构、联合、枚举或变量。

```c
#include <stdalign.h>

alignas(TYPE_SIZE) <type> <identifier>
_Alignas(TYPE_SIZE) <type> <identifier>
```

```_Alignas``` 不能在 ```typedef```、位域、函数、函数参数或使用 ```register``` 寄存器说明符声明的对象的声明中使用。
指定幂为 2（如 1、2、4、8、16 等）的有效对齐或为 0，零对齐规范没有任何作用。不要使用小于类型本身大小的值。
```struct``` 和 ```union``` 类型的对齐方式与任何成员的最大对齐方式相等。在 ```struct``` 中添加填充字节，以确保满足各个成员的对齐要求。

声明中所有 `alignas` 的组合效果不得指定比所声明的对象或成员的类型所需的对齐更严格的对齐。当声明中出现多个对齐说明符时，有效对齐的要求是最严格的指定对齐。

```c
int main()
{
    alignas(0) alignas(4) alignas(16) struct Sample s;
    return alignof(s);  // 16
}
```

如果对象的定义具有对齐说明符，则该对象的任何其他声明应指定等效对齐或不具有对齐说明符。如果对象的定义没有对齐说明符，则该对象的任何其他声明也不得有对齐说明符。如果不同翻译单元中的对象声明具有不同的对齐说明符，则行为未定义。

> *alignof*

```_Alignof``` 和别名 ```alignof``` 返回指定类型的对齐方式（以字节为单位）。它返回类型为 ```size_t``` 的值。`alignof` 的操作数不能是函数类型或不完整类型。

 ```c
#include <stdalign.h>

alignof(type);
_Alignof(type);
```

> *对齐实例*

- ```alignas``` / ```_Alignas``` 设置对齐特性。
- ```alignof``` / ```_Alignof``` 获取对齐特性。

```c
#include <stdalign.h>

typedef struct{
	int value;
	alignas(32) char alignedMemory[32];
} cache;

int main(void)
{
	printf("sizeof(cache): %zd\n", sizeof(cache)); 	// 64
    printf("alignof(cache): %zd\n", alignof(cache)); // 32

	return 0;
}
```

>---
#### 10.7. 类型转换

多个运算符自动将操作数的值从一种类型转换为另一种类型。转换包含隐式或强制转换操作的结果。除非另有明确说明，否则将操作数值转换为兼容类型不会导致值或表示形式发生更改。

- 升级（promotion）：较小类型转换成较大类型。
- 降级（demotion）：把一种类型转换成更低级别的类型。

通常，在语句和表达式中应使用类型相同的变量和常量。但是，如果使用混合类型，C 会采用自动类型转换规则。

> *整数转换等级（降序）*

```long double```、```double```、```float```、```unsigned long long``` 或 ```long long```、```unsigned long``` 或 ```long```、```unsigned int``` 或 ```int```、`unsigned short` 或 `short`。

每个整数类型都有一个整数转换等级：
- 任何两个有符号整数类型都不应具有相同的秩，即使它们具有相同的表示形式。
- 有符号整数类型的秩应大于任何有符号整数类型的秩，但精度耕地。
- 位精确有符号整数的秩应大于任何宽度较小的标准整数类型或宽度较小的任何位精确整数类型的秩。
- 任何无符号整数类型的秩应等于相应有符号整数类型的秩（如果有）。
- 任何标准整数类型的值应大于具有相同宽度的任何扩展整数类型的秩或具有相同宽度的位精确整数类型的秩。
- 任何位精确整数类型相对于相同宽度的扩展整数类型的秩都是实现定义的。
- `char` 的秩应等于 `signed char` 和 `unsigned char` 的秩。
- `bool` 的秩应小于所有其他标准整数类型的秩。
- 任何枚举类型的秩应等于兼容整数类型的秩。
- 任何扩展有符号整数类型相对于具有相同精度的另一个扩展有符号整数类型的秩是实现定义的，但仍受确定整数转换秩的其他规则的约束。

> *bool 类型*

当任何标量值转换为 `bool` 值时，如果值为零（对于算数类型）、null（对于指针类型）或标量类型为 `nullptr_t`，则结果为 `false`；否则结果为 `true`。

> *有符号和无符号整数*

当整数类型的值转换为布尔值以外的其他整数类型时，如果该值可以用新类型表示，则值保持不变。否则，如果新类型是无符号类型，则通过在该值上重复加或减去新类型中可以表示的最大值，直至该结果在新类型的范围内。否则，将对新类型进行签名，并且无法在其中表示值；结果是实现定义的，或者是实现定义的信号。

> *实浮点数和整数*

当标准浮点类型的有限值转换为布尔值以外的整数类型时，小数部分被丢弃（即该值被截断为零）。如果整数部分的值不能用整数类型表示，则行为是未定义的。

当十进制浮点类型的有限值转换为布尔值以外的整数类型时，小数部分被丢弃（即该值被截断为零）。如果整数类型不能表示整数部分的值，则应引发 “无效” 浮点异常，并且未指定转换结果。

当整数类型的值转换为标准浮点类型时，如果要转换的值可以完全用新类型表示，则该值保持不变。如果要转换的值位于可以表示但无法精确表示的值范围内，则结果是以实现定义的方式选择的最接近的较高或最接近的较低可表示值。如果要转换的值超出可表示的值范围，则行为未定义。某些隐式转换的结果可能以比新类型所需的范围和精度更大的范围和精度表示。

当整数类型的值转换为十进制浮点类型时，如果要转换的值可以完全用新类型表示，则该值保持不变。如果无法准确表示所转换的值，则应正确舍入结果，并按照 ISO/IEC 60559 中的规定提出例外情况。

> *实浮点类型*

当实数浮点类型的值转换为实数浮点类型时，如果要转换的值可以完全用新类型表示，则该值保持不变。

当实际浮点类型的值转换为标准浮点类型时，如果要转换的值在可以表示但不能精确表示的值范围内，则结果是以实现定义的方式选择的最接近的较高或最接近的较低可表示值。如果要转换的值超出可表示的值范围，则行为未定义。

当实数浮点类型的值转换为十进制浮点类型时，如果无法准确表示要转换的值，则结果将正确舍入，并引发 ISO/IEC 60559 中规定的异常。某些隐式转换的结果可能以比新类型所需的范围和精度更大的范围和精度表示

> *复数类型*

当复数类型的值转换为另一个复数类型时，实部和虚部都遵循相应实数类型的转换规则。

> *实数和复数*

当实数类型的值转换为复数类型时，复数结果值的实部由转换为相应实数类型的规则确定，复数结果值的虚部为正零或无符号零。

当复数类型的值转换为布尔值以外的实数类型时，复数值的虚部被丢弃，实部的值根据相应实数类型的转换规则进行转换。

> *强制类型转换符*

 ```c
  // (type) value
  int num;
  long long num1 = 10000000000L;
  long long num2 = 10000000000L;
  num = (int)num1 + (int)num2;
```

除非类型名称指定了 `void` 类型，否则强制转换的类型名称应指定原子、限定或非限定标量类型，操作数应具有标量类型。

涉及指针的转换应通过显式强制转换指定。指针类型不得转换为任何浮点类型。浮点类型不得转换为任何指针类型。`nullptr_t` 类型不得转换为除 `void`、`bool` 或指针类型之外的任何类型。如果目标类型为 `nullptr_t`，则强制转换表达式应为 null 指针常量或具有类型 `nullptr_t`。

> *指针显式转换规则*

- 任何整数能被转型到任何指针类型，结果可能对齐不准确，可能不指向所引用类型的对象。
- 任何指针类型可以被转型到任何整数类型。
- 任何指向对象的指针能被转型成指向任何其他对象类型的指针。若其值未为目标类型正确对齐，则行为未定义。
- 任何指向函数的指针能被转型成指向任何其他函数类型的指针。若转换结果指针回原类型，则它与原值比较相等。若将转换所得指针用作函数调用，则行为未定义（除非函数类型兼容）。
- 在指针间转换（指向对象或指向函数的）时，若原值是其类型的空指针值，则结果是目标类型的正确空指针值（null to null）。

> *不建议的指针转换*

- 没有指针和浮点类型间的转换。
- 没有指向函数指针和指向对象指针（含 `void *` ）间的转换。（**```PS```**：函数指针与对象指针间的转换被许多编译器作为扩展接受。）

```c
// 检验对象表示是转型的合法使用
    double d = 3.14;
    printf("The double %.2f(%a) is: ", d, d);
    for(size_t n = 0; n < sizeof d; ++n)
        printf("0x%02x ", ((unsigned char*)&d)[n]);
/* Output：
	The double 3.14(0x1.91eb851eb851fp+1) is: 0x1f 0x85 0xeb 0x51 0xb8 0x1e 0x09 0x40
*/
    struct S {int x;} s;
//  (struct S)s; 	// 错误；非标量类型，尽管转型到相同类型什么都不做
    (void)s; 		// 转换任何类型到 void 都合法
```

> *严格别名使用*

  给定一个拥有有效类型 T1 的对象，使用相异类型的 T2 左值表达式（典型的是解引用指针）访问它是未定义行为，除非：
  - T2 和 T1 是兼容类型。
  - T2 是与 T1 兼容的类型的 cvr 限定版本。
  - T2 是与 T1 兼容的类型的有符号或无符号版本。
  - T2 是聚合体或联合体类型，其成员中包含一个前述 T1 类型（包括子聚合体或被包含联合体的成员）。
  - T2 是字符类型（```char```、```signed char``` 或 ```unsigned char``` ）。

```c
int i = 7;
char* pc = (char*)(&i);
if(pc[0] == '\x7') {
// 通过 char 别名使用是允许的
    puts("This system is little-endian");
} else {
    puts("This system is big-endian");
}

float* pf = (float*)(&i);
float d = *pf;
// ERROR： float 左值 *pf 不能用来访问 int

struct S { int a, b; };
// int* 和 struct S* 可以别名使用，因为 S 拥有 int 类型的成员
```

>---
#### 10.8. 关系运算符


```c
  <   	小于
  <=  	小于等于
  >   	大于
  >=  	大于等于
  ==  	相等
  !=  	不等
```


关系运算符用于构建控制语句中的条件判断表达式（关系表达式）。关系表达式 **不能用于比较字符串的大小，不能自动比较结构体对象**。不能用关系运算符比较复数和虚数。由于浮点数精度的问题, 比较浮点数的大小尽量使用 `<` 和 `>` , 使用 ```fabs()``` 函数返回浮点值的绝对值。

如果指定的关系为 `true`，则每个运算符 `<`、`>`、`<=` 和 `>=` 与相等运算符应产生 1，如果指定关系为 `false`，则产生 0。结果的类型为 `int`。

如果任一操作数具有十进制浮点类型，则另一个操作数不应具有标准浮点类型、复数类型或虚数类型。

> *关系运算符优先级*

- 高优先级: <、<=、>、>=
- 低优先级: ==、!=

> *指针比较*

若 lhs 和 rhs 是指针类型表达式，则它们必须都是指向兼容类型对象的指针，除了忽略被指向对象上的限定:
  - 指向非数组元素的指针被当做如同它是指向有一个元素的数组的首元素的指针；
  - 若二个指针指向同一对象，或都指向同一数组的中的同一位置，则它们比较相等；
  - 若二个数组指向同一数组的不同元素，则指向有较大下标的元素的指针比较大于另一者；
  -	若二个指针指向同一结构体的成员，则指向结构体声明中较后声明的成员的指针，比较时大于指向较先声明的成员的指针；
  - 指向同一联合体成员的指针比较相等；
  - 所有其他指针比较引起未定义行为。

> *浮点数比较*

- IEEE-754 标准规定了浮点数存储的格式，浮点数的存储存在精度误差的问题。例如一个浮点数与 0.0 比较不能简单的使用 ```==```，实质上可以依靠 ```EPSILON``` （较小的正数）。```EPSILON``` 被规定为是最小误差。
- 如果正数 d 小于 ```EPSILON```，那么 d 和 1.0 相加，计算机就认为还是等于 1.0。

```c
#include <math.h>
#include <float.h>
/* 浮点数 D 与 0 作比较 */

if(fabs(D - 0.0) < DBL_EPSILON)
	puts("D 与 0.0 相等");
```

>---
#### 10.9. 逻辑运算符

```c
    &&      与
    ||      或
    !       非
```

逻辑运算符的结果类型是 `int`。每个操作数都应具有标量类型。

> *运算法则*

```c
    true && true = true
    false && false = false
	false && true = false

    true || false = true
	true || true = true
    false || false = false

	!false = true
```

> *优先级*

非 ( ```!``` ) > 与 ( ```&&``` ) > 或 ( ```||``` )

> *短路机制*

当 ```&&``` 左侧不满足结果为 ```true``` 的条件时，右侧表达式不会被计算。
当 ```||``` 左侧满足结果为 ```true``` 时，右侧表达式不会被计算。

>---
#### 10.10. 三目运算符

C 提供条件表达式（conditional expression）作为表达 ```if-else``` 语句的一种便捷方式，该表达式使用 ``` ? : ``` 条件运算符。

```C
x = condition ? expression-true : expression-false

//等价于
if(condition)
	x = expression-true;
else
    x = expression-false;
```

第一个操作数应具有标量类型。第二和第三操作数 ```expression-true``` 和 ```expression-false```，仅允许下列操作数：
  - 两个操作数都有算数类型；
  - 两个操作数都具有兼容的结构或联合类型；
  - 两个操作数都具有 `void` 类型；
  - 两个操作数都是指向兼容类型的限定或非限定版本的指针；
  - 两个操作数都有 `nullptr_t` 类型；
  - 一个操作数是指针，另一个是空指针常量或具有类型 `nullptr_t`；
  - 一个操作数是指向对象类型的指针，另一个操作数是指向 `void` 的限定或非限定版本的指针。
  - 如果第二个或第三个操作数中的任何一个具有十进制浮点类型，则另一个操作数不应具有标准浮点类型、复数类型或虚数类型。

首先计算第一个操作数；在它的计算与第二或第三操作数的计算（以计算者为准）之间有一个序列点。仅当第一个操作数与 0 进行比较时，才计算第二个操作数；仅当第一个操作数等于 0 时，才计算第三个操作数；结果是第二个或第三个操作数（以计算者为准）的值：
- 如果第二个和第三个操作数具有算术类型，则结果类型与通常的算术转换应用于两个操作数相同。如果两个操作数都具有结构或联合类型，则结果为复合类型。
- 如果两个操作数都具有 `void` 类型，则结果具有 `void` 类型。
- 如果第二个和第三个操作数都是指针，则结果类型是指向一个类型的指针，该类型具有两个操作数引用的类型的所有类型限定符。
- 如果一个是 null 指针常量（指针除外）或具有类型 `nullptr_t`，另一个是指针，则结果类型为指针类型。如果第二个和第三个操作数都具有 `nullptr_t` 类型，则结果也具有该类型。
- 如果两个操作数都是指向兼容类型或兼容类型的不同限定版本的指针，则结果类型是指向复合类型的适当限定版本的指针；如果一个操作数是 null 指针常量，则结果具有另一个操作数的类型；否则，一个操作数是指向 `void` 的指针或 `void` 的限定版本，在这种情况下，结果类型是指向 `void` 的适当限定版本的指针。
- 如果一个操作数是指向可变修改类型的指针，而另一个操作数是空指针常量或具有类型 `nullptr_t`，则如果类型依赖于未计算的数组大小表达式，则行为未定义。

> 鉴于声明：

```c
const void *c_vp;
void *vp;
const int *c_ip;
volatile int *v_ip;
int *ip;
const char *c_cp;
```

下表中的第三列是条件表达式的结果，其中前两列是第二和第三操作数（按任一顺序）：

```c
c_vp	c_ip	const void *
v_ip	0		volatile int *
c_ip 	v_ip	const volatile int *
vp		c_cp	const void *
ip		c_ip	const int *
vp		ip		void *
```

>---
#### 10.11. 顺序运算符

逗号运算符按从左到右的顺序计算其两个操作数。该运算的结果与右操作数具有相同的值和类型。

```c
int a = 1, b = 2;
int num = (a++, a+b);

/* 求解过程
	1. 计算 a++
	2. 计算 a+b
	3. a+b 的值赋值给 num
*/
```

>---
#### 10.12. 按位运算符

按位运算符都用于整数类型，包括 ```char```。按位（bitwise）运算，这些操作都是针对每一个位进行，不影响它左右两边的位。按位运算符除按位取反 ```~``` 均支持复合运算。

```powershell
# 1. 按位取反: 1->0, 0->1
	~(10010101) = 01101010
# 2. 按位与:  1&1=1, 0&0=0, 1&0=0
	11010110 & 01101011 = 01000000
# 3. 按位或:  1|1=1, 0|1=1, 0|0=0
	10101110 | 01001010 = 11101110
# 4. 按位异或: 1^1=0，0^1=1 0^0=0
	10101101 ^ 01011101 = 
	
# 5. 复合赋值
	a &= 1;     // a = a & 1;
	a |= 1;		// a = a | 1;
	a ^= 1;		// a = a ^ 1; 
```

> *掩码操作*

按位与运算符常用于掩码（mask）。所谓掩码指的是一些设置为开（1）或关（0）的位组合。

1. 假定符号常量 MASK 为 2（00000010）。
2. ```flags &= MASK```：表示将 flags 除 1 号位以外的所有位都设置为 0（无论 flags 的一号位是 0 或 1，其他位都会变成 0）。
3. 把掩码中的 0 看作不透明，1 看作透明，表达式 ```flags & MASK``` 相当于用掩码覆盖在 flags 的位组合上，只有 MASK 为 1 的位才可见。

```powershell
# flags &= MASK >>>>>>> 将非 1 位清 0
	MASK  >>>  00000010  >>>  ______1_
	按位与         &
	flags >>>  10010110  >>>  10010110
	             掩码
	flags >>>  ______1_  >>>  00000010
```

> *打开位 (设置位)*

有时，需要打开一个值中的特定位，同时保持其他位不变。

```powershell
# flags |= MASK >>>>>>> 将 1 位设置为 1
	MASK  >>>  00000010  >>>  ______1_
	按位或	       |
	flags >>>  10101001  >>>  10101001
	            打开位
	flags >>>  ______1_  >>>  10101011
```

> *关闭位 (清空位)*

```powershell
# flags &= ~MASK >>>>>>> 将 1 位关闭为 0
	MASK  >>>  10110110
	按位取反       ~
	MASK  >>>  01001001  >>>  _1__1__1
	按位与         &
	flags >>>  00001111  >>>  00001111
	            关闭位
	flags >>>  0_00_00_  >>>  00001001
```

> *切换位*

切换位指的是打开已关闭的位，或关闭已打开的位。可以使用按位异或运算符（^）切换位。

```powershell
# flags ^= MASK >>>>>>> 将指定的位取反，0➡1，1➡0
	MASK  >>>  00110010  >>>  __11__1_
	按位异或       ^
	flags >>>  10101001  >>>  10101001
	            切换位
	flags >>>  __01__1_  >>>  10011011
```

> *检查位的值*

有时，需要检查某位的值。例如，flags 中 1 号位是否被设置为 1？。检查指定位时需要将其他无关的位掩码（flags & MASK）。

```c
if((flags & MASK) == MASK)
// 10110101 & 10000000 ?= 10000000
// flags 指定位的值不会被修改，与 MASK 对比指定位是否相等，可以获取到当前位的值
// 相等表示校验位为 1，否则为 0
```

>---
#### 10.13. 移位运算符

左移运算符（```<<```）将其左侧运算对象每一位的值向左移动其右侧运算对象指定的位数，左侧运算对象移出左末端位的值丢失，用 0 填充空出的位置。

```c
	(10110100) << 2
  10 110100__          高位丢失，低位 0 补齐
	 11010000

>>>> 10110100 << 2 = 11010000
>>>> val <<= 2  >>>>  val = val << 2
```

右移运算符（```>>```）将其左侧运算对象每一位的值向右移动其右侧运算对象指定的位数。左侧运算对象移出右末端位的值丢失。对于无符号数，用 0 补齐高位空出的地方；对于有符号数，其结果取决于机器。空出的位置可用 0 填充，或者用符号位（即，最左端的位）的副本填充。

```powershell
# 有符号值表示
	(10001010) >> 2
	(00100010) 		# 在某些系统中的结果值, 0 填充
	(10001010) >> 2
	(11100010) 		# 在另一些系统上的结果值, 符号位 1 填充

# 无符号值表示
	(10001010) >> 2
	(00100010) 		# 所有系统都得到该结果值
```

移位运算符针对 2 的幂提供快速有效的乘法和除法：

```powershell
	number << n    # number 乘以 2 的 n 次幂
	number >> n    # 如果 number 为非负，则用 number 除以 2 的 n 次幂
```

移位运算符的复合赋值：

```c
	a >>= 1;   // a = a >> 1;
	a <<= 1;   // a = a << 1;
```

>---
#### 10.14. 替用运算符 (iso646.h)

```c
&&		and
&=		and_eq
&		bitand
|		bitor
~		compl
!		not
!=		not_eq
||		or
|=		or_eq
^		xor
^=		xor_eq
```

>---
#### 10.15. 不求值表达式

```sizeof```、*typeof* 运算符的操作数是不求值的表达式（除非它们是 VLA），例如 ```sizeof(printf("%d", 4));``` 不会进行控制台输出。

```c
#include <stddef.h>

size_t vla_size (int n) {
	typedef char vla_type[n + 3];
	vla_type b; // variable length array
	return sizeof(
		typeof_unqual(b)
	); // execution-time sizeof, translation-time typeof operation
}

int main () {
	return (int)vla_size(10); // vla_size returns 13
}
```

```_Alignof``` 运算符的操作数、泛型选择的控制表达式及作为 ```_Alignof``` 的操作数的 VLA 的大小表达式亦为不求值的表达式。

>---
#### 10.16. 泛型选择

在程序设计中，泛型编程（generic programming）指那些没有特定类型，但是一旦指定一种类型，就可以转换成指定类型的代码。

C++ 在模板中可以创建泛型算法，然后编译器根据指定的类型自动使用实例化代码；C 没有这种功能。C11 新增了泛型选择表达式（generic selection expression），根据表达式的类型选择一个值，泛型表达式常用于 ```#define``` 宏定义的一部分。一个泛型选择最多只能有一个 `default` 关联。

```c
// 泛型表达式
_Generic(assign-expr, generic-assoc-list)
// Example cbrt
#define cbrt(X) _Generic((X), 			      \
					     long double: cbrtl,  \
						 default: cbrt,		  \
						 float: cbrtf		  \
						 )(X)
```

X 表示一个表达式，该表达式匹配哪个标签，就返回哪个标签后面的值，与 ```switch``` 语句相似。

> *泛型表达式与 define 组合 ```_Generic (控制表达式 , 关联列表)```*

```c
#include <stdio.h>
#define MYTYPE(X) _Generic((X),
		int: "int",
		float : "float",
		double: "double",
		default: "other"
		)
int main(void)
{
	int d = 5;
	printf("%s\n", MYTYPE(d));
	// d 是 int 类型
	printf("%s\n", MYTYPE(2.0*d));
	// 2.0 * d 是 double 类型
	printf("%s\n", MYTYPE(3L));
	// 3L 是 long 类型
	printf("%s\n", MYTYPE(&d));
	// &d 的类型是 int *
	return 0;
}
/*
	int
	double
	other
	other
*/
```

>---
#### 10.17. 静态断言

```c
static_assert (constant-expression, string-literal);
static_assert (constant-expression);
```

常量表达式应为整数常量表达式。如果常量表达式的值不等于 0，则声明无效。否则，将违反约束，并且实现将生成诊断消息，该消息应包含字符串文本（如果存在）。

```c
static_assert(sizeof(int) == 4, "Expecting 32 bit integers");
```

---
### 11. 语句

#### 11.1. 空语句

“null 语句” 是仅包含分号的语句；它可在需要语句时显示。执行 null 语句时不会发生任何事件。通常在 ```do```、```for```、```if``` 和 ```while``` 等语句要求可执行语句作为语句主体出现。在无需实质性语句体的情况下，null 语句可满足语法要求。

```c
for (int i = 0, line[10]; i < 10; line[i++] = 0)
	;
```

>---
#### 11.2. while

```c
while(expression){
    statement;
}
```

控制表达式的计算在每次执行循环体之前进行。控制表达式应具有标量类型，在控制表达式等于零时跳出循环体。

```c
int num = 0;
while (++num < 100) {
	printf("NUM: %d\n", num);
	if (num == 50)
		break;
}
printf("BREAK SUCCESS: %d", num);
```

>---
#### 11.3. for


```c
for( 声明表达式? ; 控制表达式? ; 迭代表达式?) -- 控制表达式
{
    循环体语句块
}
for( 声明表达式? ; 控制表达式? )
{
	循环体语句块
}
```

声明表达式在首次计算 `for` 迭代语句控制表达式之前进行求值；控制表达式不等于零时进入循环体，在等于零时跳出或不进入循环体；迭代表达式在每次循环体执行后作为 `void` 表达式求值。

声明表达式和迭代表达式可以省略，控制表达式省略时将替代为非零常量。

```c
int a, b;
for(a = 1, b = 10; a < b; a++, b--) {
	printf("mul: %d\n", a * b);
}

int arr[10] = {}; 
for(int i = 0; i < 10;){
	arr[i] = i;
	i++;
}
```

>---
#### 11.4. do-while

```c
do{
    statement;
}
while(expression);
```

控制表达式的计算在循环体的每次执行之后进行。控制表达式应具有标量类型，在控制表达式等于零时跳出循环体。`do` 语句的循环体至少循环一次，再进入条件判断。

>---
#### 11.5. if-else

```c
if(exp1){
    //do....
}else if(exp2){
    //do....
}else{
    //do....
}
```

`if` 的控制表达式应具有标量类型。控制表达式不等于 0，则执行第一个子句；否则执行第二个子句 `else` 分支。

```c
#define SPACE ' '
#include <stdio.h>
int main(void)
{
	char ch;
	ch = getchar(); 			// 读取一个字符
	while (ch != '\n') 			// 当一行未结束时
	{
		if (ch == SPACE) 		// 留下空格
			putchar(ch); 		// 该字符不变
		else
			putchar(ch + 1); 	// 改变其他字符
		ch = getchar(); 		// 获取下一个字符
	}
	putchar(ch); 				// 打印换行符
	return 0;
}
```

>---
#### 11.6. switch

```c
    switch(整数表达式){
        case 常量1: <do>... break;
        case 常量2: <do>... break;
        ...
        default: <do:>...break;
    }
```

`switch` 语句的控制表达式应为整数类型。每个 `case` 标签的表达式应为整数常量表达式。```case``` 语句没有 ```break``` 时，**允许 ```case``` 之间自上而下贯穿**，直至遇到 ```default``` 或语句块结束，或遇到 ```break``` 语句。```case``` 标签表达式的类型必须能包含 ```switch(exp)``` 指定校验选择的数据类型（必须是整数类型），至少要类型一致。C 语言的 ```case``` 一般都指定一个常量值，不能使用一个范围。

```break``` 语句会跳出 ```switch``` 语句块，```default``` 标签前表示当所有未满足 ```case``` 常量表达式时的最终选择（可选分支）。最多可以有一个 `default` 标签与 `switch` 语句关联。


```c
int main(void)
{
	char ch = getchar();
	switch (ch) {
	case 'A':
		printf("%c", ch);
	case 'B':
		printf("%c", ch+1);
		break;
	case 'C':
		printf("%c", ch);
	default:
		break;
	}
}
```

>---
#### 11.7. goto 

`goto` 语句中的标识符将命名位于封闭函数中某处的标签。`goto` 语句不应从具有已修改类型的标识符的作用域外部跳转到该标识符的作用域内部。

```goto``` 语句有两部分：```goto``` 与标签名。一般条件跳转 ```if-else``` 结构可以满足， ```goto``` 语句一般用于出现问题时从一组嵌套循环中跳出，而 ```break``` 只能跳出当前循环。

```c
int main(void)
{
    int funct,i,j;
    while(funct > 0){
        for (i = 0; i < 100; i++)
        {
            for ( j = 0 ;j < 50 ;j++)
            {
                //do.....
                if (condition)
                    goto out;
            }
            //do.....
        }
        //do.....
    }
    out:
        //do....
    return 0;
}
```

>---
#### 11.8. continue

`continue` 语句只能出现在循环体中或作为循环体出现。`continue` 语句导致跳转到最里层的封闭迭代语句的循环延续部分，即跳转到循环体的末尾。

```c
while(/* ... */) {
	/* ... */
	continue;  // goto contin;
	/* ... */
contin:
}

do {
	/* ... */
	continue;  // goto contin;
	/* ... */
contin:
} while(/* ... */);

for (/* ... */) {
	/* ... */
	continue;  // goto contin;
	/* ... */
contin:
}
```

`continue` 语句等效于 `goto contin`。

>---
#### 11.9. break

`break` 语句只能出现在作为 `switch` 分支语句块或循环体。`break` 终止最里层封闭 `switch` 的执行或迭代语句。

```c
while(/* ... */) {
	/* ... */
	break;  // goto end;
	/* ... */
}
end:

do {
	/* ... */
	break;  // goto end;
	/* ... */
} while(/* ... */);
end:

for (/* ... */) {
	/* ... */
	break;  // goto end;
	/* ... */
}
end:

switch (/* ... */) {
	// other case ... 
	case /* ...  */:
		/* ... */
		break;  // goto end;
		/* ... */
	// other case ... 
}
end:
```

`break` 语句等效于 `goto end`。

>---
#### 11.10. return

```return``` 语句会终止当前函数的执行并将控制返回给其调用方。返回类型非 `void` 的函数，```return``` 语句可附带一个兼容的表达式结果返回给调用方。

```c
struct s { double i; } f(void);
union {
    struct {
        int f1;
        struct s f2;
    } u1;
    struct {
        struct s f3;
        int f4;
    } u2;
} g;
struct s f(void)
{
    return g.u1.f2;
}
/* ... */
g.u2.f3 = f()
```

---
### 12. 函数

函数是 C 中的基本模块单元。函数通常设计为执行一项特定任务且其名称通常会反映该任务。

函数必须具有定义且应具有声明，函数定义包含函数主体；函数声明为程序中其他位置定义的函数建立名称、返回类型和特性。函数声明必须在函数调用之前。

函数的返回类型应为 `void` 或除数组类型之外的完整对象类型。函数声明中的存储类说明符（如果有）应为 `extern` 或 `static`，默认为 `extern`。

>---
#### 12.1. 函数声明

函数声明位于函数定义之前，用来指定函数的名称、返回类型、存储类和其他特性。函数声明充当函数原型，用于之后在通用同一翻译单元中调用同一函数。

如果一个接受可变数量参数的函数在定义时没有以省略号表示法结尾的参数类型列表，则该行为是未定义的。

```c
int imax(int, int);    // 或
int imax(int a, int b);
int imax(int a, int );

int printf(const char *, ...);  // 可变数量参数 ...
extern int f(void);		// 外部链接声明
static void g(int);	 	// 内部链接声明
```

> *函数原型的主要用途*

- 原型用于在定义函数之前初始化指向函数的指针。形参列表用于检查函数调用中的实参是否与函数定义中的形参匹配。

> *以下是所有兼容的函数原型声明*

```c
double maximum(int n, int m, double a[n][m]);
double maximum(int n, int m, double a[*][*]);
double maximum(int n, int m, double a[][*]);
double maximum(int n, int m, double a[][m]);
double maximum(int n, int m, double (*a)[*]);
```

> 包含限定的兼容函数原型声明

```c
void f(double (* restrict a)[5]);
void f(double a[restrict][5]);
void f(double a[restrict 3][5]);
void f(double a[restrict static 3][5]);
```

>---
#### 12.2. 函数定义

函数定义指定函数的名称、函数期望接收的参数的类型和数量以及函数的返回类型。函数定义还包括带有局部变量的声明的函数体和确定函数行为的语句。作为函数定义一部分的函数声明中的参数类型列表中的参数不得具有不完整类型。未指定大小的可变长度数组类型不应作为函数定义中参数声明的一部分。

唯一可以修改函数声明的存储类说明符是 ```extern``` 和 ```static```；```extern``` 说明符表示可以从其他文件引用函数（即，将函数名导出到链接器），```static``` 不会将函数导出到链接器。参数声明中唯一可出现的存储类说明符是 `register`。

参数类型列表指定函数参数的类型，并可以声明函数参数的标识符。函数原型声明中可以省略参数的标识符。

将参数声明为 “类型数组” 应被视为 “限定的类型指针”，其中类型限定符（如果有）是在数组类型的 `[` 和 `]` 中指定的限定符。如果关键字 `static` 也出现在数组类型的 `[` 和 `]` 中，则对于每次调用函数，相应实际参数的值应提供对数组第一个元素的访问，该数组的元素数量至少与参数数组 *size* 表达式指定的元素数相同。

```c
int foo(int len, int arr[static len]);   // arr 实参的数组长度应至少和 len 相同
```

函数定义中形参的可见性范围从它的声明完成时开始，扩展到后面的形参声明，扩展到形参类型列表后面可能的属性，然后扩展到整个函数体。

每个形参实例的生命周期从开始调用时对声明进行求值开始，到调用结束时结束。在函数体内没有声明名称的形参是不可访问的。

参数标识符不能在函数体中重新声明，除非在封闭的块中。

>---
#### 12.3. 可变参数列表

`...` 指示可能有多个自变量参数传递给函数，```stdarg.h``` 提供了宏方法用于访问可变参数列表和清理工作。

C23 前，可变参数 `...` 要求参数列表中至少有一个参数，且可变参数必须是最后一个入栈参数。C23 起，可变参数 `...` 之前可以没有参数。

```c
int add_nums(int count, ...);    // C23 前
int add_nums_C23(...);			 // C23 起
```

> *使用步骤*

1. 提供一个使用省略号的函数原型；
2. 在函数定义中创建一个 ```va_list``` 类型的变量；
3. 用宏把该变量初始化为一个参数列表；
4. 用宏访问参数列表；
5. 用宏完成清理工作。

```c
// 1. 有效声明
void f1(int n, ...);
int f2(const char * s, int k, ...);

// 2. 无效声明
char f3(char c1, ..., char c2); // 省略号不在最后
double f3(...);                 // 没有形参

// 3. 宏使用可变参数列表
double sum(int lim, ...) /* 设 lim 表明变参列表中参数的数量 */
{
	// a. 声明一个储存参数的对象
	va_list ap;
	// b. 把 ap 初始化为参数列表, lim 为参数数目
	va_start(ap, lim);
	// c. 访问参数列表的内容 va_arg(ap, 类型名)
	//---- 检索第 1 个参数
	double tic = va_arg(ap, double);
	//---- 检索第 2 个参数
	int toc = va_arg(ap, int);
	/* PS: 传入的参数类型必须与宏参数的类型相匹配 */
	// d. 宏完成清理工作
	va_end(ap); 	// 清理工作
	/* PS: 释放动态分配用于储存参数的内存 */
}
```

调用 `va_end(ap)` 后，只有用 `va_start` 重新初始化 ap 后，才能使用变量 ap。```va_arg()``` 并不提供退回之前参数的方法，所以有必要保存 `va_list` 类型变量的副本。可以使用（C99）```va_copy(va_list1, va_list2)```，把 list2 传递给第一个参数。

```c
#include <stdio.h>
#include <stdarg.h>
double sum(int, ...);
int main(void)
{
	double s, t;
	s = sum(3, 1.1, 2.5, 13.3);
	t = sum(6, 1.1, 2.1, 13.1, 4.1, 5.1, 6.1);
	printf("return value for "
		   "sum(3, 1.1, 2.5, 13.3): %g\n",
		   s);
	printf("return value for "
		   "sum(6, 1.1, 2.1, 13.1, 4.1, 5.1, 6.1): %g\n",
		   t);
	return 0;
}
double sum(int lim, ...)
{
// 声明一个对象储存参数
	va_list ap;
	double tot = 0;
	int i;
// 把 ap 初始化为参数列表
	va_start(ap, lim);
// 访问参数列表中的每一项
	for (i = 0; i < lim; i++)
		tot += va_arg(ap, double);
// 清理工作
	va_end(ap);
	return tot;
}
/*
	return value for sum(3, 1.1, 2.5, 13.3): 16.9
	return value for sum(6, 1.1, 2.1, 13.1, 4.1, 5.1, 6.1): 31.6
*/
```

>---
#### 12.4. 内联函数

使用 `inline` 函数说明符声明的函数是内联函数。将函数设为内联函数表明对该函数的调用尽可能快。此类建议的有效程序是由实现定义的。

任何具有内部链接的函数都可以是内联函数。对于具有外部链接的函数，适用以下限制：如果使用 `inline` 函数说明符声明函数，则它也应在同一翻译单元中定义。如果翻译单元中函数的所有文件作用域声明都包含不带 `extern` 的内联函数说明符，则该翻译单元中的定义是内联定义。内联定义不提供函数的外部定义，也不禁止另一个翻译单元中的外部定义。内联定义提供了外部定义的替代方案，编译器可以使用它来实现对同一翻译单元中的函数的任何调用。对函数的调用是使用内联定义或外部定义是未指定的。

函数调用都有一定的开销, 函数调用过程包括建立调用、传递参数、跳转到函数代码并返回。C99 提供了内联函数（inline function）的概念，把函数变成内联函数，它会以函数体取代所有对它的调用，以避免函数调用的开销（将数据置于栈上和取得结果），这可能会生成更大的可执行文件，因为函数可能会被重复编译多次。
内部链接（```static```）的函数可以成为内联函数，使用函数说明符 ```inline``` 和存储类别说明符 ```static```，内联函数同时也可以相当于函数原型。

```c
inline static void eatline(){
	while(getchar() != '\n')
		continue;
}

int main(void){
	//...
	eatline();
	//...
}
```

一般无法获取内联函数的地址，内联函数的设计应该比较短小，较长的函数变成内联并不会节约太多的时间，执行函数体的时间总会比调用函数的时间长得多。
内联函数定义与调用必须在同一个文件，如果程序有多个文件都要使用某个内联函数，这些文件中都必须包含该内联函数的定义。可以将内联函数定义放在头文件中，使用该函数时包含该头文件即可。

```c
#ifndef EATLINE_H_
#define EATLINE_H_
inline static void eatline(){	// 不受一个定义约束
	while(getchar() != '\n')
		continue;
}
#endif
```

与 C++ 不同的是，C 允许混合使用内部函数定义和外部函数定义（具有外部链接）。具有外部链接的内联函数的声明可以产生外部定义，或者只能在翻译单元内使用的定义。使用 `extern` 的文件范围声明创建外部定义。

```c
// 1. 静态内联函数定义，内部链接
inline static void fun();
// 2. 外部链接函数定义
void fun();
// 3. 既充当内部内联函数, 又具有外部链接
inline void fun() // 该 inline 定义被视为可替换的外部定义
```

> *内联函数必须保证下列语义*

任何拥有内部链接的函数都可以声明成 ```static inline``` ，没有其他限制。
一个非 ```static``` 的内联函数不能定义一个非 ```const``` 的函数局部 ```static``` 对象，并且不能使用文件作用域的 ```static``` 对象（一般无法获取内联函数的地址）。

```c
static int x;
inline void f(void)
{
    static int n = 1; 	// ERROR：非 const 的 static 对象在非 static 的 inline 函数中
    int k = x; 			// ERROR：非 static 的 inline 函数访问 static 变量
}
```

若非 ```static``` 函数声明为 ```inline``` ，则必须在同一翻译单元中定义它；不使用 ```extern``` 的内联定义不会对外部可见，而且不会阻止其他翻译单元定义同一函数。
内联函数的地址始终是外部定义的地址，但当以此地址进行函数调用时，调用内联定义（若存在于翻译单元中）还是外部定义是未指定的。

```c
inline const char *saddr(void) 	// 用于此文件内的内联定义
{
    static const char name[] = "saddr";
    return name;
}
int compare_name(void)
{
    return saddr() == saddr(); 	// 未指定行为，调用可能是外部的
}
extern const char *saddr(void); // 外部定义也会生成
```

> 以下内联定义无效

```c
static int a;
typeof(a) inline f(){ return 0; }
typeof((int){0}) inline g() {return 0; }
```

>---
#### 12.5. 变长数组参数

在声明函数时可以使用 C99 新增的变长数组（变长数组不能改变大小），一般作为用于函数的形参声明。传入的数组不能使用 ```static``` 或 ```extern``` 存储类别说明符。C11 把变长数组作为一个可选特性。

```c
  void Func1(int size, int Arr[size]);
  void Func2(int row, int col, int Arr[row][col]);
  void Func3(int size, int(*pr)[size]);
  void Func4(int, int, int Arr[*][*]);  //省略模式

  void Func5(int Arr[size], int size);  // 无效的顺序
```

变长数组名实际上是一个指针。带变长数组形参的函数实际上是在原始数组中处理数组，因此可以修改传入的数组。
C99/C11 标准允许在声明变长数组时使用 ```const``` 变量，要求该数组的定义必须是声明在块中的自动存储类型数组。
变长数组还允许动态内存分配，这说明可以在程序运行时指定数组的大小。普通 C 数组都是静态内存分配，即在编译时确定数组的大小。

>---
#### 12.6. 限定数组形参

```c
void Function(double [static 10], const double [static 10]);
/* 传入的数组要求至少拥有 10 个元素 */

int f(const int a[20]);
/* a 拥有类型 const int* （指向 const int 的指针） */

int f(const int a[const 20]);
/* a 拥有类型 const int* const （指向 const int 的 const 指针） */

void f(double a[static restrict 10], const double b[static restrict 10]);
/* restrict 别名限定 */
```

>---
#### 12.7. 函数递归

- 外部调用函数: 第 1 级递归；
- 内部调用依次: 第 2 级递归, 第 3 级递归.....

```c
#include <stdio.h>
void up_and_down(int);
int main(void)
{
	up_and_down(1);
	return 0;
}
void up_and_down(int n)
{
	printf("Level %d: n location %p\n", n, &n); // #1
	if (n < 4)
		up_and_down(n + 1);
	printf("LEVEL %d: n location %p\n", n, &n); // #2
}
/*
	Level 1: n location 009BFC18
	Level 2: n location 009BFB40
	Level 3: n location 009BFA68
	Level 4: n location 009BF990
	LEVEL 4: n location 009BF990
	LEVEL 3: n location 009BFA68
	LEVEL 2: n location 009BFB40
	LEVEL 1: n location 009BFC18
*/
```

可以假设有一条函数调用链 —— fun1() 调用 fun2()、fun2() 调用 fun3()、fun3() 调用 fun4()：
  - 当 fun4() 结束时，控制传回 fun3()；
  - 当 fun3() 结束时，控制传回 fun2()；
  - 当 fun2() 结束时，控制传回 fun1()。

> *递归的基本原理*

1. 每级函数调用都有自己的变量。
2. 每次函数调用都会返回一次。当函数执行完毕后，控制权将被传回上一级递归。程序必须按顺序逐级返回递归。
3. 递归函数中位于递归调用之前的语句，均按被调函数的顺序执行。
4. 递归函数中位于递归调用之后的语句，均按被调函数相反的顺序执行。
5. 虽然每级递归都有自己的变量，但是并没有拷贝函数的代码（类似于循环）。
6. 递归函数必须包含能让递归调用停止的语句。通常，递归函数都使用 ```if``` 或其他等价的测试条件在函数形参等于某特定值时终止递归。

>---
#### 12.8. 函数与指针

通常，函数指针常用作另一个函数的参数，告诉该函数要使用哪一个函数。

声明一个数据指针时，必须声明指针所指向的数据类型。声明一个函数指针时，必须声明指针指向的函数类型。为了指明函数类型，要指明函数签名，即函数的返回类型和形参类型。

```c
void TpUpper(char *);   // 函数原型
void (*pf)(char*);      // pf 指向一个函数
```

> 声明了函数指针后，可以把类型匹配的函数类型赋给它

```c
void ToUpper(char *);
void ToLower(char *);
int round(double);

void (*pFun)(char *);
pFun = ToUpper;
pFun = ToLower;
pFun = round;       // ERR, 类型不一致
pFun = ToUpper();   // ERR, ToUpper() 不是地址, 返回 void

pFun("UPPER");      // = ToLower("UPPER");
(*pFun)("UPPER");   // 一般等价写法
```

> 函数指针作为参数

```c
void show(void (* fp)(char *), char * str);
```

---
### 13. 属性说明符

属性为各种源构造（如类型、对象、标识符或块）指定其他信息。它们由属性令牌标识，该令牌可以是属性前缀令牌（对于特定于实现的属性），也可以是由标识符指定的标准属性（C 标准中指定的属性）。标准中指定的任何标准属性的支持都是实现定义的且可选的。实现不支持的任何属性标记都将被忽略。

属性被认为属于某个源结构，由它们出现的语法上下文标识，对于每个单独的属性，相应的子句限制了该附属物在其中有效的语法上下文。附属于某个源构造的属性说明符序列应只包含允许应用于该源构造的属性。

```ANTLR
[[ attribute-list ]]

attribute-list:
    标准属性
    属性前缀 :: 标识符
    标准属性 ( 参数列表? )
    属性前缀 :: 标识符 ( 参数列表? )
attribute:
    attribute-token attribute-argument-clause?

attribute-token:
    
    attribute-prefixed-token

attribute-prefixed-token:
    attribute-prefix :: identifier

attribute-argument-clause:
    ( balanced-token-sequence? ) 

balanced-token-sequence:
    balanced-token
    balanced-token-sequence balanced-token 

balanced-token:
    ( balanced-token-sequenceopt )
    [ balanced-token-sequenceopt ]
    { balanced-token-sequenceopt }
    除括号、括号或大括号以外的任何标记
``` 
```c
[[attr]]
[[attr1, attr2, attr3(args)]]
[[属性前缀::attr(arg)]]
[[属性前缀::attr]]
/*
标准属性			例如 [[fallthrough]]
属性前缀::标识符	有命名空间的属性，例如 [[gnu::unused]]，C++
标准属性(实参列表)	有实参的标准属性
属性前缀::标识符(实参列表)
*/
```

>---
#### 13.1. 标准属性

标准属性中的标识符应为以下项之一：

```c
deprecated      maybe_unused        noreturn        unsequenced
fallthrough     nodiscard           _Noreturn       reproducible            
```

属性令牌在属性列表中的显示顺序不重要，每个实现都应为属性前缀令牌中的属性前缀选择一个独特的名称。实现不应定义没有属性前缀的属性，除非它是 C 标准中指定的标准属性。

```c
// 假设实现选择属性前缀 hal 并提供名为 daisy 和 rosie 的特定属性。
[[deprecated, hal::daisy]] double nine1000(double);
[[deprecated]] [[hal::daisy]] double nine1000(double);
[[deprecated]] double nine1000 [[hal::daisy]] (double);
```

在语言的所有方面，指定为标识符 `attr` 的标准属性和形式为 `__attr__` 标识符在用作属性标记时的行为应相同，但拼写除外。属性 `[[nodiscard]]` 和 `[[__nodiscard__]]` 可以自由互换。

```c
[[__deprecated__, __hal__::__daisy__]] double nine1000(double);
[[__deprecated__]] [[__hal__::__daisy__]] double nine1000(double);
[[__deprecated__]] double nine1000 [[__hal__::__daisy__]] (double);
```

对于同一实现，以下两个声明是等效的，因为属性列表中的排序并不重要。

```c
[[hal::daisy, hal::rosie]] double nine999(double);
[[hal::rosie, hal::daisy]] double nine999(double);
```

另一方面，以下两个声明并不等价，因为不同属性说明符的顺序可能会影响语义。

```c
[[hal::daisy]] [[hal::rosie]] double nine999(double);
[[hal::rosie]] [[hal::daisy]] double nine999(double);
```

>---
#### 13.2. 属性测试

```c
__has_c_attribute( 属性令牌 )
```

在 `#if` 与 `#elif` 的表达式中可以展开 `__has_c_attribute`。`#ifdef`、`#ifndef` 和 `defined` 把它当做已定义的宏处理，但不能在别处使用它。

```c
__has_c_attribute(nodiscard)        202311L
__has_c_attribute(deprecated)       202311L
__has_c_attribute(fallthrough)      202311L
__has_c_attribute(maybe_unused)     202311L
__has_c_attribute(noreturn)         202311L
__has_c_attribute(unsequenced)      202311L
__has_c_attribute(reproducible)     202311L
```

>---
#### 13.3. nodiscard 弃值表达式警告

```c
[[nodiscard]]
[[__nodiscard__]]	(1)
[[nodiscard (字符串字面量)]]
[[__nodiscard__ (字符串字面量)]]
```

`nodiscard` 属性应用于函数、枚举、结构或联合类型的定义。
- 若从转型到 `void` 以外的弃值表达式（调用声明为 `nodiscard` 的函数，或调用返回声明 `nodiscard` 的结构体 / 联合体 / 枚举的函数）则鼓励编译器发出警告。
- 弃值表达式，返回值放弃接收。

```c
struct [[nodiscard]] S { int status; };
struct S returnStruct(){
	return (struct S){0};
}

[[nodiscard("No Discard")]] int Mrix(int a, int b){
	return a ^ b;
}

int main(void){
	returnStruct();   /* warning */
	int rt = Mrix(1,2);	/* legal */
}
```

>---

#### 13.4. deprecated 弃用

```c
[[deprecated]]
[[__deprecated__]]
[[deprecated (字符串字面值)]]
[[__deprecated__ (字符串字面值)]]
```

`deprecated` 属性可用于标记仍允许使用但出于某种原因不建议使用的名称和实体。

```c
struct [[deprecated]] S;              // 结构/联合
[[deprecated]] typedef S* PS;         // typedef 名称
[[deprecated]] int x;                 // 对象
union U { [[deprecated]] int n; };    // 结构/联合成员
[[deprecated]] void f(void);          // 函数
enum [[deprecated]] E {};             // 枚举
enum { A [[deprecated]], B [[deprecated]] = 42 };   // 枚举项
```

声明时未弃用的名称可被重声明为 `deprecated`。声明为 `deprecated` 的名称不能通过不带此属性地重声明而变为未弃用。“已弃用” 适用于过时、不安全、不安全或不适合用途的名称和实体。

```c
[[deprecated]]
void TriassicPeriod(void)
{
    puts("Triassic Period: [251.9 - 208.5] million years ago.");
}
[[deprecated("Use NeogenePeriod() instead.")]]
void JurassicPeriod(void)
{
    puts("Jurassic Period: [201.3 - 152.1] million years ago.");
}
 
int main(void)
{
    TriassicPeriod();
    JurassicPeriod();
}
/* 可能的输出
test.c: In function 'main':
test.c:16:5: warning: 'TriassicPeriod' is deprecated [-Wdeprecated-declarations]
   16 |     TriassicPeriod();
      |     ^~~~~~~~~~~~~~
test.c:4:6: note: declared here
    4 | void TriassicPeriod(void)
      |      ^~~~~~~~~~~~~~
test.c:17:5: warning: 'JurassicPeriod' is deprecated: Use NeogenePeriod() instead. [-Wdeprecated-declarations]
   17 |     JurassicPeriod();
      |     ^~~~~~~~~~~~~~
test.c:9:6: note: declared here
    9 | void JurassicPeriod(void)
      |      ^~~~~~~~~~~~~~
Triassic Period: [251.9 - 208.5] million years ago.
Jurassic Period: [201.3 - 152.1] million years ago.
*/
```

>---

#### 13.5. fallthrough 贯穿抑制警告

```c
[[fallthrough]]
[[__fallthrough__]]
```

仅可用于属性声明以创建直落声明（`[[fallthrough]];`）。直落声明仅可用于 `switch` 语句中，其中要遇到的下个块项（语句、声明或标号）是该 `switch` 语句的带 `case` 或 `default` 标号的语句。指示从前一标号直落是有意的，而在发生直落时给出警告的编译器不应诊断它。

```c
switch (n) {
    case 1:
    case 2:
        g();
        [[fallthrough]];
    case 3: 	// 贯穿时不警告
        h();
    case 4: 	// 编译器可在发生贯穿时警告
	    if(n < 3) {
            i();
            [[fallthrough]]; 	// OK
        }
        else {
            return;
        }
    case 5:
        while (false) {
            [[fallthrough]]; 	// 谬构：下一语句不是同一迭代的一部分
        }
    case 6:
        [[fallthrough]]; 		// 谬构：下一语句不是同一迭代的一部分
}
```

>---

#### 13.6. maybe_unused 抑制对未使用实体的警告

```c
[[maybe_unused]]
[[__maybe_unused__]]
```

`maybe_unused` 属性应应用于结构、联合、`typedef` 名称、对象、结构或联合成员、函数、枚举、枚举器或标签的声明。若编译器可以对未使用的实体发出警告，则对任何声明为 `maybe_unused` 的实体抑制该警告。

```c
struct [[maybe_unused]] S;              // 结构/联合
[[maybe_unused]] typedef S* PS;         // typedef 名称
[[maybe_unused]] int x;                 // 对象
union U { [[maybe_unused]] int n; };    // 结构/联合成员
[[maybe_unused]] void f(void);          // 函数
enum [[maybe_unused]] E {};             // 枚举
enum { A [[maybe_unused]], B [[maybe_unused]] = 42 };   // 枚举项
```

>---

#### 13.7. noreturn 函数不会返回

```c
[[noreturn]]
[[__noreturn__]]

[[Noreturn]]        // 弃用
[[__Noreturn__]]    // 弃用
```

指示函数不会返回。这个属性适用于函数名，指示函数不会由于执行返回语句或由于抵达函数体结尾而返回（它可以通过执行 `longjmp` 返回）。如果有此属性的函数实际返回，则其行为未定义。如果可以检测这种情况，建议编译器予以诊断。
_Noreturn 函数说明符被弃用。应该用 `[[noreturn]]` 属性代替。

实现应为使用 `noreturn` 属性声明的函数生成诊断消息，该函数似乎能够返回给其调用方。

```c
[[noreturn]] void f(void) {
    abort(); // ok
}
[[noreturn]] void g(int i) { 
    // causes undefined behavior if i <= 0
    if (i > 0) abort();
}
[[noreturn]] int h(void);
```

以下标准库函数均被声明带有 `noreturn` 属性：

```c
abort()
exit()
_Exit()
quick_exit()
thrd_exit()
longjmp()
```

>---

#### 13.8. unsequenced 和 reproducible 函数类型标准属性

函数类型的属性应应用于具有函数类型的类型说明符的函数声明符。相应的属性是函数类型的属性。这些属性适用于函数声明符或者具有函数类型的类型说明符。相应属性是函数类型的性质。这些属性区分读取操作（无状态和无关联）和写入操作（无效果、幂等和可重现）或两者的组合（未排序）

尽管在语义上附加到函数类型，但所描述的属性不是此类函数原型的一部分，并且删除此类属性的重新声明和转换是有效的，并构成兼容类型。相反，如果函数声明或具有该属性的类型的函数指针访问不具有断言属性的定义，则该行为是未定义的。

```c
[[ unsequenced ]]
[[ __unsequenced__ ]]

[[ reproducible ]]
[[ __reproducible__ ]]
```

`unsequenced` 指示函数无效果、幂等、无状态且无关联，即它是无序的。
`reproducible` 指示函数无效果且幂等，即它是可重现的。

这些属性为编译器优化的目的而存在：
- 如果函数 `reproducible` 可重现，则可将先后多次调用当做一次调用。
- 如果函数 `unsequenced` 无序，则可将先后多次调用当做一次调用，且这些调用可以并行化并任意重排。

```c
size_t hash(char const[static 32]) [[reproducible]];
bool tendency(signed char) [[unsequenced]];
```

> 无作用

如果函数调用过程中编入序列的任何存储操作，都是对某对象的同步于此次调用的修改，则该调用的执行是无作用的；如果这种存储操作还是可观察的，则对该对象的所有访问必须都基于函数的一个唯一指针形参进行。

> 幂等

对于某个求值 `E`，若 `E` 的第二次求值可以紧跟第一次求值编入序列而不改变结果值（如果有）或执行的可观察状态，则它是幂等的。

> 无状态

如果函数 `F` 或其所调用的任何函数中，具有静态或线程存储期的任意对象的定义均为 `const` 但无 `volatile` 限定，则 `F` 是无状态的。

> 无关联

对于函数 `F`，如果 `F` 的调用中可以通过并非该调用的形参的左值而观察到任何对象 `X`，而在同一次程序执行中所有对 `F` 的调用中，对 `X` 的所有访问都观察到相同的值，则 `F` 无关联；或者如果访问是通过某个指针形参进行，则应当有一个唯一的这种指针形参 `P`，使得对 `X` 的任何访问都应当是基于 `P` 的左值访问。

对象 `X` 由函数调用所观察的条件是：二者均同步，`X` 并非局部与此次调用，`X` 的生存期开始于函数调用之前，且此次调用中有对 `X` 的访问被排入序列；此次调用前所存储的 `X` 的最新值（如果有），被称为此次调用所观察到的 `X` 的值。

---
### 14. 预处理器与预处理指令

预处理器是将源文件的文本作为翻译的第一阶段操作的文本处理器。预处理器不会分析源文件，但会将其分解为标记以定位宏调用。

预处理器指令（如 ```#define``` 和 ```#ifdef```）通常用于使源程序在不同的执行环境中易于更改和编译。源文件中的指令指示预处理器执行特定操作。预处理器语句使用的字符集与源文件语句相同，但转义序列不受支持。

> *转换阶段*

C 和 C++ 程序包含一个或多个源文件，每个源文件包含程序的一些文本。源文件包含文件时，使用 ```#include``` 预处理器指令包含的头文件或其它源文件，但不包括由条件编译指令（如 ```#if``` ）删除的代码部分，称为 **翻译单元**。
翻译后的翻译单元可作为单独的对象文件或对象代码库处理。然后，将这些单独的已翻译的翻译单元链接起来以构成可执行程序或动态链接库 DLL。

> *翻译单元可通过以下项进行通信*

- 对具有外部链接的函数的调用。
- 对具有外部链接的类成员函数的调用。
- 对具有外部链接的对象的直接修改。
- 对文件的直接修改。
- 进程间通信（仅适用于基于 Microsoft Windows 的应用程序）

>---

#### 14.1. 空预处理指令

 null 预处理器指令是单一数字符号 `#` 行上唯一的符号。它没有作用。

```c
//...
#
//...
```

>---

#### 14.2. 条件包含与条件求值

预处理器支持有条件地编译源文件的某些部分。这一行为由 `#if`、`#else`、`#elif`、`#ifdef`、`#ifndef`、`#elifdef`、`#elifndef` 与 `#endif` 指令所控制。

条件预处理块由 `#if`、`#ifdef`、`#ifndef` 指令开始，然后可选地包含任意多个 `#elif`、`#elifdef`、`#elifndef` 指令，接下来是最多一个可选的 `#else` 指令，并以 `#endif` 结束。

`#if` 和 `#elif` 指令统称为条件表达式预处理指令。条件表达式包含预处理指令，`#ifdef`、`#ifndef`、`#elifdef`、`#elifndef` 指令统称为条件包含预处理指令。

`#if`、`#elif` 表达式是常量表达式，仅使用常量和预定义宏或由 `#define` 指令定义的宏标识。任何非字面量，未以 `#define` 指令定义的标识符，均求值为 ​0​，但 `true` 求值为 1。

表达式可以含有形式 `defined` 的一元运算符：

```c
defined identifier
defined ( identifier )
```

`defined identifier` 中的标识符，如果被定义为宏名称（预定义的或由 `#define identifier` 定义）且没有相同名称的 `#undef identifier` 指令时，条件表达式的计算结果为 1，否则为 0。

```c
#if !defined NDEBUG
    #include <assert.h>
#endif

#if defined ( _c_cpp__ )
	// ....
#endif
```

`#ifdef identifier` 与 `#if defined identifier` 实质上等价。
`#ifndef identifier` 与 `#if !defined identifier` 实质上等价。
`#elifdef identifier` 与 `#elif defined identifier` 实质上等价。
`#elifndef identifier` 与 `#elif !defined identifier` 实质上等价。

```c
#ifdef __STDC__
#define TITLE "ISO C Compilation"
#elifndef __cplusplus
#define TITLE "Non-ISO C Compilation"
#else /* C++ */
#define TITLE "C++ Compilation"
#endif
```

这种语境中，`__has_include`、`__has_embed` 和 `__has_c_attribute` 被当做如同它们是已定义宏的名字。若条件控制表达式求值为非零值，则包含该控制代码块并跳过其他。若所用的任何标识符不是常量，则用 ​0​ 替换它。预处理器语境中，`__has_c_attribute` 表达式检测给定属性令牌是否受支持及其受支持版本。

```c
__has_include ( header-name ) 
__has_include ( header-name-tokens )

__has_embed ( header-name embed-parameter-sequence? ) 
__has_embed ( header-name-tokens pp-balanced-token-sequence? )

__has_c_attribute ( pp-tokens )
```

>---

#### 14.3. 源文件包含

```c
#include < h-char-sequence >		(1)
#include " q-char-sequence "		(2)
#include pp-tokens					(3)
```

1. 搜索由 *h-char-sequence* 所标定的头文件，并以该头文件的整个内容替换该指令。
2. 搜索由 *q-char-sequence* 所标定的源文件，并以该源文件的整个内容替换该指令。如果不支持此搜索，或者搜索失败，则重新处理该指令，并将 *q-char-sequence* 当做头文件标识并进行搜索。
3. 预先对 `pp-token` 预处理标记序列进行宏替换，然后在对其替换的内容进行源文件或头文件搜索。

```c
#include <stdio.h>
#include "Test.c"
```

典型实现对语法 (1) 仅搜索标准包含目录。标准 C 程序库被隐含包括在这些标准包含目录之中。用户通常可以通过编译器选项来控制标准包含目录。

语法 (2) 的意图为搜索未处于实现控制下的文件。典型实现首先搜索当前文件所处的目录，然后回退到 (1)。

当包含一个文件时，对其进行翻译阶段的 1 - 4 的处理，其中可能（递归地）包含并展开嵌套的其他 `#include` 指令，直到由实现定义的嵌套极限为止。

为了避免重复包含相同文件和文件（可能传递地）包含自身时发生无限递归，通常会使用头文件防护：将整个头文件包围于：

```c
#ifndef FOO_H_INCLUDED /* 唯一映射到此文件名的任何名字 */
#define FOO_H_INCLUDED
// 此文件的内容在此
#endif
```

许多编译器还实现了具有类似效果的非标准语用 `#pragma once`：它在相同文件已被包含过时禁止再次处理该文件，其中以特定于操作系统的方式确定文件身份。

```c
#pragma once
// 此文件的内容在此
```

> *语法形式说明*

引号形式，预处理器按以下顺序搜索包含文件：
  1. 与包含 ```#include``` 语句的文件在同一目录中 。
  2. 搜索从父包含文件的目录中开始进行，然后继续向上到任何祖父包含文件的目录（需要指定相对路径）。
  3. 沿每个编译器选项指定的 ```/I``` 路径（Microsoft C 编译器）。
  4. **环境变量** 指定的路径 INCLUDE。

尖括号形式，预处理器按以下顺序搜索包含文件：
  1. 沿每个编译器选项指定的 ```/I``` 路径。
  2. 在命令行上编译时，沿环境变量指定的 INCLUDE 路径进行编译。

```c
// 查找系统目录
#include <stdio.h>
// 查找当前工作目录
#include "hot.h"
// 查找/usr/biff目录
#include "/usr/biff/p.h"
```

> __has_include

```c
__has_include ( " q-char-sequence " )
__has_include ( < h-char-sequence > )

__has_include ( string-literal )
__has_include ( < h-pp-tokens > )	
```

搜索由每个包含 `__has_include` 表达式中的标识的头文件或源文件，如果搜索源文件成功，`__has_include` 表达式的计算结果为 1，如果搜索失败则为 0。`__has_include` 结果为 1 仅表示存在具有指定名字的头文件或源文件。它并不意味着当包含该头文件或源文件时，不会导致错误或能够包含任何有用之物。

```c
#if __has_include(<optional.h>)
	#include <optional.h>
	#define have_optional 1
#elif __has_include(<experimental/optional.h>)
	#include <experimental/optional.h>
	#define have_optional 1
	#define have_experimental_optional 1
#endif
#ifndef have_optional
	#define have_optional 0
#endif
```

>---

#### 14.4. 二进制资源包含

`#embed` 是用于在构建中包含（二进制）资源的预处理器指令，其中的资源被定义为从翻译环境中可以访问的数据来源。嵌入参数是嵌入参数序列中的单个预处理器参数。该资源可以被实现作为一个给定的嵌入参数的二进制数据序列来处理。

资源具有实现的资源宽度，它是由实现定义的所定位资源的位大小。其资源宽度，为由实现定义的资源宽度，除非由嵌入参数 `limit` 所修改。若资源宽度为零，则认为该资源为空。嵌入元素宽度等于 `CHAR_BIT`，或由某个由实现定义的参数所修改。资源宽度必须可被嵌入元素宽度整除，即 *资源宽度* % *元素宽度* = 0。

```c
#embed < h-char-sequence > embed-parameter-sequence?		(1)
#embed " q-char-sequence " embed-parameter-sequence?		(2)
#embed pp-tokens											(3)
```

1. 搜索由 *h-char-sequence* 所唯一标定的资源，并将该指令替换为对应于该资源数据的整数的逗号分隔列表。
2. 搜索由 *q-char-sequence* 所标定的资源，并将该指令替换为对应于该资源数据的整数的逗号分隔列表。如果不支持此搜索，或者搜索失败，则重新处理该指令，并将 *q-char-sequence* 当做 *h-char-sequence* 并进行搜索。
3. 预先对 `pp-token` 预处理标记序列进行宏替换，然后在对其替换的内容进行资源搜索。

```c
#include <stddef.h>
void have_you_any_wool(const unsigned char*, size_t);

int main (int, char*[]) {
	static const unsigned char baa_baa[] = {
		#embed "black_sheep.ico"
	};
	have_you_any_wool(baa_baa, sizeof(baa_baa));
	return 0;
}
```

`#embed` 指令旨在将资源中的二进制数据转换为一系列整数常量表达式，以尽可能保留资源位流的值。

实现应该考虑执行时的位和字节顺序以及执行时的位和字节顺序，以便更恰当地表示来自指令的资源的二进制数据。如果在翻译时通过 `#embed` 指令引用的资源与通过执行时方式访问的资源相同，则这最大化了这样的机会，例如，`fread` 或类似的数据进入连续存储将逐位比较等于从 `#embed` 指令的扩展内容初始化的字符类型的数组。

`#embed` 指令展开为上述由整数常量表达式构成的列表。列表中每个整数常量表达式的记号组，与列表中前一个整数常量表达式的记号组之间，以逗号分隔。。这个序列不会以逗号开头或结束。若整数常量表达式的列表为空，则记号序列为空。该指令被替换为其展开，并根据给出的某些特定嵌入参数，带有额外的或者替换的记号序列。

扩展序列中的各整数常量表达式的值，由该资源的数据以实现定义的映射所决定。每个整数常量表达式的值在 [0, 2<sup> 嵌入元素宽度</sup> ) 范围内。如果：
- 整数常量表达式列表中用于初始化数组，其元素类型与 `unsigned char` 兼容，或在 `char` 可持有负值时与 `char` 兼容；且
- 嵌入的元素宽度等于 `CHAR_BIT`。

则所初始化的元素数组的内容如同在翻译时间将该资源的二进制数据以 `fread` 读入到数组中一样。

标准定义了参数 `limit`、`prefix`、`suffix` 和 `if_empty`。由实现定义的嵌入参数可能改变指令的语义。

> *limit*

嵌入参数 `limit` 在嵌入参数序列中最多可出现一次。它必须带有实参，必须为整数（预处理器）常量表达式 *E*，求值为非负数，且不包含记号 `defined`。

```c
limit ( 常量表达式 )
__limit__ ( 常量表达式 )	
```

资源宽度为：
- 如果整数常量表达式 *E* 的计算结果为 0，则为 0；或
- 如果实现定义资源宽度小于嵌入元素宽度乘以该整数常量表达式 *E*，则为实现定义资源宽度；或
- 嵌入元素宽度乘以该整数常量表达式的值，如果它小于或等于实现定义资源宽度。


```c
// 检查声音资源的前 4 个元素
#include <assert.h>

int main(int, char *[])
{
	static const char sound_signature[] = {
#embed <sdk/jump.wav> limit(2+2)  
	};
	static_assert((sizeof(sound_signature) / sizeof(*sound_signature)) == 4,
	"There should only be 4 elements in this array.");
	
	// verify PCM WAV resource
	assert(sound_signature[0] == ’R’);
	assert(sound_signature[1] == ’I’);
	assert(sound_signature[2] == ’F’);
	assert(sound_signature[3] == ’F’);
	assert(sizeof(sound_signature) == 4);
	return 0;
}
```

在 `CHAR_BIT` 大于 24 的环境中，资源可能没有足够的信息，这可能违反约束：

```c
int main (int, char*[]) {
	const unsigned char arr[] = {
#embed "24_bits.bin" limit(1) // may be a constraint violation, 资源宽度 = 1 x 24?
	};
	return 0;
}
```

某些实现接口的资源可能具有无限的数据流：

```c
int main (int, char*[]) {
	const unsigned char arr[] = {
embed </owo/uwurandom> limit(513)
	};
	return 0;
}
```

`limit` 参数可以帮助只处理该信息的一部分，并防止在处理此类数据时耗尽实现的内部资源。


> *suffix*

```c
suffix ( 预处理平衡记号序列? )
__suffix__ ( 预处理平衡记号序列? )
```

嵌入参数 `suffix` 在嵌入参数序列中最多可出现一次。它必须带有（可能为空的）实参子句。如果资源非空，则该参数子句的内容被置于紧跟该指令的展开之后。否则，它没有效果。


```c
// 添加到数组初始值设定项的额外元素
#include <string.h>
#ifndef SHADER_TARGET
	#define SHADER_TARGET "edith-impl.glsl"
#endif

extern char* null_term_shader_data;
void fill_in_data () {
	const char internal_data[] = {
#embed SHADER_TARGET \ 
	suffix(,)
	0 // 源序列后补一个 0 元素
	};
	strcpy(null_term_shader_data, internal_data);
}
```

> *prefix*

```c
prefix ( 预处理平衡记号序列? )
__prefix__ ( 预处理平衡记号序列? )
```

嵌入参数 `prefix` 在嵌入参数序列中最多可出现一次。它必须带有（可能为空的）实参子句。如果资源非空，则该参数子句的内容被置于紧接该指令的展开之前。否则，它没有效果。

```c
// 当资源不为空时，为其嵌入一个前缀和后缀的附加标记
#include <assert.h>
#include <string.h>

#ifndef SHADER_TARGET
	#define SHADER_TARGET "ches.glsl"
#endif

extern char* merp;
void init_data () {
	const char whl[] = {
#embed SHADER_TARGET \
	prefix(0xEF, 0xBB, 0xBF, ) /* UTF-8 BOM */ \
	suffix(,)
	0
	};
// always null terminated,
// contains BOM if not-empty
	int is_good = (sizeof(whl) == 1 && whl[0] == ’\0’)
		|| (whl[0] == ’\xEF’ && whl[1] == ’\xBB’
		&& whl[2] == ’\xBF’ && whl[sizeof(whl) - 1] == ’\0’);
	assert(is_good);
	strcpy(merp, whl);
}
```

> *if_empty*

```c
if_empty ( 预处理平衡记号序列? )	
__if_empty__( 预处理平衡记号序列? )	
```

嵌入参数 `if_empty` 在嵌入参数序列中最多可出现一次。它必须带有（可能为空的）实参子句。如果资源为空，则以该参数子句的内容替换该指令。否则，它没有效果。

```c
// 如果资源搜索成功，由于 limit(0) 这个资源总被视为空。这个程序总是返回 0
int main(){
	return 
#embed <some_resource> \
	limit(0) \			// 资源宽度计算为 0
	prefix(1) \			// 资源被视为空，前缀无效
	if_empty(0)			// 资源为空，使用序列 0 替代
	;
	// become: return 0;
}
```

> __has_embed

```c
__has_embed ( " q-char-sequence " embed-parameter-sequence? )
__has_embed ( < h-char-sequence > embed-parameter-sequence? )

__has_embed ( string-literal pp-balanced-token-sequence? )
__has_embed ( < h-pp-tokens > pp-balanced-token-sequence? )	
```

搜索由每个包含 `__has_embed` 表达式中的标识的资源，`__has_embed` 表达式的计算结果和以下预定义的宏相同：
- `__STDC_EMBED_NOT_FOUND__  0`：如果搜索资源失败，或者如果指定的嵌入参数序列中的任何嵌入参数不受 `#embed` 指令的实现支持；
- `__STDC_EMBED_FOUND__  1`：如果搜索资源成功，并且 `#embed` 指令的实现支持指定的嵌入参数序列中的所有嵌入参数，并且资源不为空；
- `__STDC_EMBED_EMPTY__  2`：如果搜索资源成功，并且 `#embed` 指令的实现支持指定的嵌入参数序列中的所有嵌入参数，并且资源为空。

`__has_embed` 可在 `#if` 和 `#elif` 的表达式中展开。它被 `#ifdef`、`#ifndef`、`#elifdef`、`#elifndef` 和 `defined` 当做已定义宏，但不能用在别处。

```c
int main () {
#if __has_embed ("bits.bin" clang::element_type(short))
	// load "short" values directly from memory
	short meow[] = {
#embed "bits.bin" clang::element_type(short)
	};
#else
	// no support for implementation-specifid
	// clang::element_type parameter
	unsigned char meow_bytes[] = {
#embed "bits.bin"
	};
	unsigned short meow[] = {
		/* parse meow_bytes into short values
		   by-hand! */
	};
#endif
	return 0;
}
```

可以使用 `__FILE__` 和 `__has_embed` 组合来检查是否支持由 `$embed` 指令嵌入参数的特定实现扩展。

```c
#if __has_embed(__FILE__ ext::token(0xB055))
	#define DESCRIPTION "Supports extended token embed parameter"
#else
	#define DESCRIPTION "Does not support extended token embed parameter"
#endif
```

以下用于检查特定实现定义的嵌入参数的支持，否则使用标准行为来产生相同的效果。

```c
void parse_into_s(short *ptr, unsigned char *ptr_bytes, unsigned long long size);
int main()
{
#if __has_embed("test.bin" ds9000::element_type(short))
    /* Implementation extension: create short integers from the */
    /* translation environment resource into */
    /* a sequence of integer constants */
    short meow[] = {
#embed "bits.bin" ds9000::element_type(short)
    };
#elif __has_embed("test.bin")
    /* no support for implementation-specific */
    /* ds9000::element_type(short) parameter */
    const unsigned char meow_bytes[] = {
#embed "bits.bin"
    };
    short meow[sizeof(meow_bytes) / sizeof(short)] = {};
    /* parse meow_bytes into short values by-hand! */
    parse_into_s(meow, meow_bytes, sizeof(meow_bytes));
#else
#error "cannot find test.bin resource"
#endif
    return (int)(meow[0] + meow[(sizeof(meow) / sizeof(*meow)) - 1]);
}
```

>---

#### 14.5. 宏替换

预处理器支持文本宏替换及类函数文本宏替换。

```c
#define identifier replacement-list?
#define identifier ( param-list ) replacement-list
#define identifier ( param-list, ... ) replacement-list
#define identifier ( ... ) replacement-list
#undef identifier
```

`#define` 指令定义 *identifier* 为宏，即它们指示编译器将后继出现的所有标识符均替换为 *replacement-list* 替换列表，可以可选地附加处理。

`#undef` 指令解除定义 *identifier*，即它取消先前 `#define` 对标识符的定义。若标识符无与之关联的宏，则忽略此指令。

```c
#define Some_Macro

#ifdef Same_Macro
	#undef Same_Macro
#endif
```

> *仿对象宏*

```c
#define identifier replacement-list?
```

仿对象宏将所定义的标识符的每次出现替换为替换列表。

```c
#define MINSIZE 512

int * CreateArray(int [static MINSIZE]);

// 翻译阶段替换为
int * CreateArray(int [static 512]);
```

> *仿函数宏*

```c
#define identifier ( param-list ) replacement-list			(1)
#define identifier ( param-list, ... ) replacement-list		(2)
#define identifier ( ... ) replacement-list					(3)
```

仿函数宏将所定义的 *标识符* 的每次出现替换为 *替换列表*，其额外接受一定数量的实参，它们会在 *替换列表* 中的任何形参的位置上对应出现：
1. 定义简单的仿函数宏。
2. 定义有可变参数实参的仿函数宏。能用 `__VA_ARGS__` 标识符访问额外实参，然后该标识符被实参替换。
3. 定义有可变数量实参的仿函数宏，但没有常规参数。只能用 `__VA_ARGS__` 标识符访问实参，然后该标识符被实参替换。

*替换列表* 可包含标记序列 `__VA_OPT__( content )`。标记序列在 `__VA_ARGS__` 非空时，将替换为 *content*，否则将展开为空。

```c
#define F(...) f(0 __VA_OPT__(,) __VA_ARGS__)
F(a, b, c) // 替换为 f(0, a, b, c)
F()        // 替换为 f(0)

#define G(X, ...) f(0, X __VA_OPT__(,) __VA_ARGS__)
G(a, b, c) // 替换为 f(0, a, b, c)
G(a, )     // 替换为 f(0, a)
G(a)       // 替换为 f(0, a)

#define SDEF(sname, ...) S sname __VA_OPT__(= { __VA_ARGS__ })
SDEF(foo);       // 替换为 S foo;
SDEF(bar, 1, 2); // 替换为 S bar = { 1, 2 };
```

可以使用足够多的圆括号来确保仿函数宏正确的结合顺序。

```c
#define FUN(X,Y) (((X)+(Y))/2)
// X, Y   宏参数
//FUN()	  宏函数

#define SQUARE(X) X*X
//在程序中可以这样用：
z = SQUARE(2);   // 2*2 = 4;
Z = SQUARE(z+1); // z+1*z+1 = 4+4+1 = 9;
// 宏函数与标准函数的区别在于, 宏仅仅是在预处理阶段将替换体替换掉宏标识, 并不参与计算
```

从技术角度来看，可以把宏的替换体看作是记号（token）型字符串，而不是字符型字符串。
由于编译器理解 C 语言的规则，所以不要求代码中用空格来分隔记号。C 编译器可以把 ```2*2``` 直接视为 3 个记号，因为它可以识别 2 是常量，```*``` 是运算符。

> *字符串化运算符 `#`*

在仿函数宏中，*替换列表* 中标识符前的 `#` 字符串化运算符对标识符做形参替换，并将结果环绕在引号中，等效地创建一个字符串字面量。

例如 `x` 是一个宏形参，那么 ```#x``` 就是转换为字符串 ```"x"``` 的形参名。这个过程称为字符串化（stringify）：
- 格式要求：在字符串外使用 ```"str1" #x "str2"```，在字符串内使用没有替换功能。
- 转换过程：```#signal``` >>> ```"signal"```。

```c
#define PSQR(x) printf("The square of " #x " is %d.\n",((x)*(x)))

int main(void){
	int y = 5;
	PSQR(y);
	PSQR(2 + 4);
}
// The square of y is 25.
// The square of 2 + 4 is 36.
```

预处理器会添加反斜杠，以转义环绕内嵌字符串字面量的引号，若存在，并按需在字符串中双写反斜杠。它移除所有前导和尾随空白符，且将任何文本中部的空白符序列（但非内嵌字符串字面量中的）缩减成单个空格。

```c
#define Show(x) puts(#x);
Show("\123");   // 展开为 puts("\"\\123\"");
```

`#` 出现在 `__VA_ARGS__` 之前时，将整个展开后的 `__VA_ARGS__` 放入引号：

```c
#define Showlist(...) puts(#__VA_ARGS__)
Showlist();            // 展开成 puts("")
Showlist(1, "x", int); // 展开成 puts("1, \"x\", int")
```

> *连接运算符 `##`*

```##``` 运算符可用于仿函数宏的替换部分。而且，```##``` 还可用于对象宏的替换部分。```##``` 运算符把两个记号组合成一个记号。

只可以粘贴有一同组成合法记号的记号：组成较长标识符的标识符、组成数字的数位、或组成 `+=` 的运算符 `+` 与 `=`。不能通过粘贴 `/` 与 `*` 创建注释，因为注释在进行宏替换前已被移除。若连接的结果不是合法记号，则行为未定义。

一些编译器提供允许 `##` 出现在逗号后和 `__VA_ARGS__` 前的扩展，在此情况下 `##` 在 `__VA_ARGS__` 非空时无效，但在 `__VA_ARGS__` 为空时移除逗号：这使得可以定义如 `fprintf (stderr, format, ##__VA_ARGS__)` 的宏。

标准没有规定 `#` 与 `##` 操作符的求值顺序。

```c
#include <stdio.h>
#define XNAME(n) x ## n   // 表示将 x 与 n 组合成一个记号
#define PRINT_XN(n) printf("x" #n " = %d\n", x ## n);

int main(void)
{
	int XNAME(1) = 14; 	// 变成 int x1 = 14;
	int XNAME(2) = 20; 	// 变成 int x2 = 20;
	int x3 = 30;

	PRINT_XN(1); // 变成 printf("x1 = %d\n", x1);
	PRINT_XN(2); // 变成 printf("x2 = %d\n", x2);
	PRINT_XN(3); // 变成 printf("x3 = %d\n", x3);
	return 0;
}
/*
	PRINT_XN() 宏用 # 运算符组合字符串
	## 运算符把记号组合为一个新的标识符。
*/
```

>---
#### 14.6. 取消宏定义

`#undef` 移除（取消定义）之前使用 ```#define``` 创建的名称，后续出现的标识符会被预处理器忽略。若标识符无与之关联的宏，则忽略此指令。

```__DATE__``` 和 ```__FILE__```，这些宏是已定义的，且不能取消定义。

```c
#define WIDTH 80
#define ADD( X, Y ) ((X) + (Y))
.
.
#undef WIDTH
#undef ADD
```

>---
#### 14.7. 文件名与行信息

```c
#line digit-sequence		
#line digit-sequence " s-char-sequence "
#line pp-tokens
```

`#line digit-sequence` 指令更改当前预处理器行号为 *digit-sequence* 表示的行号。从此点开始，宏 `__LINE__` 的出现会展开成 *行号* 加上自此遇到的实际代码行数。若 *行号* 为 0、或大于 32767 (C99 前)、或大于 2147483647 (C99 起)，则行为未定义。



`#line digit-sequence " s-char-sequence "` 将当前预处理器文件名更改为 *s-char-sequence* 表示的文件名，此点后宏 `__FILE__` 的每次出现将生成 *文件名*。

一些自动代码生成工具从以其他语言书写的文件产生 C 源文件，它们会使用此指令。该情况下，它们可能插入引用原始源文件的行号和文件名的 ```#line``` 指令到生成的 C 文件中。

```c
#include <assert.h>
#define FNAME "test.c"
int main(void)
{
#line 777 FNAME
        assert(2+2 == 5);
}
// test: test.c:777: int main(): Assertion `2+2 == 5' failed.
```

编译器使用行号和可选文件名来引用它在编译过程中发现的错误。

```c
// line_directive.c
#include <stdio.h>

int main()
{
    printf( "This code is on line %d, in file %s\n", __LINE__, __FILE__ );
#line 10
    printf( "This code is on line %d, in file %s\n", __LINE__, __FILE__ );
#line 20 "hello.c"
    printf( "This code is on line %d, in file %s\n", __LINE__, __FILE__ );
    printf( "This code is on line %d, in file %s\n", __LINE__, __FILE__ );
}
/* Output
	This code is on line 6, in file line_directive.c
	This code is on line 10, in file line_directive.c
	This code is on line 20, in file hello.c
	This code is on line 21, in file hello.c
*/
```

> *`#line` 和 `__LINE__` 与 `__FILE__`*

当给定的断言不为 true 时，宏 ASSERT 将使用预定义的宏 ```__LINE__``` ，并 ```__FILE__``` 打印有关源文件的错误消息。

```c
#define ASSERT(condition) if( !(condition) )\
{ printf( "assertion error line %d, file(%s)\n", __LINE__, __FILE__ ); }
```

>---

#### 14.8. 诊断指令

```c
#error " s-char-sequence "
#error pp-tokens

#warning " s-char-sequence "
#warning pp-tokens
```

`#error` 和 `#warning` 指令使实现产生一个诊断消息。`#error` 会终止编译，但 `#warning` 不影响程序的合法性并编译继续。

```c
#if __STDC__ != 1
#error "Not a standard compliant compiler"
#endif
 
#if __STDC_VERSION__ >= 202311L
#warning "Using #warning as a standard feature"
#endif
 
#include <stdio.h>
int main (void)
{
    printf("The compiler used conforms to the ISO C Standard !!");
}
```

>---

#### 14.9. 实现定义行为控制

```c
#pragma pp-tokens
_Pragma ( "s-char-sequence" )
```

`#pragma` 指令控制编译器的实现指定行为，如禁用编译器警告或更改对齐要求等。忽略任何不被识别的语用。Pragma 指令指定特定于计算机或特定于操作系统的编译器功能。

C99 提供 ```_Pragma()``` 预处理器运算符，该运算符把字符串转换成普通的编译指示：移除 `"s-char-sequence"` 字符串字面值的编码前缀（若存在）、外层引号，及开头 / 尾随空白符，将每个 `\"` 以 `"`，每个 `\\` 以 `\` 替换，然后记号化结果，再如同在 `#pragma` 指令中使用其结果。

```_Pragma()``` 运算符不使用 `#` 符号，可以用于宏展开的一部分。

```c
_Pragma("nonstandardtreatmenttypeB on");
// 等价于
#pragma nonstandardtreatmenttypeB on
```

如果预处理标记 `STDC` 紧跟在指令中的 `pragma` 之后（在任何宏替换之前），则不会对指令执行宏替换，并且指令应具有以下形式之一

```c
#pragma STDC FP_CONTRACT on-off-switch        
#pragma STDC FENV_ACCESS on-off-switch
#pragma STDC CX_LIMITED_RANGE on-off-switch

// on-off-switch: one of
	ON
	OFF
	DEFAULT

#pragma STDC FENV_ROUND direction

// direction: one of
	FE_DOWNWARD
	FE_TONEAREST
	FE_TONEARESTFROMZERO
	FE_TOWARDZERO
	FE_UPWARD
	FE_DYNAMIC

#pragma STDC FENV_DEC_ROUND dec-direction

// dec-direction: one of
	FE_DEC_DOWNWARD
	FE_DEC_TONEAREST
	FE_DEC_TONEARESTFROMZERO
	FE_DEC_TOWARDZERO
	FE_DEC_UPWARD
	FE_DEC_DYNAMIC
```

- ```FENV_ACCESS OFF```：默认是关闭，表示编译器程序将访问或修改浮点环境这意味着禁用可能推翻标志测试和模式更改（例如，全局共用子表达式删除、代码移动，及常量折叠）的优化。
- ```FP_CONTRACT ON```：允许缩略浮点表达式，即忽略舍入错误和浮点异常的优化，被观察成表达式以如同书写方式准确求值。
- ```CX_LIMITED_RANGE OFF```：告知编译器复数的乘法、除法，及绝对值可以用简化的数学公式，不考虑中间溢出的可能性。
- `FENV_ROUND` 
- `FENV_DEC_ROUND`

> *非标准语用*

```c
#pragma once		// 当某个头文件中包含它时，指示编译器只对其分析一次
#pragma pack		// 控制后继定义的结构体和联合体的最大对齐系数

#pragma pack(integer)          // 设置当前对齐为值 integer
#pragma pack()                 // 设置当前对齐为默认值（由命令行选项指定）
#pragma pack(push)             // 推入当前对齐的值到内部栈
#pragma pack(push, integer)    // 推入当前对齐的值到内部栈然后设置当前对齐为值 integer
#pragma pack(pop)              // 从内部栈弹出顶条目然后设置（恢复）当前对齐为该值

#pragma unpack()     // 取消上次设定的对齐系数
```

>---
####  14.10. 预定义宏

下列宏名称在任意翻译单元中均被预定义：

| Macro                                                                          | Description                                                                                                                        |
| :----------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------- |
| `__STDC__`                                                                     | 展开成整数常量 1。此宏是用以指示遵从标准的实现                                                                                     |
| `__STDC_VERSION__`                                                             | 展开成 `long` 类型的整数常量，其值随着 C 标准的每个版本递增                                                                        |
| `__STDC_HOSTED__`                                                              | 若实现有宿主（在操作系统下运行），则展开成整数常量 1，若为自立的（不在操作系统中运行）则展开成 ​0                                  |
| `__FILE__`                                                                     | 展开成当前文件名，为字符串字面量，可用 `#line` 指令更改                                                                            |
| `​__LINE__`                                                                    | 展开成源文件行号，为整数常量，可用 #line 指令更改                                                                                  |
| `__DATE__`                                                                     | 展开成翻译的日期，格式为 `"Mmm dd yyyy"` 的字符串字面量。月份名如同以 `asctime` 生成，而若月之日期小于 10 则 `"dd"` 的首字符为空格 |
| `__TIME__`                                                                     | 展开成翻译的时间，格式为 `"hh:mm:ss"` 的字符串字面量，如同 `asctime()` 所生成                                                      |
| `__STDC_UTF_16__`                                                              | 扩展为 1 以指出 `char16_t` 使用 UTF-16 编码                                                                                        |
| `__STDC_UTF_32__`                                                              | 扩展为 1 以指出 `char32_t` 使用 UTF-32 编码                                                                                        |
| `__STDC_EMBED_NOT_FOUND__`<br>`__STDC_EMBED_FOUND__`<br>`__STDC_EMBED_EMPTY__` | 分别扩展为 ​0​、1 和 2                                                                                                             |
  
实现可能预定义下列额外宏名：

| Macro                        | Description                                                                                                   |
| :--------------------------- | :------------------------------------------------------------------------------------------------------------ |
| `__STDC_ISO_10646__`         | 若 wchar_t 使用 Unicode，则展开成形式为 yyyymmL 的整数常量，日期指示受支持的 Unicode 最近版本                 |
| `__STDC_IEC_559__`           | 若支持 IEC 60559 则展开成 1 (弃用) (C23 起)                                                                   |
| `__STDC_IEC_559_COMPLEX__`   | 若支持 IEC 60559 复数算术则展开成 1 (弃用) (C23 起)                                                           |
| `__STDC_UTF_16__`            | 若 `char16_t` 使用 UTF-16 则展开成 1                                                                            |
| `__STDC_UTF_32__`            | 若 `char32_t` 使用 UTF-32 则展开成 1                                                                            |
| `__STDC_MB_MIGHT_NEQ_WC__`   | 若 `'x' == L'x'` 可能对基础字符集的成员为 `false` 则展开成 1，例如在基于 EBCDIC 的，`wchar_t` 使用 Unicode 的系统上 |
| `__STDC_ANALYZABLE__`        | 若支持可分析性则展开成 1                                                                                      |
| `__STDC_LIB_EXT1__`          | 若支持边界检查接口则展开成整数常量 201112L                                                                    |
| `__STDC_NO_ATOMICS__`        | 若不支持原子类型和原子操作库则展开成 1                                                                        |
| `__STDC_NO_COMPLEX__`        | 若不支持复数类型和复数运算库则展开成 1                                                                        |
| `__STDC_NO_THREADS__`        | 若不支持多线程则展开成 1                                                                                      |
| `__STDC_NO_VLA__`            | 若不支持自动存储期的 (C23 起) 非常量长度数组及可变修改类型 (C23 前) 则展开成 1                                  |
| `__STDC_IEC_60559_BFP__`     | 若支持 IEC 60559 二进制浮点算术则展开成 202311L                                                               |
| `__STDC_IEC_60559_DFP__`     | 若支持 IEC 60559 十进制浮点算术则展开成 202311L                                                               |
| `__STDC_IEC_60559_COMPLEX__` | 若支持 IEC 60559 复数算术则展开成 202311L                                                                     |
| `__STDC_IEC_60559_TYPES__`   | 若支持 IEC 60559 互换可扩展类型则展开成 202311L                                                               |

这些宏的值（除了 `__FILE__` 和 `__LINE__`）在整个翻译单元中保持常量。尝试重定义或解除定义这些宏导致未定义行为。

>---

#### 14.11. 预定义变量

预定义变量 `__func__` 不是预处理器宏，尽管有时与 `__FILE__` 及 `__LINE__` 一同使用它，例如通过 `assert`。```__func__``` 隐式定义为包含函数的未限定和未修饰名称的字符串。

```c
void example(){
    printf("%s\n", __func__);
}
// prints "example"
```

---