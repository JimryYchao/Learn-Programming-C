## C 内存模型与内存管理

---
### 内存模型

 为 C 抽象机的目的，定义计算机内存存储的语义。用于 C 程序的数据存储（内存）是一个或多个连续字节的序列。内存中每个字节拥有唯一的地址。

> *字节*

 字节是内存的最小可寻址单元。它定义为一系列连续的位，以保有任何基础执行字符集。

> *内存位置*

 可以是一个标量类型（算术类型、指针类型、枚举类型）的对象，或非零长位域的最大连续序列。

> *线程及数据竞争*

 执行的线程是一个程序中的控制流，它以调用顶层函数 ```thrd_create``` 或其他方法起始。任意线程可潜在地访问程序中的任意对象（拥有自动及线程局域存储期的对象仍能通过指针被另一线程访问）。执行的不同线程始终允许同时访问（读或修改）不同的内存位置。

 一个表达式的求值写入一个内存位置，而另一求值读取或修改同一内存位置时，我们称这两个表达式冲突。拥有两个冲突表达式的程序有数据竞争，除非两个冲突求值是原子操作（尽可能小的避免死锁与长时间等待），或一个冲突求值先发生于另一个。发生数据竞争，则程序行为未定义。

---
### 内存管理

 C 语言的内存管理，分成两部分。一部分是系统管理的，另一部分是用户手动管理的。
 一般 C 数据声明时，程序使用的内存大多数是自动分配的（```stdlib.h```）

> *系统管理的内存*

 系统管理的内存主要是函数内部的变量（局部变量）。局部变量在函数运行时进入内存，函数运行结束后自动从内存卸载。这些变量存放的区域称为 “栈”（stack），“栈” 所在的内存是系统自动管理的。

> *用户手动管理的内存*

 用户申请的内存主要是程序运行的整个过程中都存在的变量（全局变量）。这些变量需要用户手动从内存释放。如果使用后忘记释放，它就一直占用内存，直到程序退出，这种情况称为 “内存泄漏”（memory leak）。这些变量所在的内存称为 “堆”（heap），“堆” 所在的内存是用户手动管理的。

#### void 指针

 每一块内存都有地址，通过指针变量可以获取指定地址的内存块。指针变量必须有类型，否则编译器无法知道，如何解读内存块保存的二进制数据。
 向系统请求内存的时候，有时不确定会有什么样的数据写入内存，需要先获得内存块，稍后再确定写入的数据类型。
 为了满足这种需求，C 语言提供了一种不定类型的指针，叫做 ```void``` 指针。它只有内存块的地址信息，没有类型信息，等到使用该块内存的时候，再向编译器补充说明，里面的数据类型是什么。

 `void` 指针等同于无类型指针，可以指向任意类型的数据，但是不能解读数据。```void``` 指针与其他所有类型指针之间是互相转换关系

#### malloc()

 可以使用 ```malloc``` 函数在程序运行时分配更多的内存，接受一个参数表示所需要的内存字节数，该函数会找到合适的匿名空闲内存块，返回值为动态分配内存的首字节地址（返回一个指针对象，指向 ```void``` 的指针）；分配内存失败时，将返回空指针。
 可以把指向 ```void``` 通用指针赋给任意类型的指针，不用考虑类型匹配的问题（可以强制转换成匹配的类型）。```malloc``` 函数要求系统在堆（heap）中分配一段连续的内存块，可以使用该函数为任意类型分配内存。

> *为 30 个 ```double``` 类型的值请求内存空间，ptd 指向该位置*

```c
    double * ptd;
    ptd = (double*)malloc(30* sizeof(double));
```

 ptd 指向一个 ```double``` 类型，但不是指向内含 30 个 ```double``` 类型值的块，ptd 指向了该内存的首元素，可以像数组那样 ```ptd[n]``` 访问该区域的元素变量

> *常见运用*

`malloc()` 最常用的场合，就是为数组和自定义数据结构分配内存。可以用来创建动态数组，根据成员数量的不同，而创建长度不同的数组。
`malloc()` 不会对所分配的内存进行初始化，里面还保存着原来的值。如果没有初始化，就使用这段内存，可能从里面读到以前的值。程序员要自己负责初始化。

> *伸缩型数组的结构*

```c
typedef struct
{
	int len;
	int arr[];
} Array;
Array arr = {.len = 10, .arr = (int *)malloc(arr.len * sizeof(int))};
```

> *内存分配失败*

 如果内存分配失败，可以调用 ```exit()``` 函数结束程序，或做一些其他的操作。 
 标准提供了两个返回值以保证在所有操作系统中都能正常工作：```EXIT_SUCCESS```（或者，相当于 0）表示普通的程序结束，```EXIT_FAILURE``` 表示程序异常中止。

```c
    ptd = (double *) malloc(n * sizeof(double));
	if(ptd==NULL){
		exit(EXIT_FAILURE);
		// or do...
	}
```

> *malloc 多维数组*

```c
    int n = 5;
    int m = 6;

    int arr[n][m];  // n x m de 变长数组
    int(*p1)[6];    // C99 之前写法
    int(*p2)[m];    // 需要编译器支持变长数组

    p1 = (int(*)[6])malloc(n*6*sizeof(int));    // n x 6 数组
    p2 = (int(*)[m])malloc(n*m*sizeof(int));    // n x m 数组, 需要支持变长数组
```

#### memset()

 由于 ```malloc``` 函数并不会将申请的内存归置为 0，可以使用 ```memset``` 将该内存归置为 0。

```c
int * pArr = malloc(sizeof(int)*size);
memset(pArr, 0, sizeof(int)*size);
```

#### free()

 `free()` 要与 ```malloc()``` 函数搭配使用，```free``` 函数的参数是 ```malloc``` 返回的地址，表示释放之前 ```malloc``` 分配的内存，·不能使用 ```free``` 释放其他方式分配的内存。
 被 ```free``` 释放掉的内存区域，访问数据时，数据将可能丢失，这块区域系统将放弃标记，但是 ```free``` 的内存区域的数据并不会立即消失，但不建议继续使用。
 一般将 ```free``` 函数位于程序的末尾。

> *动态数组*

 数组的声明，可以是常量表示维度自动分配内存创建，也可以声明变长数组，在函数块中的自动内存中创建，或者是声明一个指针，调用 ```malloc``` 函数创建

 利用变长数组的特征与分配内存函数可以创建动态数组，可以在程序运行时选择数组的大小和分配内存

> *malloc, free, exit 动态分配数组*

```c
#include <stdio.h>
#include <stdlib.h> 	/* 为 malloc()、free()提供原型 */
int main(void)
{
	double* ptd;
	int max;
	int number;
	int i = 0;
	puts("What is the maximum number of type double entries ? ");
	if (scanf("%d", &max) != 1)
	{
		puts("Number not correctly entered -- bye.");
		exit(EXIT_FAILURE);
	}
	ptd = (double*)malloc(max * sizeof(double));
	if (ptd == NULL)
	{
		puts("Memory allocation failed. Goodbye.");
		exit(EXIT_FAILURE);
	}
	/* ptd 现在指向有max个元素的数组 */
	puts("Enter the values (q to quit):");
	while (i < max && scanf("%lf", &ptd[i]) == 1)
		++i;
	printf("Here are your %d entries:\n", number = i);
	for (i = 0; i < number; i++)
	{
		printf("%7.2f ", ptd[i]);
		if (i % 7 == 6) // 7个元素一行
			putchar('\n');
	}
	if (i % 7 != 0)
		putchar('\n');
	puts("Done.");
	free(ptd);
	return 0;
}
```

> *free() 的重要性*

- 静态内存的数量在编译时是固定的，在程序运行期间也不会改变。
- 自动变量使用的内存数量在程序执行期间自动增加或减少。但是动态分配的内存数量只会增加，除非用 ```free()``` 进行释放。
- 若未使用 ```free``` 释放 ```malloc``` 申请的内存，且 ```malloc``` 返回的指针丢失或被释放，该区域内存也不会被自动回收，由于指针丢失，导致这块区域也无法访问且无法重复利用。
- 无节制申请内存但不释放的情况下，会导致大量的内存被耗尽，程序未结束之前就已经耗尽所有的内存，这类问题称为内存泄露（memory leak）。
- 因此在使用申请的内存之后不再使用，需要使用 ```free``` 释放掉多余的内存。

#### calloc()

 分配内存可以使用 ```calloc()```。

```c
void* calloc(unsigned int count, unsigned int size);
// count 表示所需的存储单元的数目
// size 表示存储单元的大小(字节为单位)
```

 ```calloc``` 函数在创建内存的时候，同时会将块中的所有位都设置为 0。使用 ```free``` 函数释放 ```calloc``` 申请的内存。

```c
long * newmem = (long *)calloc(100, sizeof(long));
```

> *calloc 与 malloc*

```c
int* p = calloc(10, sizeof(int));
// 等同于
int* p = malloc(sizeof(int) * 10);
memset(p, 0, sizeof(int) * 10);
```

 `calloc()` 相当于 ```malloc()``` + ```memset()```。```calloc``` 申请的内存也需要 ```free``` 释放。

#### realloc()

 `realloc()` 函数用于修改已经分配的内存块的大小，可以放大也可以缩小，返回一个指向新的内存块的指针。如果分配不成功，返回 ```NULL```。

```c
void* realloc(void* block, size_t size)
// block：已经分配好的内存块指针（由 malloc 或 calloc 或 realloc 产生）
// size：该内存块的新大小，单位为字节
```

 `realloc()` 可能返回一个全新的地址（数据也会自动复制过去），也可能返回跟原来一样的地址。
 `realloc()` 优先在原有内存块上进行缩减，尽量不移动数据，所以通常是返回原先的地址。如果新内存块小于原来的大小，则丢弃超出的部分。如果大于原来的大小，则不对新增的部分进行初始化。

```c
int* pArr = realloc(Null,sizeof(int)*100);  // 相当于新建内存
int* pArr2 = realloc(pArr, 0);	// 相当于缩小到 0, 释放掉内存
```

#### restrict 受限指针

 声明指针变量时，可以使用 ```restrict``` 限定符，告诉编译器，该块内存区域只有当前指针一种访问方式，其他指针不能读写该块内存。这种指针称为 “受限指针”（restrict pointer）。

```c
int* restrict p = malloc(sizeof(int));
```

#### memcpy 内存拷贝

 `memcpy()` 用于将一块内存拷贝到另一块内存。该函数的原型定义在头文件 ```string.h```。

```c
void* memcpy(
  void* restrict dest, 
  void* restrict source, 
  size_t n
);
// dest 是目标地址，source 是源地址, n 是复制字节大小
// 返回目标地址的指针
```

 目标地址与源地址这两个内存块不应该有互相重叠的区域。

> *复制字符串*

```c
  char s[] = "Goats!";
  char t[100];

  memcpy(t, s, sizeof(s));  // 拷贝7个字节，包括终止符 \0
```

#### memmove 内存移动

 `memmove()` 函数用于将一段内存数据复制到另一段内存。它跟 ```memcpy()``` 的主要区别是，它允许目标区域与源区域有重叠。如果发生重叠，源区域的内容会被更改；如果没有重叠，它与 ```memcpy()``` 行为相同。

```c
void* memmove(
  void* dest, 
  void* source, 
  size_t n
);
```

#### memcmp 内存比较

```c
int memcmp(
  const void* s1,
  const void* s2,
  size_t n	// 比较的字节数
);
```

 它的返回值是一个整数。两块内存区域的每个字节以字符形式解读，按照字符顺序进行比较，如果两者相同，返回 0；如果 s1 大于 s2，返回大于 0 的整数；如果 s1 小于 s2，返回小于 0 的整数。

#### 动态内存分配和变长数组

 使用变长数组或 ```malloc``` 创建数组的行为很相似，但变长数组是自动存储类型，该内存空间会自动释放，而 ```malloc``` 需要使用 ```free``` 释放不用的空间。
 变长数组仅能在该定义的块中使用，```malloc``` 创建的数组可以在多个函数中调用。
 `free` 使用的指针变量可以与 ```malloc``` 的指针变量不同，但要求两个指针的地址值相同，不能释放同一块内存两次。

#### 存储类别与动态内存分配

 假设一个理想化模型：程序把它可用的内存分为：
  - 一部分供具有外部链接、内部链接和无链接的静态变量使用；
  - 一部分供自动变量使用；
  - 一部分供动态内存分配。

 静态类型所用的内存数量在编译时确定，与程序的生命周期共存，程序结束时销毁。
 自动类型在程序进入定义块时创建，离开块时销毁，这部分内存通常以栈方式处理，新创建的变量按顺序加入内存，以相反的顺序销毁。
 动态分配的内存在调用 ```malloc``` 或相关函数时存在，在调用 ```free``` 时释放，未使用的内存块分散在已使用的内存块之间，使用动态内存通常比栈内存慢（动态分配的区域一般称为内存堆或自由内存）。

---