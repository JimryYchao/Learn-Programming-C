## C 组成元素

---
### 标记、空白字符、注释

> *标记*

C 编译器识别的基本元素是 **标记**（令牌），包括有关键字、标识符、常量、字符串、运算符、标点符号等。

> *空白字符*

空白字符包括有空格 ```' '```、水平制表符 ```'\t'```、换行符 ```'\n'```、回车符 ```'\r'```、换页符 ```'\f'``` 和垂直制表符 ```'\v'```。标记由空白符和其他标记分隔（划分边界），在分析代码时，编译器将忽略空白字符。

> *注释*

```c
// CXX 单行风格
/*
	C 多行
	风格
*/
```

> *标识符（identifier）*

标识符为程序中的变量、类型、函数和标签提供名称，名称在拼写和大小写上必须与任何关键字都不同。标识符的首字符不可以是数字字符。

```c
/* 有效标识符 */
_Identifier
Identifier
Identifier123
```

> *标识符翻译限制*

  自 C99 后各标识符极限：
  - 内部标识符或宏名中 63 个有效起始字符；
  - 外部标识符中 31 个有效起始字符；
  - 一个翻译单元中 4095 个外部标识符；
  - 一个块中声明 511 个拥有块作用域的标识符；
  - 一个预处理翻译单元中同时定义 4095 个宏标识符。


>---
### 关键字（令牌）类型

> *标准 C 关键字*

| Keyword       | Description                                          |
| :------------ | :--------------------------------------------------- |
| alignas       | 设置类型的对齐属性                                   |
| alignof       | 获取类型的对齐属性                                   |
| auto          | 自动类型声明                                         |
| bool          | 声明布尔类型                                         |
| break         | 跳出当前循环或分支                                   |
| case          | switch 语句的 case 分支                              |
| char          | 字符类型                                             |
| const         | 只读类型声明限定                                     |
| constexpr     | 常量表达式                                                    |
| continue      | 结束当前循环，进入下一轮                             |
| default       | switch 语句的默认分支                                |
| do            | do 循环体                                            |
| double        | 双精度浮点类型                                       |
| else          | if 语句 的 else 分支                                 |
| enum          | 枚举类型                                             |
| extern        | 外部类型引用声明                                     |
| false         | 布尔值，假                                           |
| float         | 单精度浮点类型                                       |
| for           | for 循环                                             |
| goto          | 无条件跳转语句                                       |
| if            | if 条件分支                                          |
| inline        | 内联函数                                             |
| int           | 整数类型                                             |
| long          | 长整数类型                                           |
| nullptr       | 空指针字面值                                         |
| register      | 寄存器存储类型声明                                   |
| restrict      | 参数引用类型声明限定                                 |
| return        | 函数返回语句                                         |
| short         | 短整数类型声明                                       |
| signed        | 声明有符号数值类型                                   |
| sizeof        | 计算数据类型或变量所占字节数                         |
| static        | 静态类型声明限定                                     |
| static_assert | 静态断言                                             |
| struct        | 结构类型                                             |
| switch        | switch 条件分支语句                                  |
| thread_local  | 线程本地存储声明                                     |
| true          | 布尔值，真                                           |
| typedef       | 类型别名声明                                         |
| typeof        | 获得变量或函数的类型                             |
| typeof_unqual | 无限制 typeof                                                    |
| union         | 联合或共用体类型                                     |
| unsigned      | 声明无符号数值类型                                   |
| void          | 无类型                                               |
| volatile      | 易变声明，声明的变量类型在程序执行过程中可被隐式改变 |
| while         | while 循环                                           |
| _Atomic       | 声明原子类型                                         |
| _BitInt       | 位精确整数                                                     |
| _Complex      | 声明复数类型                                         |
| _Decimal128   | 128 位十进制数                                       |
| _Decimal32    | 32 位十进制数                                        |
| _Decimal64    | 64 位十进制数                                        |
| _Generic      | 泛型编程                                             |
| _Imaginary    | 虚数类型                                             |
| _Noreture     | 应用方的函数不返回调用方                             |

> 关键字替代写法

| Keyword       | Alternative    |
| :------------ | :------------- |
| alignas       | _Alignas       |
| alignof       | _Alignof       |
| bool          | _Bool          |
| static_assert | _Static_assert |
| thread_local  | _Thread_local  |


>---
### 标点符号

```c
[    ]    (    )    {    }    .    ->
++   --   &    *    +    -    ~    !
/    %    <<   >>   <    >    <=   =>   ==   !=   ^    |    &&   ||
?    :    ::   ;    ...
=    *=   /=   %=   +=   -=   <<=  >>=  &=   ^=   |=
,    #    ##
```

> 二元符

```c
<:   :>   <%   %>   %:   %:%:
// 等效于
[    ]    {    }    #    ##
```


>---
### Constants

常量包含有整数常量、浮点常量、枚举常量、字符常量和预定义常量。每一个常量都包含一个类型，常量的值必须在其类型的可表示值范围内：

#### 整数常量

```c
0b'1010'0101            // 二进制
076543210               // 八进制

0x'abcdef
0X'ABCDEF0123456789   // 十六进制 
```

整数常量的类型是可以表示其值的相应列表中的第一个。

| Suffix                           | 十进制                                                            | 八进制、十六进制或二进制                                                                                    |
| :------------------------------- | :---------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------- |
| none                             | `int`<br>`long int`<br>`long long int`                            | `int`<br>`unsigned int`<br>`long int`<br>`unsigned long int`<br>`long long int`<br>`unsigned long long int` |
| `u` or `U`                       | `unsigned int`<br>`unsigned long int`<br>`unsigned long long int` | `unsigned int`<br>`unsigned long int`<br>`unsigned long long int`                                           |
| `l` or `L`                       | `long int` <br>`long long int`                                    | `long int`<br>`unsigned long int`<br>`long long int`<br>`unsigned long long int`                            |
| `ul` or `uL` or `Ul` or `UL`     | `unsigned long int`<br>`unsigned long long int`                   | `unsigned long int`<br>`unsigned long long int`                                                             |
| `ll` or `LL`                     | `long long int`                                                   | `long long int`<br>`unsigned long long int`                                                                 |
| `ull` or `Ull` or `uLL` or `ULL` | `unsigned long long int`                                          | `unsigned long long int`                                                                                    |
| `wb` or `WB`                     | `_BitInt(N)`，其中宽度 N 是大于 1 的可以容纳值和符号位的最小 N    | `_BitInt(N)`，其中宽度 N 是大于 1 的可以容纳值和符号位的最小 N                                              |
| `u` or `U` and `wb` or `WB`      | `unsigned _BitInt(N)`，其中宽度 N 是大于 0 的可以容纳值的最小 N   | `unsigned _BitInt(N)`，其中宽度 N 是大于 0 的可以容纳值的最小 N                                             |

```c
-3wb        /* Yields an _BitInt(3) that is then negated; two value bits, one sign bit */
-0x3wb      /* Yields an _BitInt(3) that is then negated; two value bits, one sign bit */
3wb         /* Yields an _BitInt(3); two value bits, one sign bit */
3uwb        /* Yields an unsigned _BitInt(2) */
-3uwb       /* Yields an unsigned _BitInt(2) that is then negated, resulting in wraparound */
```

#### 浮点常量

无后缀的浮点常量具有 `double` 类型，如果后缀是浮点后缀，则它具有类型：

| Suffix       | Type          | Description    |
| :----------- | :------------ | :------------- |
| `f` or `F`   | `float`       | 单精度浮点数   |
| `l` or `L`   | `long double` | 长双精度浮点数 |
| `df` or `DF` | `_Decimal32`  | 32 位十进制数  |
| `dd` or `DD` | `_Decimal64`  | 64 位十进制数  |
| `dl` or `DL` | `_Decimal128` | 128 位十进制数 |

浮点后缀 `df`、`dd`、`dl`、`DF`、`DD` 或 `DL` 不能用于十六进制浮点常量。浮点常量有一个有效部分，后面可能跟一个指数部分和一个指定其类型的后缀。有效数部分的组成部分可以是包括整数部分和小数部分的数字序列。在确定常数值时，忽略数字分隔符 `'`。指数部分的分量可以是 e、E、p、P，后跟由可选带符号的数字序列组成的指数。整数部分或分数部分必须存在；对于十进制浮点常量，分数或指数部分必须存在。

有效数部分被解释为（十进制或十六进制）有理数；指数部分中的数字序列被解释为十进制整数。对于十进制浮点常量，指数表示有效数部分要缩放的 10 的幂。对于十六进制浮点常量，指数表示有效数部分要缩放的 2 的幂。对于十进制浮点常量，以及当 `FLT_RADIX` 不是 2 的幂时的十六进制浮点常量，结果要么是最接近的可表示值，要么是与最接近的可表示值紧邻的较大或较小的可表示值，以实现定义的方式选择。对于十六进制浮点常量，当 `FLT_RADIX` 为 2 的幂时，结果将正确舍入。

浮点常量被转换为内部格式，就像在编译时一样。浮点常数的转换在执行时不应引发异常条件或浮点异常。同一源形式的所有浮点常量应转换为具有相同值的相同内部格式。

#### 枚举常量

对于没有固定基础类型的枚举，声明为枚举常量的标识符具有 `int` 类型或枚举类型。声明为具有固定基础类型的枚举的枚举常量的标识符具有关联的枚举类型。枚举常量可以在表达式（或常量表达式）中使用，只要可以使用整数类型的值。

#### 字符常量

整数字符常量是用单引号括起来的一个或多个多字节字符的序列。UTF-8  `char8_t` 字符常量以 `u8` 为前缀，`wchar_t` 字符常量以 `L` 为前缀，UTF-16 `char16_t` 字符常量以 `u` 为前缀，UTF-32 `char32_t` 字符常量以 `U` 为前缀。`wchar_t`、`char16_t`、`char32_t` 字符常量统称为宽字符常量。序列的元素是源字符集的任何成员；它们以实现定义的方式映射到执行字符集的成员。

UTF-8、UTF-16 或 UTF-32 字符常量不得包含多个字符。该值应分别用单个 UTF-8、UTF-16 或 UTF-32 代码单元表示。

```c
char8_t c8 = u8'A';     // UTF-8
char c = 'A';           
wchar_t wc = L'A';      // 宽字符
char16_t c16 = u'A';    // UTF-16
char32_t c32 = U'A';    // UTF-32

wchar_t mwc = L'123';   // 多字节字符
```

八进制转义序列以反斜杠开头后跟最多三个八进制数字的序列被视为整数字符常量的单个字符或宽字符常量的单个宽字符的构造的一部分。在十六进制转义序列中，`\x` 后跟最多四位的十六进制数字被视为整数字符常量的单个字符或宽字符常量的单个宽字符的构造的一部分。在通用字符名中，`\u` 后面的四位十六进制数字被视为整数字符常量的单个字符或宽字符常量的单个宽字符的构造的一部分。

```c
char oct = '\65';
char hex = '\xff';
char uni = '\u00f4';
```

#### 预定义常量

```c
false           
true
nullptr
```

`true` 和 `false`  是 `bool` 类型的常量，其中 `false` 的值为 0，`true` 的值为 1。`nullptr` 表示空指针常量。

>---
### 存储类说明符

```c
auto
constexpr
extern
register
static
thread_local
typedef
```

在声明中最多可以给定一个存储类说明符，除了：
- `thread_local` 可以和 `static` 或 `extern` 一起出现；
- `auto` 可以和除 `typedef` 之外的其他项一起出现；(C23)
- `constexpr` 可以和 `auto`、`register` 或 `static` 一起出现。

存储类说明符指定标识符和声明功能的各种属性：
- 存储持续时间：块范围的 `static`、`thread_local`、`auto`、`register`
- 链接：`extern`、`static`、文件范围的 `constexpr` 、`typedef`
- 值：`constexpr`
- 类型：`typedef`

<br>

#### auto

```auto``` 存储类说明符声明具有本地生存期的自动变量。只能声明在内部级别（函数体范围）。自动类型变量不会自动初始化（栈存储不存在垃圾回收），直接使用未定义的自动类型变量是未定义行为。
对于内部级别的静态类型，不能用自动类型进行初始化（因为自动类型的地址是不确定的）。

如果要从初始值设定项推断类型，则 `auto` 只能出现在具有文件范围的标识符的声明说明符中，或与其他存储类说明符一起出现。

如果 `auto` 与另一个存储类说明符一起出现，或者如果它出现在文件作用域的声明中，那么在确定存储持续时间或链接时将忽略它。在这种情况下，它仅表示可以推断声明的类型。

<br>

#### constexpr

使用 `constexpr` 声明的对象或其任何成员的对象（即使是递归的）不能具有原子类型、可变修改类型或 `volatile` 或 `restrict` 限定修饰的类型。`constexpr` 声明为定义，并且具有初始值设定项。初始值设定项的字符串文本中的任何常量表达式或任何字符的值都应在相应的目标类型中可完全表示。`constexpr` 在声明后值不可变。

使用 `constexpr` 声明的对象或子对象：
- 具有指针、整数或算数类型，则它的任何显式初始化设定项应分别是为 null、整数常量表达式或算数常量表达式。
- 具有实数浮点类型，则初始值设定项应具有整数或实数浮点类型。
- 具有虚数类型，则初始值设定项应具有虚数类型。
- 具有十进制浮点类型，则声明的对象应具有十进制浮点类型，并且转换应保留初始值设定项的量。
- 如果初始值设定项具有实数类型或 NaN 值，则初始值设定项类型的非限定版本和声明的对象的相应实数类型应兼容。

```c
struct s { void *p; };
constexpr struct s A = { nullptr };
constexpr struct s B = A;
/* 尽管表达式 A.p 不是一个空指针常量，而只是一个空指针，
但 B 的初始化中唯一的显式初始化项是 A，而不是 A.p，
因此该初始化没有违反约束。 */
```

使用存储类说明符 `constexpr` 声明的对象在翻译时其值永久固定。如果尚不存在，则将 `const` 限定隐式添加到对象的类型中。声明的标识符被视为相应类型的常量表达式。

在块范围中声明的对象，使用存储类说明符 `constexpr` 且不带 `static`，具有自动存储持续时间，标识符没有链接，并且对象的每个实例都有一个唯一的地址，可通过 `&`（如果未使用 `register` 说明符声明）获得（如果有）。文件范围中的此类对象具有静态存储持续时间，相应的标识符具有内部链接，并且每个看到相同文本定义的翻译单元都实现具有不同地址的单独对象。

使用 `constexpr` 说明符声明的标识符可以在常量表达式中使用其值；使用 `constexpr` 说明符声明的对象存储其初始值设定项的确切值，不支持隐式值更改。

```c
constexpr int K = 47;
enum{
    A = K,              // Valid, constant init
};
constexpr int L = K;    // Valid, constexpr init
static int b = K + 1;   // Valid, static init
int array[K];           // Not VLA

constexpr static unsigned short array[] = {
    3000,   // valid, fits in unsigned short range
    300000, // constraint violation if short is 16-bit
    -1      // constraint violation, target type is unsigned
};

struct S {
    int x, y;
};
constexpr struct S s = {
    .x = INT_MAX,   // valid
    .y = UINT_MAX,  // constraint violation
};
```

`constexpr` 对象的约束旨在翻译时强制检查可移植性：

```c
constexpr unsigned int minusOne = -1;         // constraint violation
constexpr unsigned int uint_max = -1U;        // ok
constexpr double onethird       = 1.0/3.0;    // possible constraint violation
constexpr double onethirdtrunc  = (double)(1.0/3.0);     // ok
constexpr _Decimal32 small      = DEC64_TRUE_MIN * 0;    // constraint violation
```

与字符串文本 `"\xFF"` 元素的 `char` 类型相关的实现定义行为可能会导致在翻译时违反约束

```c
constexpr char string[]            = { "\xFF", };   // ok
constexpr char8_t u8string[]       = { u8"\xFF", }; // ok
constexpr unsigned char ucstring[] = { "\xFF", };   // possible constraint violation
// 如果 char 能表示负数，且宽度为 8，上面的代码等效于
constexpr char string[]            = { -1, 0, };    // ok
constexpr char8_t u8string[]       = { 255, 0, };   // ok
constexpr unsigned char ucstring[] = { -1, 0, };    // constraint violation
// 如果 char 不能表示负数，则等效于
constexpr char string[]            = { 255, 0, };    // ok
constexpr char8_t u8string[]       = { 255, 0, };    // ok
constexpr unsigned char ucstring[] = { 255, 0, };    // ok
```

使用 `constexpr` 说明符声明的标识符可以在常量表达式中使用其值：

```c
constexpr int K = 47;
enum {
    A = K;
}
constexpr int L = K;
static int b = K + 1;
int array[K];   // 非 VLA
```

<br>

#### extern

```extern``` 存储类说明符声明对在其他位置类型声明的引用。在外部级别中引用声明之后，该引用声明将在剩余的翻译单元内均可见。
```extern``` 限定从未声明的类型，表明该声明是具有外部链接属性的，那么此定义可见于构成程序的任何翻译单元中。可以在文件范围和函数体范围内声明 ```extern``` 类型。

具有块范围的函数的标识符声明不应具有除 `extern` 之外的显式存储类说明符。

<br>

#### register

```register``` 限定变量的存储类为寄存器类型，变量通常储存在计算机内存中，寄存器变量储存在 CPU 的寄存器中，访问速度要比内存中的变量更快。当被编辑器忽略时，自动转换为自动类型。
寄存器类型无法获取地址，因此无法利用地址运算符，即使变为自动类型。

```c
int main(void){
    register int num = 1;       // 指定该变量储存在 CPU 寄存器中
}
void Fun(register int num);     // 指定形参储存方式
```

<br>

#### static

```static``` 限定类型的声明仅在当前范围内可见，且存储期是静态的（全局生存）。可以限制变量和函数的链接方式。可以在文件范围和函数体范围内声明 ```static``` 类型。
静态类型仅在首次进入所在范围时初始化，且仅在该声明的范围内私有永久存储，无论是内部级别或外部级别。

```c
static int num;         // 文件范围中内部链接静态存储持续时间
int foo(){
    static int local_num = num;     // 块范围中静态存储持续时间
}
```

<br>

#### thread_local

`thread_local` 声明的变量类型具有线程存储期，不能用于函数类型的声明。如果 `thread_local` 出现在任何对象的声明中，则该说明符应出现在该对象的每份声明中。当声明具有块范围的对象时，则需要与 ```static``` 或 ```extern``` 之一组合以决定其链接。线程对象在启动线程时开始初始化。

> *试探性定义*

试探性定义是没有初始化器的外部声明，且要么没有存储类说明符或拥有说明符 `static`。
试探性定义是可能或可能不表现为定义的声明。若在同一翻译单元的前方或后方能找到实际的外部定义，则试探性定义仅表现为声明；若在同一翻译单元中无定义，则试探性定义表现为将对象零初始化的实际定义。

 ```c
int i1 = 1;     	// 定义，外部链接
int i1;         	// 试探性定义，表现为声明，因为 i1 已定义
extern int i1;  	// 声明，引用前面的定义

extern int i2 = 3; 	// 定义，外部链接
int i2;            	// 试探性定义，表现为声明，因为 i2 已定义
extern int i2;     	// 声明，引用到前面的外部链接定义
```

不同于 ```extern``` 声明（如果前一声明已建立标识符链接，```extern``` 声明不更改链接属性），试探性定义可以与同一标识符另一声明的链接不一致。若同一标识符的二个声明均在作用域内且拥有不同链接，则行为未定义。

```c
static int i4 = 2; 	// 定义，内部链接
int i4;            	// 未定义行为：链接与前一行不一致
extern int i4;    	// 声明，引用到内部链接定义

static int i5; 		// 试探性定义，内部链接
int i5;        		// 未定义行为：链接与前一行不一致
extern int i5; 		// 引用到前者，其链接为内部
```

拥有内部链接的试探性定义必须拥有完整类型。

```c
static int i[];     // ERROR：试探性 static 声明中不允许出现不完整类型
int i[];            // 试探性声明，等价于 int i[1] = {0}; 除非在此文件之后重定义声明
```

<br>

#### typedef

使用 ```typedef``` 声明为已由 C 定义的类型或用户自定义类型构造更短和更有意义的名称。`typedef` 声明不会创建类型，而是创建现有类型的同义词或可通过其他方式指定的类型的名称。

当使用 ```typedef``` 名称作为类型说明符时，可以将其与特定的类型说明符组合，但不可以将其与其他类型说明符组合。可接受的修饰符包括 ```const``` 和 ```volatile```。

`typedef` 与通常标识符（例如枚举项、变量或函数）共享命名空间。

如果使用除 `typedef` 以外的存储类说明符声明聚合（结构或数组等）或联合对象，则存储类说明符生成的属性（链接除外）也适用于对象的成员，包括递归地适用于任何聚合或联合成员对象。

```c
typedef void fv(int);
typedef void (*pfv)(int);

void (*signal(int, void(*) (int)))(int);
// use fv
fv* signal(int, fv*);
// use pfv
pfv signal(int, pfv);
```

> *typedef 实例*

```c
// 定义声明
typedef struct{
	int count;
	float cost;
} book;
// 声明类型对象
book mbook = {.count = 10,.cost = 10* 1.5f};

// const 说明
typedef char* const ConstString;	// 指向常量字符串的指针
ConstString str = "HelloWorld";
typedef const char* ConstpStr;		// 指向字符串的常量指针
```

> *typedef 声明 VLA 数组*


如果 `typedef` 名称指定了可变修改的类型，则它应该具有块范围。每次按执行顺序到达 `typedef` 名称的声明时，都会计算与可变长度数组声明符和 `typeof` 运算符关联的任何数组大小表达式。`typedef` 声明不会引入新类型，而只会引入所指定类型的同义词。

对 VLA 的 ```typedef``` 只能出现在块作用域内，数组长度会在每次控制流经过 ```typedef``` 声明时求值。

```c
void F(int n){
    typedef int Array[n];	// Array 是 VLA ，其长度为 n ，现在求值
    n += 1;
    Array a; 				// a 的长度是 +=1 前的 n
    int b[n]; 				// a 和 b 长度不同
}
```


>---
### 类型说明符

```c
void
char
short
int
long
float
double
signed
unsigned
_BitInt( constant-expression )
bool
_Complex
_Decimal32
_Decimal64
_Decimal128
atomic-type-specifier
struct-or-union-specifier
enum-specifier
typedef-name
typeof-specifier
```

除了类型推断，任何声明中的声明说明符中，以及每个成员声明和类型声明的说明符限定符列表中，都应至少给出一个类型说明符。

```c
void
char
signed char
unsigned char
short / signed short / short int / signed short int
unsigned short / unsigned short int
int / signed / signed int
unsigned / unsigned int
long / signed long / long int / signed long int
unsigned long / unsigned long int
long long / signed long long /long long int / signed long long int
unsigned long long / unsigned long long int
_BitInt( constant-expression ) / unsigned _BitInt( constant-expression )
unsigned _BitInt( constant-expression )
float 
double
long double
_Decimal32
_Decimal64
_Decimal128
bool
float _Complex
double _Complex
long double _Complex
atomic type specifier
struct or union specifier
enum specifier
typedef name
typeof specifier
```

如果实现不支持复数类型，则不使用 `_Complex`；如果实现不支持十进制浮点类型，则不使用 `_Decimal32`、`_Decimal64`、`_Decimal128`。

关键字 `_BitInt` 的常量表达式应为整数常量表达式 N，用于指定类型的宽度。`unsigned _BitInt` 类型的宽度应大于等于 1，`signed _BitInt` 类型的宽度应大于 2。N 的值小于等于 `BITINT_MAXWIDTH`。


> *定义变量*

```c
/* 声明整型 */
<signed/unsigned> <char/short/int/long/long long> Integer;
enum EnumType;

/* 声明浮点型 */
<float/double/long double> Double

/* 声明指针 */
<type *> p;
int* pInt = &num;
```

<br>

#### void

```void``` 有三种用途：指定为函数返回类型、为未采用参数的函数指定一个参数类型列表、指定一个指向未指定的类型的指针。
```void*``` 能用作指向未指定的类型的指针，除 ```char*``` 外转换成其他类型的指针需要强制类型转换。

<br>

#### 整数数值类型

```c
// 1. short >>> 16 bits
    short int num1;
    short num2;
// 2. int   >>> 16/32 bits
    signed int num1;
    int num2;
// 3. long(L)  >>> 32 bits
    long int num1;
    long num2;
// 4. long long(LL) >>> 64 bits
    long long int num1;
    long long num2;
// 5. unsigned
    unsigned int ui;
    unsigned u;  // U 后缀
    unsigned short us;
    unsigned long ul; // UL 后缀
```

> *整型进制转换*

```c
printf("%d");       // 显示十进制数字
printf("%o");       // 以八进制显示数字
printf("%x");       // 以十六进制显示数字
// 显示进制数字前缀
printf("%#o");      // %#o、%#x、%#X,
```

> *整型可移植: ```stdint.h```*

- C99 新增了两个头文件 ```stdint.h``` 和 ```inttypes.h```，以确保 C 语言的类型在各系统中的功能相同。
* 在 ```stdint.h``` 头文件中，```int32_t``` 表示 32 位的有符号整数类型：
  - 在 32 位 ```int``` 的系统中，```int32_t``` 作为 ```int``` 的别名。
  - 在 ```int``` 为 16 位、```long``` 为 32 位的系统会把 ```int32_t``` 作为 ```long``` 的别名。
- 使用 ```int32_t``` 类型编写程序，并包含 ```stdint.h``` 头文件时，编译器会把 ```int``` 或 ```long``` 替换成与当前系统匹配的类型。

```c
// 1. 精确宽度整数类型
typedef signed char             int8_t;
typedef short                   int16_t;
typedef int                     int32_t;
typedef long long               int64_t;
typedef unsigned char           uint8_t;
typedef unsigned short          uint16_t;
typedef unsigned int            uint32_t;
typedef unsigned long long      uint64_t;
// 2. 至少有指定宽度的最小整数类型
typedef signed char             int_least8_t;
typedef short                   int_least16_t;
typedef int                     int_least32_t;
typedef long long               int_least64_t;
typedef unsigned char           uint_least8_t;
typedef unsigned short          uint_least16_t;
typedef unsigned int            uint_least32_t;
typedef unsigned long long      uint_least64_t;
// 3. 最快最小宽度类型
typedef signed char             int_fast8_t;
typedef int                     int_fast16_t;
typedef int                     int_fast32_t;
typedef long long               int_fast64_t;
typedef unsigned char           uint_fast8_t;
typedef unsigned int            uint_fast16_t;
typedef unsigned int            uint_fast32_t;
typedef unsigned long long      uint_fast64_t;
// 4. 系统的最大整数类型
typedef long long               intmax_t;
typedef unsigned long long      uintmax_t;
```

`int_least8_t` 是可容纳 8 位有符号整数值的类型中宽度最小的类型的一个别名。如果某系统的最小整数类型是 16 位，可能不会定义 ```int8_t``` 类型。该系统仍可使用 ```int_least8_t``` 类型，但可能把该类型转换为 16 位的整数类型。
`int_fast8_t` 被定义为系统中对 8 位有符号值而言运算最快的整数类型的别名。
C99 定义了最大的有符号整数类型 ```intmax_t```，可储存任何有效的有符号整数值。类似地，```unitmax_t``` 表示最大的无符号整数类型。这些类型有可能比 ```long long``` 和 ```unsigned long``` 类型更大。

<br>

#### char 字符

`char` 用于储存字符，技术层面本质是整数类型。```wchar_t``` 是 ```char``` 的宽字符版本。计算机使用数字编码来处理字符，用特定的整数表示特定的字符（常用编码 ASCII）。
常规 ```char``` 字符类型的宽度为 8 位，代表执行字符集；宽字符常量的宽度为 16 位，用于指定扩展执行字符集的成员，多字节字符是由一个或多个字节的序列构成的字符，常用于日文、中文等字符集字符表示。宽字符使用 L 前缀标明字符类型。

 ```c
// 声明字符类型
	char c = 'A';
// char 小整数
	unsigned char c_num = 1;
	signed char c_num = -2;
// 宽字符
	wchar_t CN_Str = L'宽';
```

转义序列被视为单个字符，是有效的字符常量。通常用于指定操作。

```
\a      警报
\b      退格
\f      换页
\n      换行
\r      回车
\t      水平制表符
\v      垂直制表符
\\      反斜杠
\'      单引号
\"      双引号
\?      问号
\o nn   八进制表示法的 ASCII 字符
\x hh   十六进制表示法的 ASCII 字符
\x hhhh 十六进制表示法的 Unicode 字符
```

> *双标符（替用记号）与三标符*

```c
// 双标符
{	<%		}	%>
[	<:		]	:>
# 	%:		##	%:%:

// 三标符
{	??<		}	??>
[	??(		]	??)
#	??=		\	??/
^	??'		|	??!
~	??-

//---------------------------
%:include <stdlib.h>
%:include <stdio.h>
%:include <iso646.h>

int main(int argc, char** argv)
??<
    if (argc > 1 and argv<:1:> not_eq NULL)
    <%
       printf("Hello%s\n", argv<:1:>);
    %>

    return EXIT_SUCCESS;
??>
```

<br>

#### _Bool 类型

C99 标准添加 ```_Bool``` 类型，表示布尔值；1 表示 ```true```，0 表示 ```false```。```_Bool``` 类型实际上是一种整数类型，仅占用 1 bit。

```c
#include <stdbool.h>

_Bool t = true;    // 1
bool f = false;    // 0
```

<br>

#### 浮点数值类型

`float` 类型必须至少能表示 6 位有效数字，且取值范围至少为 10<sup>-37</sup>～10<sup>+37</sup>。
`double` 双精度浮点类型，最小取值范围与 ```float``` 相同，最少能表示 10 位有效数字，占用大小 64 位，32 位表示指数部分，32 位表示非指数部分。```double``` 的值至少有 13 位有效数字。
当浮点值出现上溢（overflow）时，```printf``` 数值会显示为 ```inf``` 或 ```infinity```。下溢时（underflow），可能会发生精度丢失。关于浮点数的未定义行为，例如被 0 除，将返回 ```NaN```。

```c
// 1. 单精度浮点数
   	float num1 = 3.14f;
// 2. 双精度浮点数
   	double num2 = 3.1415;
// 3. 长浮点数, 至少与 double 精度相同
	long double num3 = 3.14L;
// 4. 有效浮点数声明
	3.14, .2, 4e16, .8e55, 99.
```

> *十六进制浮点数（C99）*

- 0x 作为十六进制前缀，用 p 和 P 代替 e 和 E，用 2 的幂代替 10 的幂（P 计数法）。
- 并非所有的编译器都支持 C99 的这一特性。

```c
double num = 0xa.1fp10;
/*
	a   ---- 10
	.1f ---- 1/16 + 15/256
	p10 ---- 2^10
*/
0xa.1fp10 = (10 + 1/16 + 15/256) * 2^10 = 10364.0
```

<br>

#### 枚举类型

枚举（enumerated type）由一组命名整数常量构成，它定义了一组已命名的整数标识符。所有的枚举类型都具有基础类型，基础类型可以使用枚举类型说明符显式指定，并且枚举项的值是其固定的基础类型；若未显式指定，则基础类型是枚举的兼容类型，该类型是 `char` 或标准或扩展的有符号或无符号整数类型。

枚举项关联常量值默认从 0 开始, 后面的成员依次递增；指定常量值时，顺次项依次递增。枚举项可以进行自增自减运算。

```c
enum DAY{
    saturday, // 0
    sunday = 0,
    monday,  // 1
    tuesday, // 2
    wednesday,
    thursday,
    friday
} workday;
```

对于具有固定基础类型的枚举，定义枚举常量值的整数常量表达式应可在该固定基础类型中表示。枚举常量的值不能超过其基础类型的范围，递增的成员枚举值不能溢出基础类型值的最大值。对于没有固定基础类型的枚举，定义枚举常量值的表达式应为整数常量表达式。

具有固定基础类型的枚举声明：

```c
enum Month : unsigned char
{
    Jan = 1, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec
}

enum E1: short;
enum E1{
    /* ... */
}
```

<br>

#### 结构类型

“结构声明” 用于为类型命名和指定一系列可具有不同类型的变量值（称为结构的 “成员” 或 “字段”），描述了一个组织布局。结构的声明有模板声明与类型声明，模板声明可以不含有标记。结构不能包含其自身的实例，但可以包含指向自身实例的指针。
当两个结构变量的类型相同，可以将一个结构赋值给另一个结构（与简单数据结构相同的行为，数组不可以）。

```c
#include <stdio.h>
struct book{
	const char * Name;
	int cost;
};
int main(void){
// 1. 外部声明
	struct book myBook;
	myBook.Name = "Ychao";
	myBook.cost = 99;
// 2. 块初始化
	struct book myBook2 = {
		"Ychao",99,
	};
// 3. 指定初始化器
	struct book mBook3 ={
		.Name = "Ychao",
		.cost = 99,
	};
// 4. 无标识符结构变量
	struct{
		const char * Name;
		int cost;
	} MBook = {
		.Name = "Ychao",
		.cost = 99,
	};
}
```

嵌套结构可以访问，就像它们是在文件范围级别声明的一样。

```c
// 嵌套结构
struct a{
    int x;
    struct b
    {
      int y;
    } var2;
} var1;
// 合法声明
struct a var3;
struct b var4;
/*-------- 匿名结构 -------*/
struct{
    int x;
    int y;
} mystruct;
```

具有多个命名成员的结构的最后一个成员可以是具有不完整的数组类型，这样的数组成员称为 **灵活数组** 成员。这样的结构（以及任何包含这种结构的联合）不应是结构的成员或数组的元素。在大多数情况下，将忽略灵活数组成员。`sizeof` 运算符在计算结构的大小时会忽略灵活数组成员。通过结构访问该灵活数组就好像该成员被替换为具有相同元素类型的最长的数组，该数组不会使结构体大于被访问的对象；该数组的偏移量应保持该灵活数组成员的偏移量，即使它与替换数组的偏移量不同。如果这个数组没有元素，则访问该数组元素或生成一个指针，行为未定义。

```c
struct Sample
{
    int len;
    int arr[];
};
struct Sample *Init(int len);
struct Sample *Init(int len)
{
    struct Sample *rt = calloc(1, sizeof(struct Sample) + sizeof(int [len]));
    rt->len = len;
    return rt;
}
int main(void)
{
    struct Sample *parr = Init(10);

    for (size_t i = 0; i < parr->len; i++)
        parr->arr[i] = i * i;

    printf("%d", parr->arr[parr->len - 1]);
    free(parr);
}

// 对于 struct Sample {int len; int arr[];};
struct Sample *s1 = malloc(sizeof(struct Sample) + 32);
struct Sample *s2 = malloc(sizeof(struct Sample) + 22);
// 假设 malloc 成功分配，s1 和 s2 的行为相当于
struct {int len; int arr[8];} *s1;
struct {int len; int arr[5];} *s2;
```

对于 `*s1 = *s2` 赋值，仅复制成员 `len`；如果任何数组元素位于结构的第一个 `sizeof(struct Sample)` 字节内，则它们被设置为不确定表示形式，该表示形式可能与源数组元素的表示形式副本一致，也可能不一致。

> *结构成员的填充与对齐:*

结构成员按其声明顺序进行存储，第一个成员的内存地址最低，最后一个成员的内存地址最高。

> *结构体的对齐步骤：*

结构体各成员对齐 ➡ 结构体总体对齐。

> *结构体对齐规则：*

第一个数据成员存放的地址为结构体变量偏移量为 0 的地址处。
其他结构体成员自身对齐时，存放的地址为 min { 有效对齐值为自身对齐值，对齐系数 } 的最小整数倍的地址处（其中，自身对齐值表示成员的自身大小；**对齐系数** 指宏定义 pack 指定值或机器位数）。
总体对齐时，结构体字节大小为 min { 所有成员中自身对齐值最大的，对齐系数 } 的整数倍。

> *对齐系数：*

对齐系数：宏 ```#pragma pack(N)``` 指定的值，N 一定是 2 的幂次方，1、2、4 等。
默认指定对齐值：32 位 Linux 主机的默认对齐值为 4；64 位为 8；AMR CPU 默认指定对齐值为 8。
`#pragma pack(N)` 每个特定平台上的编译器都有自己的默认 “对齐系数”（也叫对齐模数），可以自定义为编译器指定对齐系数。

> *对齐实例：*

 ```c
//此代码在 64 位 Linux 下编写，默认系数为 8
typedef struct _st_struct1
{
	char 	a;		// 1
	short   b;		// 2
	int		c;		// 4
} st_struct1;

printf("%ld\n",sizeof(st_struct1)); // size = 8
/* PS
1. a 是 char 类型，占 1 个字节，第一个数据成员，放在结构体变量偏移量为 0 的地址处
2. b 是 short 类型，占 2 个字节，b 的有效对齐值为 min{2, 8}=2；
   依次查看 2 的整数倍地址是否可以存放 2 个字节；
   	【2×0 = 0】 此地址处已经存放 a
   	【2×1 = 2】 此地址为空，可以将 b 存放在地址偏移量为 2 和 3 处.
3. c 是 int 类型，占 4 个字节，c 的有效对齐值为 4
   对齐到 4 的整数倍地址，即地址偏移量为 4 处.在内存中存放的位置为 4,5,6,7

4. 结构体总对齐字节大小为 min{4, 8}=4 的整数倍，此时内存中共占 8 个字节，正好是 4 的整数倍，所以 sizeof(st_struct1) = 8
*/

//此代码在 64 位 Linux 下编写
typedef struct _st_struct2
{
	char    a; // 地址位 0
	int     c; // 地址位 4
	short   b; // 地址位 8
} st_struct2;

printf("%ld\n",sizeof(st_struct2));	// size = 12
```

> *指定对齐值实例：*

使用 ```#pragma pack(N)``` 设置结构体边界时，最好使用一次 ```#pragma unpack()```， 否则在它之后定义的所有结构体都会按 N 字节对齐。

```c
//此代码在64位Linux下编写
#pragma pack(1)
/*
    对齐遵循始终寻址为 1 的倍数的地址，根据对齐规则，总体的结构体大小为 7
*/

typedef struct _st_struct3
{
 	char    a;  // 地址位 0
	int     c;  // 地址位 1
	short   b;  // 地址位 5
} st_struct3;

printf("%ld\n", sizeof(st_struct3)); // 7

#pragma unpack()
// 恢复系统默认的对齐特性
```

> *把结构内容保存在文件中：*

由于结构可以储存不同类型的信息，所以它是构建数据库的重要工具。数据库文件可以包含任意数量的此类数据对象。储存在一个结构中的整套信息被称为记录（record），单独的项被称为字段（field）。

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAXTITL 40
#define MAXAUTL 40
#define MAXBKS 10 /* 最大书籍数量 */
char *s_gets(char *st, int n);
struct book /* 建立 book 模板 */
{
    char title[MAXTITL];
    char author[MAXAUTL];
    float value;
};
int main(void)
{
    struct book library[MAXBKS]; /* 结构数组 */
    int count = 0;
    int index, filecount;
    FILE *pbooks;
    int size = sizeof(struct book);
// 1. fopen 二进制读写 a 模式
    if ((pbooks = fopen("book.dat", "a+b")) == NULL)
    {
        fputs("Can't open book.dat file\n", stderr);
        exit(1);
    }
// 2. 定位到文件开始
    rewind(pbooks);
// 3. 预先 fread 读取 book.dat 中的二进制数据 (library: 并输出)
    while (count < MAXBKS && fread(&library[count], size, 1, pbooks) == 1)
    {
    // 读取 book 并赋值给 library 数组中的结构体
        if (count == 0)
            // 打印当前 book 中的数据
            puts("Current contents of book.dat:");
        printf("%s by %s: $%.2f\n", library[count].title,
                library[count].author, library[count].value);
        count++;
    }
    filecount = count;
    // 验证当前 book 容量是否满
    if (count == MAXBKS)
    {
        fputs("The book.dat file is full.", stderr);
        exit(2);
    }
// 4. 输入数据并保存在 book.dat 中
    puts("Please add new book titles.");
    puts("Press [enter] at the start of a line to stop.");
    while (count < MAXBKS && s_gets(library[count].title, MAXTITL) != NULL && library[count].title[0] != '\0')
    {
        puts("Now enter the author.");
        s_gets(library[count].author, MAXAUTL);
        puts("Now enter the value.");
        scanf("%f", &library[count++].value);
	    while (getchar() != '\n')
            continue; /* 清理输入行 */
        if (count < MAXBKS)
            puts("Enter the next title.");
    }
// 5. 输入结束输出 book.dat 内容
    if (count > 0)
    {
        puts("Here is the list of your books:");
        for (index = 0; index < count; index++)
            printf("%s by %s: $%.2f\n", library[index].title,
                    library[index].author, library[index].value);
        fwrite(&library[filecount], size, count - filecount,
                pbooks);
    }
    else
        puts("No books? Too bad.\n");
    puts("Bye.\n");
    fclose(pbooks);
    return 0;
}
char *s_gets(char *st, int n)
{
    char *ret_val;
    char *find;
    ret_val = fgets(st, n, stdin);
    if (ret_val)
    {
        // 查找换行符
        find = strchr(st, '\n');
        // 如果地址不是 NULL，
        if (find)
            // 在此处放置一个空字符
            *find = '\0';
        else
            // 清理输入行
            while (getchar() != '\n')
                continue;
    }
    return ret_val;
}
```

<br>

#### 位域

除了结构或联合的成员的声明符外，结构声明符也可以是指定数目的位，称为 “位域”。其长度从字段名称的声明符到冒号。位域被解释为整型类型。

在 ANSI C 标准下，位字段的类型只能是 ```unsigned int```、```signed int``` 和 ```int``` 的一种（包括 ```char```、```short```），C99 和 C11 新增了 ```_Bool``` 类型的位字段。

位字段通过一个结构声明来建立，该结构声明为每个字段提供标签，并确定该字段的宽度。指定位域宽度的表达式应为整数常量表达式，其非负值不超过省略冒号和表达式时指定的类型对象的宽度。如果值为零，则声明中不应有声明符。


```c
struct{
	unsigned int first:4	// 表明该字段占用的 bit
	unsigned int second:2
	unsigned int third:8
} BitDomain[10]
/*
	first 位字段占用 4 个位
	三个位字段保存在一个 int 大小的内存单元中
	单个 BitDomain 元素只是用其中的 14 位
	数组对象使用了 （10 * sizeof int）大小的内存空间
 */
```

在 ANSI C 标准下，```sizeof``` 不能操作 `BitDomain` 的位字段，带有位字段的结构提供一种记录设置的方便途径，位字段的储存顺序自低位到高位方向。
ANSI C 标准规定，位域的宽度不能超过它所依附的数据类型的长度。通俗地讲，成员变量都是有类型的，这个类型限制了成员变量的最大长度。例如 `int` 位字段的最大长度不能超过 32 位。
为位字段赋值，不能超过字段可容纳的范围，例如 `BitDomain.first` 的大小为 4 bits，它的赋值范围为 0~2<sup>4</sup>-1。

```c
struct{
	unsigned int first : 4; // 表明该字段占用的 bit
	unsigned int second : 2;
	unsigned int third : 8;
} BitDomain = {
	.first = 0b0010,
	.second = 0b10,
	.third = 0b10100101
};
```

声明的总位数超过一个 ```unsigned int``` 的大小时，会自动溢出到下一个 ```unsigned int``` 类型的存储位置。
一个字段不允许跨越两个 ```unsigned int``` 之间的边界，编译器会自动移动跨界的字段，从而保持 ```unsigned int``` 之间的边界对齐。

```c
struct
{
    unsigned int first : 9;
    unsigned int second : 7;
    unsigned int may_straddle : 30;
    unsigned int last : 18;
} Bits;

printf("%zd", sizeof Bits); // 防止跨越，将为 12 B
```

> *位字段的填充和对齐*

- 使用一个宽度为 0 的未命名字段迫使下一个字段与下一个整数对齐。
- 当未命名字段宽度大于 0 时，会使两个字段之间产生一个不可访问的未命名位字段填充。

```c
struct {
	unsigned int field_0;   // 成员 field_0 没有限制，占用 4B;
	unsigned int field_1 : 1 ;
	unsigned int : 2 ;      // 2 位的填充
	unsigned int field_2 : 1 ;
	unsigned int : 0 ;      // 迫使下一个位字段与 int 边界对齐
	unsigned int field_3 : 1 ;
} BitDomain;
```

> *位域的存储*

- 当相邻成员的类型相同时，如果它们的位宽之和小于类型的 ```sizeof``` 大小，那么后面的成员紧邻前一个成员存储，直到不能容纳为止。
- 当它们的位宽之和大于类型的 ```sizeof``` 大小，那么后面的成员将从新的存储单元开始，其偏移量为类型大小的整数倍。
- 当相邻成员的类型相同时，成员之间会趋向紧凑排列；当不同时，顺位成员会进行偏移存储，并遵循结构体的对齐原则。

<br>

#### 联合类型

“联合声明” 指定一组变量值和（可选）一个命名联合的标记。变量值称为联合的 “成员”，并且可以具有不同的类型，能在同一个内存空间中储存不同的数据类型（不是同时储存）。联合的字节大小与成员中的最大字节数相同。使用联合未初始化的成员时的行为是不确定的（存在精度损失问题），应使用被初始化的成员对象。

联合可以具有位域，但不能包含不完整类型、类型 ```void``` 或函数类型。成员不可以是联合的实例，但可以声明联合类型的指针。


> *联合的存储*

- 与联合变量关联的存储是联合的最大成员所需的存储。
- 在存储较小的成员时，联合变量可以包含未使用的内存空间。
- 所有成员都存储在同一内存空间中并以相同的地址开始。每次将值赋给不同的成员时，都会重写存储的值。

> *联合的声明与初始化*

```c
// 声明
union sign
{
    int svar;
    unsigned uvar;
};	// size = 4

// 具有位域的联合
union{ 		
	unsigned int a:1;
	unsigned int b:4;
	int value;
} BitUnion;	// size = 4

// 初始化
union sign digit = {99}; 	// 默认初始化第一个元素
union sign digit2 = digit;	// 用另一个联合初始化
union sign val = {.uvar = 100};	// 指定初始化器
```

> *联合常嵌套在一个结构中*

```c
struct x
{
    int type_tag;
    union
    {
      int x;
      float y;
    };
};
```

<br>

#### 数组类型

“数组声明” 将命名数组并指定其元素的类型，其特征是元素的类型相同。数组类型的变量被视为指向数组首元的指针。
一般地，声明数组时需要指定数组的长度，初始化器初始化数组时，元素数目不能超过声明数组的长度；当初始化列表中的值少于数组元素个数时，编译器会把剩余的元素都初始化为类型默认值。C 数组不允许声明零长度数组，试探性声明的数组默认为具有一个数值为 0 的类型数组。

```c
// 1. 数组的声明包括数据类型与数组大小
	int IntArr[COUNT];
// 2. 初始化
	int Arr[5] = {0,1,2,3,4};           // 初始化器传统方式
	char Str[] = "This is a String";    // 自动确定长度
	int Arr[5] = {[2] = 2};             // 指定初始化器

//------ 试探性声明 ------
int[] a;  // 行为被暂认为是 a = {0}

// 3. 多维数组
int Arr[length0][length1];
int Arr[3][3][3][3];  //......多维数组
int Array[4][4] = {
	{1,2,3,4},
    {10,20,30,40},
    {100,200,300,400},
    {0,0,0,0}
}
int arr[2][3] = {1,2,3,4,5,6};  // 顺序初始化
```

`Arr [ 可选类型限定符/static ]` 只能出现在具有数组类型的函数参数的声明中，并且只能出现在最外层的数组类型派生中。

```c
int fun1(int a, int arr[static a]);
int fun2(int arr[restrict const static 5]);
```

如果数组标识符被声明为具有可变修改的类型，则它应该是一个普通的标识符，没有链接，且具有块作用域或函数原型作用域。如果标识符声明为具有静态或线程存储持续时间的对象，则它不应具有可变长度数组类型。

> *结构中的灵活数组成员（C99）*

- C99 新增了一个特性：灵活数组成员（flexible array member），该结构的最后一个成员具有一些特性。
- 该数组不会立即存在，使用这个灵活数组成员可以编写合适的代码，就好像它确实存在并具有所需数目的元素一样。

```c
struct flex{
	int count;
	double average;
	double scores[];
// 灵活数组成员, 要求不声明大小, 必须是最后一个, 结构中至少有一个非灵活数组成员
}
```

- 声明一个 ```struct flex``` 类型的结构变量时，不能用 ```flex.scores``` 做任何事，因为没有给这个数组预留存储空间。
- C99 意图声明一个指向 ```struct flex``` 的指针, 然后用 ```malloc``` 分配足够的空间, 以存储 ```struct flex``` 结构的常规内容与灵活数组成员所需的额外空间。
- 不可以将带有灵活数组的结构赋值给同类型结构变量。

```c
struct flex * pf;
pf = malloc(sizeof(struct flex) + 5 * sizeof(double));
// 分配一个内含 5 个 double 类型的数组的 flex
```

> 可变长度数组（VLA）

可变修改（VM）类型的所有有效声明都位于块作用域或函数原型作用域。使用 `thread_local`、`static`、`extern` 存储类说明符声明的数组对象不能具有可变长度数组类型（VLA）类型。使用 `static` 存储类说明符声明的对象可以具有 VM 类型（即指向 VLA 类型的指针）。最后，只能使用 VM 类型声明普通标识符，因此，具有 VM 类型的标识符不能是结构或联合的成员。

```c
extern int n;
int A[n];                       // invalid: file scope VLA
extern int (*p2)[n];            // invalid: file scope VM
int B[100];                     // valid: file scope but not VM
void fvla(int m, int C[m][m]);  // valid: VLA with prototype scope
void fvla(int m, int C[m][m])   // valid: adjusted to auto pointer to VLA
{
    typedef int VLA[m][m];      // valid: block scope typedef VLA
    struct tag
    {
        int (*y)[n];            // invalid: y not ordinary identifier
        int z[n];               // invalid: z not ordinary identifier
    };
    int D[m];                   // valid: auto VLA
    static int E[m];            // invalid: static block scope VLA
    extern int F[m];            // invalid: F has linkage and is VLA
    int(*s)[m];                 // valid: auto pointer to VLA
    extern int(*r)[m];          // invalid: r has linkage and points to VLA
    static int(*q)[m] = &B;     // valid: q is a static block pointer to VLA
}
```

未指定绑定的 `arr[*]` 可以在数组大小表达式中使用，但不能直接作为参数声明的抽象声明符嵌套序列的一部分：

```c
void f1(int [*]);                       // valid
void f2(int (*)[sizeof(int (*)[*])]);   // invalid
```


<br>

#### 指针类型

“指针声明” 可命名指针变量并指定该变量所指向的对象的类型。声明为指针的变量保留了一个内存地址；可以为任何基本、结构或联合类型、函数、数组和其他指针对象创建关联指针。

指针的默认类型是 ```void*```，声明为指向 ```void``` 的指针的变量可用于指向任何类型的对象。除 ```char*``` 类型外，```void``` 指针转换为其他类型的指针时需要类型强制转换。
指针类型可以是 ```const``` 和 / 或 ```volatile```，分别指定指针不能被程序本身修改，或指针可以被超出程序的控制范围的某进程以合法方式修改。

在同一 CPU 架构下，不同类型的指针变量所占用的存储单元是相同的，但存放数据的变量因数据的类型不同，所占用的存储空间长度也不同。指针描述了数据在内存中的位置，标示了一个占据存储空间的实体，其特点是可对存储数据的变量地址进行操作。
创建一个指针时，系统只分配了储存指针本身的内存，并未分配储存数据的内存。在使用指针之前，必须先用已分配的地址初始化它。之后才可以进行解引用的操作。

```c
// 【&】地址运算符用于获取类型的内存地址
// 【*】解引用运算符用于获取指针变量指向地址的值
int number = 10;
int *pN = &number;

int rt = *pN;	// 10

// ---- 不可解引用未初始化的指针 ----
int * pt;	// 未初始化的指针，其值不确定
*pt = 5; 	// ERROR：未定义行为
```

> *按字节寻址系统（如 PC）*

- 变量的名称、地址和变量的值之间关系密切，指针获取变量的机器码地址，变量保存数据的类型，数据的类型决定了值在内存中的字节大小，在该内存位置保存变量的值。
- 普通变量把值作为基本量，把地址作为通过 ```&``` 运算符获得的派生量；而指针变量把地址作为基本量，把值作为通过 ```*``` 运算符获得的派生量。
- 一元 `&` 地址运算符的操作数必须是函数指数符、`[]` 或一元 `*` 操作符的结果，也可以是指定非位域且未使用 `register` 存储类说明符声明的对象的值。一元 `*` 运算符的操作数应是指针类型。

> *指针与地址的关系*

- 指针的值是它所指向对象的地址。地址的表示方式依赖于计算机内部的硬件。
- 许多计算机（包括 PC 和 Mac）都是按字节编址，意思是内存中的每个字节都按顺序编号。
- 一个较大对象的地址（如 ```double``` 类型的变量）通常是该对象第一个字节的地址。
- 在指针前面使用 ```*``` 运算符可以得到该指针所指向对象的值。
- 指针加 1，指针的值递增它所指向类型的大小（以字节为单位）。

> *指针基本操作*

```c
#include <stdio.h>
int main(void)
{
	int urn[5] = { 100, 200, 300, 400, 500 };
	int* ptr1, * ptr2, * ptr3;
	ptr1 = urn;				// 把一个地址赋给指针
	ptr2 = &urn[2];			// 把一个地址赋给指针
	printf("pointer value, dereferenced pointer, pointer address : \n");
// 1. 解引用指针，以及获得指针的地址
	printf("ptr1 = %p, *ptr1 = %d, &ptr1 = %p\n", ptr1, *ptr1, &ptr1);
	printf("ptr2 = %p, *ptr2 = %d, &ptr2 = %p\n", ptr2, *ptr2, &ptr2);
// 2. 指针加法
	ptr3 = ptr1 + 4;
	printf("\nadding an int to a pointer:\n");
	printf("ptr1 + 4 = %p, *(ptr1 + 4) = %d\n", ptr1 + 4, *(ptr1 + 4));
// 3. 递增指针
	ptr1++;
	printf("\nvalues after ptr1++:\n");
	printf("ptr1 = %p, *ptr1 = %d, &ptr1 = %p\n", ptr1, *ptr1, &ptr1);
// 4. 递减指针
	ptr2--;
	printf("\nvalues after ptr2--:\n");
	printf("ptr2 = %p, *ptr2 = %d, &ptr2 = %p\n", ptr2, *ptr2, &ptr2);
	--ptr1; // 恢复为初始值
	++ptr2; // 恢复为初始值
	printf("\nPointers reset to original values:\n");
	printf("ptr1 = %p, ptr2 = %p\n", ptr1, ptr2);
// 5. 一个指针减去另一个指针
	printf("\nsubtracting one pointer from another:\n");
	printf("ptr2 = %p, ptr1 = %p, ptr2 - ptr1 = %td\n", ptr2, ptr1, ptr2 - ptr1);
// 6. 一个指针减去一个整数
	printf("\nsubtracting an int from a pointer:\n");
	printf("ptr3 = %p, ptr3 - 2 = %p\n", ptr3, ptr3 - 2);

	return 0;
}
/*
	pointer value, dereferenced pointer, pointer address :
	ptr1 = 010FFC9C, *ptr1 = 100, &ptr1 = 010FFC90
	ptr2 = 010FFCA4, *ptr2 = 300, &ptr2 = 010FFC84

	adding an int to a pointer:
	ptr1 + 4 = 010FFCAC, *(ptr1 + 4) = 500

	values after ptr1++:
	ptr1 = 010FFCA0, *ptr1 = 200, &ptr1 = 010FFC90

	values after ptr2--:
	ptr2 = 010FFCA0, *ptr2 = 200, &ptr2 = 010FFC84

	Pointers reset to original values:
	ptr1 = 010FFC9C, ptr2 = 010FFCA4

	subtracting one pointer from another:
	ptr2 = 010FFCA4, ptr1 = 010FFC9C, ptr2 - ptr1 = 2

	subtracting an int from a pointer:
	ptr3 = 010FFCAC, ptr3 - 2 = 010FFCA4
*/
```

> *指向结构或联合的指针*

- 像指向数组的指针比数组本身更容易操控（如, 排序问题），指向结构的指针通常比结构本身更容易操控，在函数中传递结构指针比传递结构本身效率更高。对于指向结构或联合的指针，使用 `->` 访问指向对象的成员。
- 在一些早期的 C 实现中，结构不能作为参数传递给函数，但是可以传递指向结构的指针。
- 一些用于表示数据的结构中包含指向其他结构的指针。

```c
struct book{
	int cost;
} bp;
struct book * pbook = &bp;
pbook->cost = 99;		// -> 访问指针关联结构成员，等价于 bp.cost

pbook->cost = (*pbook).cost = bp.cost
```

> *结构中的字符数组和字符指针*

```c
// 1. 字符串数组作为成员
struct name{
	char first[LEN];
	char last[LEN];
};
// 2. 字符指针作为成员
struct pname{
	char * first;
	char * last;
};
struct name veep = {"Talia", "Summers"};
struct pname treas = {"Brad", "Fallingjaw"};
```

- name 结构将两个固定大小的数组用于储存姓名, 字符串储存在结构内部。
- pname 结构保存了两个指针变量, 它使用的是储存在别处的字符串 (字符串常量或数组中的字符串)。
- 由于 pname 中的指针是未初始化的变量, 因此地址可以是任何值, 为其赋值可能会修改掉原有的程序数据, 直接赋值操作可能会导致程序的崩溃。
- 因此，如果要用结构储存字符串，用字符数组作为成员比较保险。用指向 ```char``` 的指针也行，但是误用会导致严重的问题，可以预先使用 ```malloc``` 分配空闲内存。

> *指针和数组的关系*

- 数组标识符实质上指向了数组首元素的地址。数组内相邻元素地址对应关系：```&arr[n+1] = &arr[n]+1```。
- 指针类型加 1 表示增加一个存储单元，对于组数表示下一个元素地址，而不是表示下一个字节地址，因此这就要求指针与指向对象类型相对应（例如，`pti` 的类型是 ```short``` 类型，```pti + 1```，其值每次递增 2 字节）。
- 在数组中，定义 ```arr[n]``` 的含义是 ```*(arr + n)``` （其中 ```arr = &arr[0]```）。

```c
int arr[10] = {99};
if (arr == &arr[0])
{
	// arr 值等于 &arr[0]
	printf("\n%d",*arr);	// 99
}

int *pArr = arr;
// 等价于
int *pArr = &arr[0];
```

> *指针表示法与数组表示法*

- 处理数组的函数实际上用指针作为参数，但是在编写这样的函数时，可以选择是使用数组表示法还是指针表示法。
- 对于 ```int Arr[Size]``` 数组，```*(Arr+i)``` 与 ```Arr[i]``` 等价，但指针表示法（尤其与增量运算符一起使用时）更接近于机器语言，编译时能够生成效率更高的代码。

> *指向多维数组的指针*


```c
int main(void) {
	int(Arr[2])[3] = {		// 二维数组
		{1,2,3},
		{2,3,4}
	};
	int Arr1[] = { 1,2,3,4 };

	int* pr[2] = { Arr1, &Arr1[1] };	// pr 是一个包含两个指针元素的数组

	int(*pr1)[3] = Arr;				// pr1 指向一个内含两个 int 类型值的数组

	for (size_t i = 0; i < 2; i++)
	{
		printf("%p\n", pr1[i]);
		printf("%p\n", Arr[i]);
	}
}

// 对于 ```Arr[n][m][i][l]...``` 数组

int Arr[a][b][c][d];
int(*pr)[b][c][d] = Arr;

Arr[0][0][0][0] = ****pr = pr[0][0][0][0];
```

<br>

#### 字符串与字符串字面量

字符串字面量是用双引号括起来的零个或多个多字节字符的序列，用于表示以 `\0` 结尾的字符串的字符序列。UTF-8 字符串字面量以 `u8` 为前缀，`wchar_t` 字符串字面量以 `L` 为前缀，UTF-16 字符串字面量以 `u` 为前缀，UTF-32 字符串字面量以 `U` 为前缀。`wchar_t`、`char16_t`、`char32_t` 字符串字面量统称为宽字符串字面量。

```c
char8_t* s8 = u8"Hello";
char* s = "Hello";
wchar_t * ws = L"Hello";
char16_t * s16 = u"Hello"; 
char32_t * s32 = U"Hello"; 
```

如果相邻字符串文字标记的序列包括带前缀的字符串文字标记，则带前缀的标记应全部具有相同的前缀（或没有前缀）。

```c
"a" "b" L"c"
"a" L"b" "c"
L"a" "b" L"c"
L"a" L"b" L"c"
// 等同于
L"abc"
```

> *字符串字面量的类型*

- 字符串字面量是具有 ```char``` 的类型数组（宽字符字符串是具有 ```wchar_t```  的类型数组）。
- 文本字符串的字符将按顺序存储在连续内存位置，```null``` 字符（```\0```）自动追加到每个字符串并标记该字符串的末尾。
- **编译器无法在两个不同的地址存储两个相同的字符串**，```/GF```（消除重复的字符串，编译器优化策略）强制编译器将相同字符串的单个副本置于可执行文件中。

```c
char *str1 = "Hello";
char *str2 = "Hello";

int main(void)
{
	printf("pStr1: %p\n",str1);
	printf("pStr2: %p\n",str2);
}
/*
pStr1: 0000000000404000
pStr2: 0000000000404000
*/
```

若要形成占用多行的字符串文本，则可以将两个字符串串联起来。为此，请键入反斜杠。

```c
/* 串联一 */
"Long strings can be bro\
ken into two or more pieces."
  >>> 等价于
"Long strings can be broken into two or more pieces."

/* 串联二 */
char *string = "This is the first half of the string, "
               "this is the second half";
```

ANSI C 兼容性要求编译器在串联后接受字符串中最多 509 个字符。
Microsoft C 允许的字符串的最大长度约为 2048 个字节，若字符串由多个双引号部分构成，对于串联的每个行，预处理器会将一个额外的字节添加到总字节数。若使用行继续符（```\```）代替双引号，则预处理器不会为每个行添加一个额外字符。

> *格式转换说明符*

```powershell
%a，%A      浮点数、十六进制数和p，P计数法（C99，C11）
%c          单个字符
%d          有符号十进制数
%e，%E      浮点数，e计数法
%f          浮点数，十进制
%g，%G      自动选择%f 或 %e
%i          有符号十进制整数
%o          无符号八进制整数
%p          指针
%s          字符串
%u          无符号十进制整数
%x，%X      无符号十六进制整数，使用十六进制数 0f，0F
%%          打印一个百分数符号 %
```

格式字符串中的转换说明一定要与后面的每个项相匹配，若忘记这个基本要求会导致严重的后果。如果只打印短语或句子，就不需要使用任何转换说明。

> *转换说明修饰符*

  在 ```%``` 和转换字符之间插入修饰符可修饰基本的转换说明。

```c
标记        -、+、空格、#、0，可以不使用标记或使用多个标记
数字        表示最小字段宽度

.数字       精度：%e、%E、%f 转换表示小数位位数
                %g、%G 转换表示有效数字的最大位数
                %s 转换表示待打印字符的最大数量
                整型转换，表示待打印数字的最小位数
                只使用 . 表示其后紧随一个0, %.f 等同于 %.0f;

h           与整型转换说明一起使用，表示 (unsigned) short int
hh          与整型转换说明一起使用，表示 signed char 或 unsigned char
j           与整型，表示 intmax_t 和 uintmax_t 类型
l           与整型，表示 (unsigned) long int
ll          与整型，表式 (unsigned) long long int
L           与浮点型，表示 long double
t           与整型，表示 ptrdiff_t (两个指针差值)
z           与整型，表示 size_t 类型，为 sizeof 返回类型
```

```%zd```  返回的类型规定为无符号整数，不同系统中，可能使用 ```%u```，```%lu```，```%llu```。

> *printf 中的标记*
 
 ```c
-       待打印项左对齐
+       显示数值符号，符号为正显示 +，符号为负显示 -
空格    有符号值若为正，在值前面显示前导空格；负则显示减号；+ 覆盖标记空格

%o          显示八进制前缀, 结果以 0 开始
%#x/%#X     显示十六进制前缀, 结果以 0x、0X 开始
%#g/%#G	    防止结果后面的 0 被删除(近似数)
0N          N 数值类型，用前导 0 代替空格填充字段宽度
整数        出现 - 左对齐标记或者指定精度，则忽略前导 0
```

> *格式输出案例*

- 字符宽度

```c
#include <stdio.h>
#define PAGES 959
int main(void)
{
    printf("*%d*\n", PAGES);
    printf("*%2d*\n", PAGES);
    printf("*%10d*\n", PAGES);
    printf("*%-10d*\n", PAGES);

    return 0;
}
/*
    *959*
    *959*
    *       959*
    *959       *
*/
```

- 一些浮点型修饰符的组合

```c
#include <stdio.h>
int main(void)
{
    const double RENT = 3852.99; // const变量
    printf("*%f*\n", RENT);
    printf("*%e*\n", RENT);
    printf("*%4.2f*\n", RENT);
    printf("*%3.1f*\n", RENT);
    printf("*%10.3f*\n", RENT);
    printf("*%10.3E*\n", RENT);
    printf("*%+4.2f*\n", RENT);
    printf("*%010.2f*\n", RENT);
    return 0;
}
/*
    *3852.990000*
    *3.852990e+03*
    *3852.99*
    *3853.0*
    *  3852.990*
    * 3.853E+03*
    *+3852.99*
    *0003852.99*
 */
```

- 一些格式标记

```c
#include <stdio.h>
int main(void)
{
    printf("%x %X %#x\n", 31, 31, 31);
    printf("**%d**% d**% d**%+d**\n", 42, 42, -42, 42);
    printf("**%5d**%5.3d**%05d**%05.3d**\n", 6, 6, 6, 6);
    return 0;
}
/*
    1f 1F 0x1f
    **42** 42**-42**+42**
    **    6**  006**00006**  006**
*/
```

- 字符串格式

```c
#include <stdio.h>
#define BLURB "Authentic imitation!"
int main(void)
{
	// 最小2宽度
    printf("[%2s]\n", BLURB);
	// 最小24宽度
    printf("[%24s]\n", BLURB);
    // 最小24宽度, 5字符宽度
	printf("[%24.5s]\n", BLURB);
	// 左对齐,最小24宽度,5字符宽度
    printf("[%-24.5s]\n", BLURB);
    return 0;
}
/*
    [Authentic imitation!]
    [    Authentic imitation!]
    [                   Authe]
    [Authe                   ]
*/
```

> *转换说明参数传递机制*

参数传递机制因实现而异
- 就 ```printf("%ld %ld %ld %ld\n", n1, n2, n3, n4)```，对于 ```float``` n1、n2，系统仍会将 ```float (4B)``` 转换成 ```double (8B)``` 储存在 stack 中，n3、n4 紧随压入栈中。
- ```%ld``` 转换说明，取参数读取栈中数据应读取 4 字节的 ```long``` 类型，但将 n1 的前半部分作为第一个参数，后半部分作为第二个参数。因此出现 ```printf``` 读错了字节导致转换说明出错。

```c
float n1= 1.0f, n2 = 2.0f;
long  n3 = 3L, n4 = 4L;
printf("%ld %ld %ld %ld\n",n1, n2, n3, n4); // 0 0 3 4
```

>---
### 类型限定符

`const` 类型限定符将对象声明为不可修改。
`volatile` 类型限定符声明一个项，该项的值可由超出该项所在的程序控制范围的某个项（如并发执行的线程）合理更改（易变的）。
`restrict` 用于限定指针，出于优化策略，表明该指针是访问数据对象的唯一且初始的方式。但不限定其指向的内容。
`_Atomic` 声明限定原子类型。

如果数组类型的规范包含任何类型限定符，则数组和元素类型都是限定的。如果函数类型的规范包含任何类型限定符，则行为是未定义的。

```c
// 合法声明
typedef volatile int VI;
const int ci;
// 非法声明
typedef int *i, volatile *vi;
float f, const cf;
```

<br>

#### const

```c
const int ci;
const int carri[size];
void Func(const int);	// 限定函数形参
```

`const` 指针声明时的注意点：

```c
// * 在 const 后，限定指针指向的值
int const *p_ci;        // 指向整型常量的指针
const int *p_ci;        // 指向整型常量的指针
// * 在 const 前，限定指针
int* const cp_i;        // 指向整型的常量指针
// const 双限定
const int* const cp_ci; // 指向整型常量的常量指针
```

如果通过非 `const` 限定类型的左值修改使用 `const` 限定类型定义的对象，行为未定义。
`const` 与非 `const` 指针间的转换：指向非 ```const``` 类型的指针能隐式转换成指向同一或兼容类型的 ```const``` 限定版本的指针。能用类型强制转换进行逆向转换。

```c
int* p = 0;
const int* cp = p;  // 添加限定符，int 隐式转换到 const int
p = cp;             // ERROR：舍弃限定符（const int 到 int）
p = (int*)cp;       // 强制转换
```

指向指向 ```T``` 指针的指针不可转换为指向指向 ```const T``` 指针的指针；对于要兼容的二个类型，其限定必须等同。

```c
char *p = 0;
const char **cpp = &p; 	// ERROR： char* 与 const char* 不是兼容类型
char * const *pcp = &p; // 添加限定符（ char * 到 char *const ）
```

> *`const` 两种声明方式*

```c
void Func(char* const c);
// 等价于
void Func(char c[const]);
```

<br>

#### volatile

`volatile` 类型说明符可用于提供对特定内存位置的可靠访问。如果尝试通过使用具有非易失性限定类型的左值来引用使用易失性限定类型定义的对象，则该行为是未定义的。

具有易失性限定类型的对象可能会以实现未知的方式进行修改，或者具有其他未知的副作用。因此，任何提及此类对象的表达都应严格按照抽象机器的规则进行求值。

`volatile` 限定告知计算机，代理（不是变量所在的程序）可以修改该变量的值，一般用于硬件地址以及在其他程序或同时运行的线程中共享数据。

```c
volatile int vol;
void f(double x[volatile], const double y[volatile]);
void f(double * volatile x, const double * volatile y);
```

一个非 ```volatile``` 值到 ```volatile``` 值的转换是无效果的。欲使用 ```volatile``` 语义访问非 ```volatile``` 对象，必须先将其地址转换成指向 ```volatile``` 类型的指针，再通过该指针访问该对象。

```c
int vol;
// 转变为易变对象
volatile int* pVol = &vol;
```

任何通过非 ```volatile``` 左值结果，对拥有 ```volatile``` 限定类型的对象尝试读或写会导致未定义行为。

```c
volatile int n = 1; // volatile 限定类型
int* p = (int*)&n;
int val = *p; // 未定义行为
```

`volatile` 限定的结构体或联合体类型，其成员会自动获取其所属类型的限定。以 ```volatile``` 类型限定符声明数组类型（通过使用 ```typedef``` ），数组类型无 ```volatile``` 限定，但其元素成员有。
`const volatile` 限定：一个项可以同时是 ```const``` 和 ```volatile```，在这种情况下，此项不能被它自己的程序以合法方式修改，但能被一些异步进程修改（例如系统时钟，硬件修改）。
 
 ```c
volatile const int loc;
const volatile int * ploc;
```

> *`volatile` 禁用优化策略*

```c
val1 = x;
//do...不使用 x 的代码
val2 = x;
```

一些编译器会将 x 的值保存在寄存器，当 val2 使用 x 时，并不会从原始内存位置的读取 x 的值，会从寄存器上读取 x，目的是为了程序优化（此过程称为高速缓存 caching）。
但如果其他的代理在 val1 与 val2 改变了 x 的值，编译器并不知道这类事发生，安全起见，使用 ```volatile``` 限定的变量不会采用高速缓存的方式读取 x 的值。

<br>

#### restrict

```restrict``` 关键字允许编译器优化某部分代码以更好地支持计算，只能用于指针，表明该指针是访问数据对象的唯一且初始的方式。它限定指针，而不是它指向的内容。若对标记为 ```restrict``` 的指针使用了别名，则结果是不确定的。通过 `register` 限定指针访问的对象与该指针具有特殊关联，要求对该对象的所有访问都直接或间接使用该指针的值。

 ```c
// 用于函数形参，限定仅能从 restrict 指针变量访问数据
void test(int* restrict first, int* restrict second, int* val)
{
    *first += *val;
    *second += *val;
}
// 将 union 成员标记为 restrict 告诉编译器在任何作用域中只有 z.x 或 z.y 可被访问
union z
{
    int* restrict x;
    double* restrict y;
};
```

文件作用域的 ```restrict``` 限定指针必须在程序运行期间指向单个数组的元素。文件作用域 ```restrict``` 指针对访问动态分配的全局数组很有用。

```c
/* 作用于文件作用域 */
float * restrict a, * restrict b;
float c[100];

int init(int n) {
   float * t = malloc(2*n*sizeof(float));
   a = t;      // a 引用前半
   b = t + n;  // b 引用后半
}
// 编译器可以从 restrict 限定符推断 a 、 b 和 c 都没有潜在的别名引用
// 如果使用 a，b，c 中的一个访问对象，并且该对象在程序中的任何未知被修改，则
// 永远不会使用另外两个中的任何一个来访问它。
```

以下示例中的函数参数声明：

```c
void f(int n, int * restrict p, int * restrict q){
    while(n--)
        *p++ = *q++;
}
// 每次执行函数期间，通过其中一个指针访问对象时，则不会同时通过另一个指针参数访问该对象

void g(void){
    extern int d[100];
    f(50, d+50, d);  // valid
    f(50, d+1, d);   // undefined behavior
}
// 第二次调用中 d[1] 到 d[49] 中的每个元素都通过 p 和 q 访问，如果 p 和 q 数组是不相交的数组，则行为是实现定义的。
```

`restrict` 指针之间赋值的规则不区分函数调用和等效的嵌套块。除了一个例外，只有在嵌套块中声明的受限指针之间的 “外部到内部” 赋值才定义了行为。

```c
{
    int * restrict p1;
    int * restrict q1;
    p1 = q1; // undefined behavior
    {
        int * restrict p2 = p1; // valid
        int * restrict q2 = q1; // valid
        p1 = q2; // undefined behavior
        p2 = q2; // undefined behavior
    }
}
```


> *`restrict` 优化策略*
        
```c
int* restrict restar = (int *) malloc(10 * sizeof(int));
// 指针 restar 是访问由 malloc() 所分配内存的唯一且初始化的方式

restar[0] += 5;
restar[0] += 3;
// 由于 restar 唯一指定访问方式, 编译器处于优化考虑, 会采用 restar[0] += 8 进行替换

//------------------- 一般模式 -------------------
int ar[10];
int * par = ar;

par[0] += 5;
ar[0] *= 2;
par[0] += 3;
/*
  par 未使用 restrict 限定, 编译器就必须假设最坏的方式(其他标识符可能已经改变该地址的值),
不能用 par[0] += 8 进行替换
*/
```

> *`restrict` 的两种声明方式*

```c
void Func(int* restrict n);
// 等价于
void Func(int n[restrict]);
```

<br>

#### _Atomic

```c
    _Atomic ( type-name )
```

如果实现不支持原子类型，则不应使用原子类型说明符。原子类型说明符中的类型名称不应引用数组类型、函数类型、原子类型或限定类型。

并发程序设计把程序执行分成可以同时执行的多个线程, 因此如何管理访问相同数据的不同线程，C11 通过包含可选的头文件 ```stdatomic.h```，提供了一些可选的（不是必须实现的）管理方法。

> *`_Atomic` 用作类型说明符或类型限定符*

- 当 ```_Atomic``` 用作类型说明符，指代新的原子类型；当用作类型限定符，指代类型名的原子版本。在此范围中，它可以与 ```const```、```volatile``` 及 ```restrict``` 混合使用（尽管不同于其他限定符，类型名的原子版本可能拥有不同的大小、对齐以及对象表示）。
- 若编译器定义了宏常量 ```__STDC_NO_ATOMICS__``` ，则不提供关键词 ```_Atomic```。

```c
    _Atomic const int *p1;  // p 是指向 _Atomic const int 的指针
    const atomic_int *p2;   // 同上
    const _Atomic(int) *p3; // 同上
```

> *原子类型解释说明：*

- 原子类型的对象是仅有的免除数据竞争的对象，即它们可以被两个线程共时修改，或先被一个修改再被另一个读取。
- 每个原子对象都拥有关联于其自身的修改顺序，即对该对象的完整修改顺序（若从某个线程的视角来看，对于某原子对象 M 的修改 A 发生先于同一原子对象 M 的修改 B，则在 M 的修改顺序中 A 的出现先于 B）。
- 不同线程可能会观测到不同原子对象有相异的修改顺序，对于所有原子运算，保证有四种连贯：
  - **写写连贯**：若原子对象 M 的修改操作 A 先发生于 M 的修改操作 B，则 M 的修改顺序中 A 出现早于 B。
  - **读读连贯**：若原子对象 M 的值计算 A 先发生于 M 的值计算 B ，且从 M 上的副作用 X 求得 A 值，则 B 所计算得的值要么是 X 所存储的值，要么是 M 上的副效应 Y 所存储的值，其中 Y 在 M 的修改顺序中出现后于 X。
  - **读写连贯**：若原子对象 M 的值计算 A 先发生于 M 上的操作 B ，则从 M 上的副效应 X 求得 A 值，这里 X 在 M 的修改顺序中出现先于 B 。
  - **写读连贯**：若在原子对象 M 上的副效应 X 先发生于 M 的值计算 B ，则求值 B 从 X，或从在 M 的修改顺序中出现后于 X 的副效应 Y 求得其值。

- 原子属性仅对左值表达式有意义。左值到右值转换（模仿从原子区域到 CPU 寄存器的内存读取）会把原子性及其他限定符剥去。

```c
#include <stdio.h>
#include <threads.h>
#include <stdatomic.h>

atomic_int acnt;
int cnt;

int f(void* thr_data)
{
    for(int n = 0; n < 1000; ++n) {
        ++cnt;
        ++acnt;
        // 对于此例，宽松内存顺序是足够的，例如
        // atomic_fetch_add_explicit(&acnt, 1, memory_order_relaxed);
    }
    return 0;
}

int main(void)
{
    thrd_t thr[10];
    for(int n = 0; n < 10; ++n)
        thrd_create(&thr[n], f, NULL);
    for(int n = 0; n < 10; ++n)
        thrd_join(thr[n], NULL);

    printf("The atomic counter is %u\n", acnt);
    printf("The non-atomic counter is %u\n", cnt);
}
/* 可能的输出
	The atomic counter is 10000
	The non-atomic counter is 8644
*/
```

<br>

#### 限定声明的结构成员

```c
struct s { int i; const int ci; };
struct s s;
const struct s cs;
volatile s vs;
```

各种成员具有以下类型：

```c
s.i         int
s.ci        const int
cs.i        const int
cs.ci       const int
vs.i        volatile int
vs.ci       volatile const int
```

>---
### 复杂声明解释

#### 抽象声明符

- 抽象声明符是没有标识符的声明符，由一个或多个指针、数组或函数修饰符组成。
- 指针修饰符 【```*```】 始终在声明符中的标识符前面。
- 数组 【```[ ]```】 和函数 【```()```】 修饰符紧跟在标识符后面。
- 抽象声明符常表示函数原型的形参或返回类型。

```c
int             int 整型
int *           指针声明
int *[3]        指向 int 的 3 个指针组成的数组
int (*)[5]      指向 5 个 int 类型数组的指针
int (*)[*]      指向未指定数目的 int 类型的可变长度数组的指针
int *()         一个不带参数的函数，返回一个指向 int 的指针
int (*)(void)   指向不带参数并返回 int 的函数的指针
int (*const []) (unsigned int, ...)  
指向函数的未指定数目的常量指针的数组，每个函数都有一个参数，其类型是 unsigned int 以及未指定数
目的其他参数，并返回一个 int
```

<br>

#### 解释复杂的声明符

复杂声明符是由多个数组、指针或函数修饰符限定的标识，可以将数组、指针和函数修饰符的各种组合应用于单个标识符。通常 ```typedef``` 可用来简化声明。在解释复杂声明符时，方括号和圆括号（即，标识符右侧的修饰符）优先于星号（即，标识符左侧的修饰符）。方括号和圆括号具有相同的优先级并且都是从左到右关联。

> *解释复杂声明符的一般步骤*

1. 从标识符开始并直接查找方括号或圆括号（如果有）的右侧。
2. 解释这些方括号或圆括号，然后查找星号的左侧。
3. 如果在任何阶段遇到一个右圆括号，请返回并将规则 1 和 2 应用于圆括号内的所有内容。
4. 应用类型说明符。

> *解释复杂声明符*

```C
char *( *(*var)() )[10];
 ^   ^  ^ ^ ^   ^    ^
 7   6  4 2 1   3    5

/*
  1. 标识符 var 声明为
  2. 指向以下内容的指针
  3. 返回以下内容的函数
  4. 指向以下内容的指针
  5. 包含 10 个元素的数组，这些元素分别为
  6. 指向以下内容的指针
  7. char 值

TOTAL: 标识符 var 声明为 (指向 (返回 (指向 (包含 10 个元素的数组，
这些元素分别为 (指向 (char 值) 的指针) ) 的指针) 的函数) 的指针)
*/
```

<br>

#### 复杂的声明符举例

```c
int *var[5];		/* 声明为指向 int 的指针数组 */
int (*var)[5];		/* 声明为指向 int 数组的指针 */
long *var(long, long);		/* 声明为返回 long 指针的函数 */
long (*var)(long, long);	/* 声明为指向返回 long 的函数指针 */

struct both{
    int a;
    char b;
} (*var[5])(struct both, struct both);
/* 声明为指向返回结构 both 的函数的指针数组 */

struct both *var[5](struct both, struct both);
/* 非法：声明函数数组 */

unsigned int* (*const *name[5][10])(void);
/* 声明为指向常量指针的指针的二维数组，这些常量指针指向返回 unsigned int* 的函数 */

double (*var(double(*)[3]))[3];
/* 声明为返回指向包含 3 个 double 数组指针的函数，其形参是指向包含 3 个 double 数组的指针 */

union sign{
     int x;
     unsigned y;
} **var[5][5];
/* 声明为指向指针的指针二维数组，这些指针指向具有两个成员的联合的指针 */

union sign *(*var[5])[5];
/* 声明为一个五元素指针数组，数组元素指向联合的五元素指针数组 */
```

<br>

#### 不完整类型

**不完整类型** 是一种用于描述标识符但缺少确定该标识符的大小所需的信息的类型。不完整类型不能用于定义变量，但是用不完全类型定义指针或者引用是合法的。
“不完整类型” 可以是：尚未指定其成员的结构类型、联合类型或未指定其维度的数组类型。
在使用不完整类型前必须确保该类型被完成定义。```void``` 类型是无法完成的不完整类型，特殊用于函数的参数与函数返回等。

> *不完整类型应用于*

- 指向不完整类型的指针；
- 不完整类型的引用；
- 不完整类型的 ```typedef``` 名称；
- 返回不完整类型的函数和函数原型的抽象声明类型。

<br>

#### 复合文本

**复合文字** 为那些存储类型说明符的名称提供初始值设定项支持。类型名称应指定完整的对象类型或未知大小的数组，但不能指定可变长度的数组类型。复合文本与文件范围或块范围相关联。

```c
SC? typeof(T) Identifier = { IL };
// SC 存储类说明符可能为空
// IL 是一个初始值设定项列表
```

对于与函数原型范围关联的复合文本，类型被确定在块作用域中，并且不会创建任何对象；若它是复合文本常量，则在翻译时计算；若不是复合文本常量，则既不会计算整个复合文本，也不会计算任何初始值设定项。因为复合文本是匿名的，所以不能先创建然后再使用它，必须在创建的同时使用它。

对于数组，复合文本类似数组初始化列表，前面是用括号括起来的类型名。

```c
int arr[2] = {1,2};           // 常规数组声明
int *arr2 = (int[2]){1,2};    // 复合字面量
// (int[2])  即为数组复合字面量的类型名(匿名)
// 也可省略数组大小     即 (int[]){1,2}
// 多维复合字面量: (int[2][1]){{1},{2}}
```

对于结构或联合，带有名称的初始值设定项可以与复合文本组合，使用复合文本创建的结构对象可以传递给函数。

```c
struct S
{
    int value;
    int id;
};
struct S s1 = (struct S){.id = 10010, .value = 10};
struct S s2 = (struct S){10, 10086};

struct S* ps1 = &(struct S){.id = 1, .value = 100};
```

类型限定符修饰的复合文本。

```c
void func(volatile int arr[], const register char *strs);
int main(void)
{
    func((volatile int[]){1, 2, 3, 4, 5, 6}, (const char *){"Hello World!"});
}
```

复合文本一般是提供只临时需要的值的一种手段。复合字面量具有块作用域，这意味着一旦离开定义复合字面量的块，程序将无法保证该字面量是否存在。

>---
### 类型推断

推断类型的声明应包含 `auto` 关键字，对于作为对象的此类声明，初始化声明应具有 `direct-declarator = assignment-expression` 的形式。声明对象的推断类型是左值、数组到指针或函数到指针转换之后的赋值表达式的类型，并由额外的限定符限定。

```c
auto p = (struct {int x; } *)0;  // p 是 struct {int x;} * 
```

`auto` 与 `alignas` 组合： 

```c
auto alignas (struct s *) x = 0;   // 实现定义的行为
```

以下在文件范围定义：

```c
static auto a = 3.5;
auto p = &a;
// 解释为
static double a = 3.5;
double * p = &a;
```

推断类型的标识符的作用域仅在初始值设定项结束之后开始，因此赋值表达式不能使用标识符来引用声明的对象或函数。在初始值设定项中使用标识符是无效的，即使外部作用域中存在具有相同名称的实体也是如此。

```c
{
    double a = 7;
    double b = 9;
    {
        double b = b * b;   // undefined, uses uninitialized
                            // variable without address
        printf("%g\n", a);  // valid, uses "a" from outer scope, prints 7
        auto a = a * a;     // invalid, "a" from outer scope is not
                            // visible during initialization
    }
    {
        auto b = a * a;     // valid, uses "a" from outer scope
        auto a = b;         // valid, "a" from outer scope not visible now
        // ...
        printf("%g\n", a);  // valid, uses "a" from inner scope, prints 49
    }
    // ...
}
```

类型推断可用于捕获对类型泛型函数的调用的类型。它确保使用与参数 x 相同的类型。如果将 y 的类型显式指定为与 x 不同的类型，则不会强制执行不匹配的诊断。

```c
#include <tgmath.h>
auto y = cos(x);
```

具有推断类型的对象的定义在允许初始值设定项语法的所有上下文中都有效。特别是，它们可用于确保 for-loop 控制表达式的类型安全性。

```c
for (auto i = j; i < 2*j; ++i) {
    // ...
}
// 无论 j 类型的整数秩或符号，i 将具有 j 类型的非原子非限定版本
```

>---
### 类型初始化

#### 初始化标量类型

> *初始化任何类型的变量，遵循的下列规则*

- 在文件范围级别声明的变量可初始化，未显示初始化的外部级别变量将自动初始化为 0，指针类型分配为 ```null``` 指针（其值为 0）。
- 常数表达式可用于初始化使用 ```static``` 声明的任何全局变量。
- 使用 ```auto``` 或 ```register``` 存储类说明符声明的变量在每次执行控制传递给声明它们的块时进行初始化。
- 在 ```auto``` 或 ```register``` 变量的声明中省略初始值设定项，则变量的初始值是未定义的（栈存储的特征，它的值是包含之前定义的值的任何表达式，甚至是函数调用）。
- 外部变量声明和所有 ```static``` 变量（无论是外部还是内部变量）的初始值必须是常数表达式，```auto``` 变量的地址不能用作静态初始值设定项，因为它不是常量。
- 如果标识符的声明具有块范围，并且标识符具有外部链接，则该声明不能具有初始化（函数或结构、枚举、联合的模板声明）。

<br>

#### 初始化聚合类型

聚合类型是结构、联合或数组类型。如果聚合类型包含聚合类型的成员，则初始化规则将以递归方式进行。

> *聚合对象的初始化列表*

- 初始化列表是一个用逗号分隔的初始值设定项的列表，列表的每个初始值设定项是常量表达式或内嵌初始值设定项列表。
- 对于每个初始值设定项列表，常量表达式的值将按顺序赋给聚合变量的相应成员。
- 列表具有的值少于聚合类型时，聚合的其余成员会初始化为 0（指针为 ```null```）；列表具有的值多于聚合类型会导致错误。
- 未显式初始化的自动标识符的初始值是不确定的。

> *聚合类型初始时的规则*

- 结构的初始值设定项要么是同一类型的表达式，要么是其成员包含在大括号 ```{ }``` 中的初始值设定项的列表。未命名的位域成员是未初始化的。
- 如果数组的大小未知，则初始值设定项的数目将确定数组的大小。
- 初始化器列表不能为空。

> *嵌套的初始化设定项列表*

```c
int P[4][3] =
{
    { 1, 1, 1 },
    { 2, 2, 2 },
    { 3, 3, 3,},
    { 4, 4, 4,},
};
```

如果聚合成员没有嵌入的初始值设定项列表，则只会按顺序将值赋给子聚合的每个成员。

```c
int P[4][3] =
{
   1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4
};
```

> *联合的初始化设定项列表*

```c
union
{
    char x[2][3];
    int i, j, k;
} y = {
	{
        {'1'},
        {'4'}
    }
};
```

该联合的第一个元素是数组，因此该初始值设定项是聚合初始值设定项。初始值设定项列表 `{'1'}` 将值赋给数组的第一行。由于列表中仅显示一个值，因此，第一列中的元素将初始化为字符 1，而该行中的其余两个元素将初始化为值 0（默认值）。同样，`x` 的第二行的第一个元素将初始化为字符 4，而该行中的其余两个元素将初始化为值 0。

> *可以使用单个指示符从数组的两端 “分配” 空间*

```c
int a[A_MAX] = {
    1, 3, 5, 7, 9, [A_MAX-5] = 8, 6, 4, 2, 0
};
```

如果 `A_MAX` 大于 10，则中间会有一些零值元素；如果小于 10，则前 5 个初始值设定项提供的某些值将被后 5 个初始值设定项覆盖。

<br>

#### 初始化字符串

可以使用字符串文本（或宽字符串文本）初始化字符（或宽字符）的数组。

```c
char code[] = "abc";
// 等同于
char s[]  = {'a', 'b', 'c', '\0'};
```

标识符列表的长度值只能与要初始化的标识符的数量相同。如果指定短于字符串的数组大小，则会忽略多余字符。

```c
// 只有初始值设定项的前三个字符将分配给 code，字符 d 和字符串终止 null 字符将被丢弃
char code[3] = "abcd";
// 等同于
char s[3] = {'a', 'b', 'c'};
```

<br>

#### 空初始化器

对象声明的初始值设定项可以是空初始化器 `{}`，对象的值将初始化为全零位。

```c
int num = {};
int arr[10] = {};
struct s = {};
union u = {};
```

>---
### 属性说明符（C23）

属性为各种源构造（如类型、对象、标识符或块）指定其他信息。它们由属性令牌标识，该令牌可以是属性前缀令牌（对于特定于实现的属性），也可以是由标识符指定的标准属性（C 标准中指定的属性）。标准中指定的任何标准属性的支持都是实现定义的且可选的。实现不支持的任何属性标记都将被忽略。

属性被认为属于某个源结构，由它们出现的语法上下文标识，对于每个单独的属性，相应的子句限制了该附属物在其中有效的语法上下文。附属于某个源构造的属性说明符序列应只包含允许应用于该源构造的属性。

```ANTLR
[[ attribute-list ]]

attribute-list:
    标准属性
    属性前缀 :: 标识符
    标准属性 ( 参数列表? )
    属性前缀 :: 标识符 ( 参数列表? )
attribute:
    attribute-token attribute-argument-clause?

attribute-token:
    
    attribute-prefixed-token

attribute-prefixed-token:
    attribute-prefix :: identifier

attribute-argument-clause:
    ( balanced-token-sequence? ) 

balanced-token-sequence:
    balanced-token
    balanced-token-sequence balanced-token 

balanced-token:
    ( balanced-token-sequenceopt )
    [ balanced-token-sequenceopt ]
    { balanced-token-sequenceopt }
    除括号、括号或大括号以外的任何标记
``` 

```c
[[attr]]
[[attr1, attr2, attr3(args)]]
[[属性前缀::attr(arg)]]
[[属性前缀::attr]]
/*
标准属性			例如 [[fallthrough]]
属性前缀::标识符	有命名空间的属性，例如 [[gnu::unused]]，C++
标准属性(实参列表)	有实参的标准属性
属性前缀::标识符(实参列表)
*/
```

<br>

#### 标准属性

标准属性中的标识符应为以下项之一：

```c
deprecated      maybe_unused        noreturn        unsequenced
fallthrough     nodiscard           _Noreturn       reproducible            
```

属性令牌在属性列表中的显示顺序不重要，每个实现都应为属性前缀令牌中的属性前缀选择一个独特的名称。实现不应定义没有属性前缀的属性，除非它是 C 标准中指定的标准属性。

```c
// 假设实现选择属性前缀 hal 并提供名为 daisy 和 rosie 的特定属性。
[[deprecated, hal::daisy]] double nine1000(double);
[[deprecated]] [[hal::daisy]] double nine1000(double);
[[deprecated]] double nine1000 [[hal::daisy]] (double);
```

在语言的所有方面，指定为标识符 `attr` 的标准属性和形式为 `__attr__` 标识符在用作属性标记时的行为应相同，但拼写除外。属性 `[[nodiscard]]` 和 `[[__nodiscard__]]` 可以自由互换。

```c
[[__deprecated__, __hal__::__daisy__]] double nine1000(double);
[[__deprecated__]] [[__hal__::__daisy__]] double nine1000(double);
[[__deprecated__]] double nine1000 [[__hal__::__daisy__]] (double);
```

对于同一实现，以下两个声明是等效的，因为属性列表中的排序并不重要。

```c
[[hal::daisy, hal::rosie]] double nine999(double);
[[hal::rosie, hal::daisy]] double nine999(double);
```

另一方面，以下两个声明并不等价，因为不同属性说明符的顺序可能会影响语义。

```c
[[hal::daisy]] [[hal::rosie]] double nine999(double);
[[hal::rosie]] [[hal::daisy]] double nine999(double);
```

<br>

#### 属性测试

```c
__has_c_attribute( 属性令牌 )
```

在 `#if` 与 `#elif` 的表达式中可以展开 `__has_c_attribute`。`#ifdef`、`#ifndef` 和 `defined` 把它当做已定义的宏处理，但不能在别处使用它。

```c
__has_c_attribute(nodiscard)        202311L
__has_c_attribute(deprecated)       202311L
__has_c_attribute(fallthrough)      202311L
__has_c_attribute(maybe_unused)     202311L
__has_c_attribute(noreturn)         202311L
__has_c_attribute(unsequenced)      202311L
__has_c_attribute(reproducible)     202311L
```

<br>

#### nodiscard 弃值表达式警告

```c
[[nodiscard]]
[[__nodiscard__]]	(1)
[[nodiscard (字符串字面量)]]
[[__nodiscard__ (字符串字面量)]]
```

`nodiscard` 属性应用于函数、枚举、结构或联合类型的定义。
- 若从转型到 `void` 以外的弃值表达式（调用声明为 `nodiscard` 的函数，或调用返回声明 `nodiscard` 的结构体 / 联合体 / 枚举的函数）则鼓励编译器发出警告。
- 弃值表达式，返回值放弃接收。

```c
struct [[nodiscard]] S { int status; };
struct S returnStruct(){
	return (struct S){0};
}

[[nodiscard("No Discard")]] int Mrix(int a, int b){
	return a ^ b;
}

int main(void){
	returnStruct();   /* warning */
	int rt = Mrix(1,2);	/* legal */
}
```

<br>

#### deprecated 弃用

```c
[[deprecated]]
[[__deprecated__]]
[[deprecated (字符串字面值)]]
[[__deprecated__ (字符串字面值)]]
```

`deprecated` 属性可用于标记仍允许使用但出于某种原因不建议使用的名称和实体。

```c
struct [[deprecated]] S;              // 结构/联合
[[deprecated]] typedef S* PS;         // typedef 名称
[[deprecated]] int x;                 // 对象
union U { [[deprecated]] int n; };    // 结构/联合成员
[[deprecated]] void f(void);          // 函数
enum [[deprecated]] E {};             // 枚举
enum { A [[deprecated]], B [[deprecated]] = 42 };   // 枚举项
```

声明时未弃用的名称可被重声明为 `deprecated`。声明为 `deprecated` 的名称不能通过不带此属性地重声明而变为未弃用。“已弃用” 适用于过时、不安全、不安全或不适合用途的名称和实体。

```c
[[deprecated]]
void TriassicPeriod(void)
{
    puts("Triassic Period: [251.9 - 208.5] million years ago.");
}
[[deprecated("Use NeogenePeriod() instead.")]]
void JurassicPeriod(void)
{
    puts("Jurassic Period: [201.3 - 152.1] million years ago.");
}
 
int main(void)
{
    TriassicPeriod();
    JurassicPeriod();
}
/* 可能的输出
test.c: In function 'main':
test.c:16:5: warning: 'TriassicPeriod' is deprecated [-Wdeprecated-declarations]
   16 |     TriassicPeriod();
      |     ^~~~~~~~~~~~~~
test.c:4:6: note: declared here
    4 | void TriassicPeriod(void)
      |      ^~~~~~~~~~~~~~
test.c:17:5: warning: 'JurassicPeriod' is deprecated: Use NeogenePeriod() instead. [-Wdeprecated-declarations]
   17 |     JurassicPeriod();
      |     ^~~~~~~~~~~~~~
test.c:9:6: note: declared here
    9 | void JurassicPeriod(void)
      |      ^~~~~~~~~~~~~~
Triassic Period: [251.9 - 208.5] million years ago.
Jurassic Period: [201.3 - 152.1] million years ago.
*/
```

<br>

#### fallthrough 贯穿抑制警告

```c
[[fallthrough]]
[[__fallthrough__]]
```

仅可用于属性声明以创建直落声明（`[[fallthrough]];`）。直落声明仅可用于 `switch` 语句中，其中要遇到的下个块项（语句、声明或标号）是该 `switch` 语句的带 `case` 或 `default` 标号的语句。指示从前一标号直落是有意的，而在发生直落时给出警告的编译器不应诊断它。

```c
switch (n) {
    case 1:
    case 2:
        g();
        [[fallthrough]];
    case 3: 	// 贯穿时不警告
        h();
    case 4: 	// 编译器可在发生贯穿时警告
	    if(n < 3) {
            i();
            [[fallthrough]]; 	// OK
        }
        else {
            return;
        }
    case 5:
        while (false) {
            [[fallthrough]]; 	// 谬构：下一语句不是同一迭代的一部分
        }
    case 6:
        [[fallthrough]]; 		// 谬构：下一语句不是同一迭代的一部分
}
```

<br>

#### maybe_unused 抑制对未使用实体的警告

```c
[[maybe_unused]]
[[__maybe_unused__]]
```

`maybe_unused` 属性应应用于结构、联合、`typedef` 名称、对象、结构或联合成员、函数、枚举、枚举器或标签的声明。若编译器可以对未使用的实体发出警告，则对任何声明为 `maybe_unused` 的实体抑制该警告。

```c
struct [[maybe_unused]] S;              // 结构/联合
[[maybe_unused]] typedef S* PS;         // typedef 名称
[[maybe_unused]] int x;                 // 对象
union U { [[maybe_unused]] int n; };    // 结构/联合成员
[[maybe_unused]] void f(void);          // 函数
enum [[maybe_unused]] E {};             // 枚举
enum { A [[maybe_unused]], B [[maybe_unused]] = 42 };   // 枚举项
```

<br>

#### noreturn 函数不会返回

```c
[[noreturn]]
[[__noreturn__]]

[[Noreturn]]        // 弃用
[[__Noreturn__]]    // 弃用
```

指示函数不会返回。这个属性适用于函数名，指示函数不会由于执行返回语句或由于抵达函数体结尾而返回（它可以通过执行 `longjmp` 返回）。如果有此属性的函数实际返回，则其行为未定义。如果可以检测这种情况，建议编译器予以诊断。
_Noreturn 函数说明符被弃用。应该用 `[[noreturn]]` 属性代替。

实现应为使用 `noreturn` 属性声明的函数生成诊断消息，该函数似乎能够返回给其调用方。

```c
[[noreturn]] void f(void) {
    abort(); // ok
}
[[noreturn]] void g(int i) { 
    // causes undefined behavior if i <= 0
    if (i > 0) abort();
}
[[noreturn]] int h(void);
```

以下标准库函数均被声明带有 `noreturn` 属性：

```c
abort()
exit()
_Exit()
quick_exit()
thrd_exit()
longjmp()
```

<br>

#### unsequenced 和 reproducible 函数类型标准属性

函数类型的属性应应用于具有函数类型的类型说明符的函数声明符。相应的属性是函数类型的属性。这些属性适用于函数声明符或者具有函数类型的类型说明符。相应属性是函数类型的性质。这些属性区分读取操作（无状态和无关联）和写入操作（无效果、幂等和可重现）或两者的组合（未排序）

尽管在语义上附加到函数类型，但所描述的属性不是此类函数原型的一部分，并且删除此类属性的重新声明和转换是有效的，并构成兼容类型。相反，如果函数声明或具有该属性的类型的函数指针访问不具有断言属性的定义，则该行为是未定义的。

```c
[[ unsequenced ]]
[[ __unsequenced__ ]]

[[ reproducible ]]
[[ __reproducible__ ]]
```

`unsequenced` 指示函数无效果、幂等、无状态且无关联，即它是无序的。
`reproducible` 指示函数无效果且幂等，即它是可重现的。

这些属性为编译器优化的目的而存在：
- 如果函数 `reproducible` 可重现，则可将先后多次调用当做一次调用。
- 如果函数 `unsequenced` 无序，则可将先后多次调用当做一次调用，且这些调用可以并行化并任意重排。

```c
size_t hash(char const[static 32]) [[reproducible]];
bool tendency(signed char) [[unsequenced]];
```

> 无作用

如果函数调用过程中编入序列的任何存储操作，都是对某对象的同步于此次调用的修改，则该调用的执行是无作用的；如果这种存储操作还是可观察的，则对该对象的所有访问必须都基于函数的一个唯一指针形参进行。

> 幂等

对于某个求值 `E`，若 `E` 的第二次求值可以紧跟第一次求值编入序列而不改变结果值（如果有）或执行的可观察状态，则它是幂等的。

> 无状态

如果函数 `F` 或其所调用的任何函数中，具有静态或线程存储期的任意对象的定义均为 `const` 但无 `volatile` 限定，则 `F` 是无状态的。

> 无关联

对于函数 `F`，如果 `F` 的调用中可以通过并非该调用的形参的左值而观察到任何对象 `X`，而在同一次程序执行中所有对 `F` 的调用中，对 `X` 的所有访问都观察到相同的值，则 `F` 无关联；或者如果访问是通过某个指针形参进行，则应当有一个唯一的这种指针形参 `P`，使得对 `X` 的任何访问都应当是基于 `P` 的左值访问。

对象 `X` 由函数调用所观察的条件是：二者均同步，`X` 并非局部与此次调用，`X` 的生存期开始于函数调用之前，且此次调用中有对 `X` 的访问被排入序列；此次调用前所存储的 `X` 的最新值（如果有），被称为此次调用所观察到的 `X` 的值。

---