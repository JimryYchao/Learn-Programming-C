## C 组成元素

> 工作记录：属性说明符（C23）缺省行为

---
### 标记、空白字符、注释

> *标记*

C 编译器识别的基本元素是 **标记**，包括有关键字（令牌）、标识符、常量、字符串、运算符、标点符号等。

> *空白字符*

空白字符包括有空格 ```' '```、制表符 ```'\t'```、换行符 ```'\n'```、回车符 ```'\r'```、换页符 ```'\f'``` 和垂直制表符 ```'\v'```。标记由空白符和其他标记分隔（划分边界），在分析代码时，编译器将忽略空白字符。

> *注释*

```c
// CXX 单行风格
/*
	C 多行
	风格
*/
```

> *标识符（identifier）*

标识符为程序中的变量、类型、函数和标签提供名称，名称在拼写和大小写上必须与任何关键字都不同。标识符的首字符不可以是数字字符。

```c
/* 有效标识符 */
_Identifier
Identifier
Identifier123
```

> *标识符翻译限制*

  自 C99 后各标识符极限：
  - 内部标识符或宏名中 63 个有效起始字符
  - 外部标识符中 31 个有效起始字符
  - 一个翻译单元中 4095 个外部标识符
  - 一个块中声明 511 个拥有块作用域的标识符
  - 一个预处理翻译单元中同时定义 4095 个宏标识符


---
### 关键字（令牌）类型

> *标准 C 关键字*

|关键字| 描述 |
|:----|:----|
|auto 		| 自动类型声明
|const		| 只读类型声明限定
|extern		| 外部类型引用声明
|static		| 静态类型声明限定
|restrict	| 参数引用类型声明限定
|volatile	| 声明的变量类型在程序执行过程中可被隐式改变
|register	| 寄存器存储类型声明
|inline		| 内联函数
|||
|char		| 字符类型
|double		| 双精度浮点类型
|float		| 单精度浮点类型
|short		| 短整数类型声明
|int 		| 整数类型
|long		| 长整数类型
|enum		| 枚举类型
|struct		| 结构类型
|union		| 联合或共用体类型
|void		| 函数无返回类型
|signed		| 声明有符号数值类型
|unsigned	| 声明无符号数值类型
|||
|switch		| switch 条件分支语句
|case		| switch 语句的 case 分支
|default	| switch 语句的默认分支
|if			| if 条件分支
|else		| if 语句 的 else 分支
|do			| do 循环体
|while		| while 循环
|for		| for 循环
|break		| 跳出当前循环或分支
|continue	| 结束当前循环，进入下一轮
|goto		| 无条件跳转语句
|return		| 函数返回语句
|||
|sizeof		| 计算数据类型或变量所占字节数
|typedef	| 类型别名声明
|typeof     | 反射获得变量或函数的类型

> *保留关键字*

|保留关键字|描述|
|:---|:---|
|_Alignas 		| （C11）修改类型的内存对齐属性
|_Alignof		| （C11）获取类型的内存对齐属性
|_Atomic		| （C11）声明原子类型
|_Bool			| （C99）声明布尔类型
|_Complex		| （C99）声明复数类型
|_Generic		| （C11）泛型编程
|_Imaginary		| （C99）虚数类型
|_Noreture		| （C11）宏定义，应用方的函数不返回调用方
|_Static_assert	| （C11）在编译时测试断言
|_Thread_local	| （C11）线程本地存储

---
### 存储类说明符

```c
auto、register  /* 声明项具有本地存储期 */
static、extern  /* 声明项具有全局存储期 */
_Thread_local   /* 声明项具有线程存储期 */
__declspec      /* 扩展的存储类特性，Microsoft C 专用*/
```

#### static

```static``` 限定类型的声明仅在当前范围内可见，且存储期是静态的（全局生存）。可以限制变量和函数的链接方式。 可以在文件范围和函数体范围内声明 ```static``` 类型。

静态类型仅在首次进入所在范围时初始化，且仅在该声明的范围内私有永久存储，无论是内部级别或外部级别。

 ```c
// 在函数形参中修饰数组长度，表示该数组至少 20 个元素
 double stick(double ar[static 20]);
```

#### extern

```extern``` 存储类说明符声明对在其他位置类型声明的引用。在外部级别中引用声明之后，该引用声明将在剩余的翻译单元内均可见。

```extern``` 限定从未声明的类型，表明该声明是具有外部链接属性的，那么此定义可见于构成程序的任何翻译单元中。可以在文件范围和函数体范围内声明 ```extern``` 类型。

#### auto

```auto``` 存储类说明符声明具有本地生存期的自动变量。只能声明在内部级别（函数体范围）。自动类型变量不会自动初始化（栈存储不存在垃圾回收），直接使用未定义的自动类型变量是未定义行为。

对于内部级别的静态类型，不能用自动类型进行初始化（因为自动类型的地址是不确定的）。

#### register

```register``` 限定变量的存储类为寄存器类型，变量通常储存在计算机内存中，寄存器变量储存在 CPU 的寄存器中，访问速度要比内存中的变量更快。当被编辑器忽略时，自动转换为自动类型。

寄存器类型无法获取地址，因此无法利用地址运算符，即使变为自动类型。

```c
int main(void){
    register int num = 1;       // 指定该变量储存在 CPU 寄存器中
}
void Fun(register int num);     // 指定形参储存方式
```

#### _Thread_local

```_Thread_local``` 声明的变量类型具有线程存储期，不能用于函数类型的声明。用于对象声明时必须在每次声明上出现；当用在块范围时，必须与 ```static``` 或 ```extern``` 之一组合以决定链接。线程对象在启动线程时开始初始化。

> *试探性定义*

试探性定义是没有初始化器的外部声明，且要么没有存储类说明符或拥有说明符 `static`。

试探性定义是可能或可能不表现为定义的声明。若在同一翻译单元的前方或后方能找到实际的外部定义，则试探性定义仅表现为声明；若在同一翻译单元中无定义，则试探性定义表现为将对象零初始化的实际定义。

 ```c
int i1 = 1;     	// 定义，外部链接
int i1;         	// 试探性定义，表现为声明，因为 i1 已定义
extern int i1;  	// 声明，引用前面的定义

extern int i2 = 3; 	// 定义，外部链接
int i2;            	// 试探性定义，表现为声明，因为 i2 已定义
extern int i2;     	// 声明，引用到前面的外部链接定义
```

不同于 ```extern``` 声明（如果前一声明已建立标识符链接，```extern``` 声明不更改链接属性），试探性定义可以与同一标识符另一声明的链接不一致。若同一标识符的二个声明均在作用域内且拥有不同链接，则行为未定义。

```c
static int i4 = 2; 	// 定义，内部链接
int i4;            	// 未定义行为：链接与前一行不一致
extern int i4;    	// 声明，引用到内部链接定义

static int i5; 		// 试探性定义，内部链接
int i5;        		// 未定义行为：链接与前一行不一致
extern int i5; 		// 引用到前者，其链接为内部
```

拥有内部链接的试探性定义必须拥有完整类型。

```c
static int i[];     // ERROR：试探性 static 声明中不允许出现不完整类型
int i[];            // 试探性声明，等价于 int i[1] = {0}; 除非在此文件之后重定义声明
```

---
### 类型说明符

类型说明符用于在声明时定义变量或函数的类型，说明符类型有 ```void```、```char```、```short```、```int```、```long```、```float```、```double```、```signed```、```unsigned```、```struct```、```union```、```enum```、```typedef-name```。

> *定义变量*

```c
/* 声明整型 */
<signed/unsigned> <char/short/int/long/long long> Integer;
enum EnumType;

/* 声明浮点型 */
<float/double/long double> Double

/* 声明指针 */
<type *> p;
int* pInt = &num;
```

#### void

```void``` 有三种用途：指定为函数返回类型、为未采用参数的函数指定一个参数类型列表、指定一个指向未指定的类型的指针。

```void*``` 能用作指向未指定的类型的指针，除 ```char*``` 外转换成其他类型的指针需要强制类型转换。

#### 数据类型说明符和等效简化声明

```c
signed char         >>>     char
signed int          >>>     int, signed
signed short int    >>>     short, signed short
signed long int     >>>	    long, signed long
unsigned char       >>>     NaN
unsigned int        >>>     unsigned
unsigned short int  >>>     unsigned short
unsigned long int   >>>	    unsigned long
float               >>>     NaN
long double         >>>     NaN
```

---
### 类型限定符

```const``` 类型限定符将对象声明为不可修改。

```volatile``` 类型限定符声明一个项，该项的值可由超出该项所在的程序控制范围的某个项（如并发执行的线程）合理更改（易变的）。

```restrict``` 用于限定指针，出于优化策略，表明该指针是访问数据对象的唯一且初始的方式。但不限定其指向的内容。

```_Atomic```（C11）声明原子类型。

```c
// 合法声明
typedef volatile int VI;
const int ci;
// 非法声明
typedef int *i, volatile *vi;
float f, const cf;
```

#### const

```c
const int ci;
const int carri[size];
void Func(const int);	// 限定函数形参
```

`const` 指针声明时的注意点：

```c
// * 在 const 后，限定指针指向的值
int const *p_ci;        // 指向整型常量的指针
const int *p_ci;        // 指向整型常量的指针
// * 在 const 前，限定指针
int* const cp_i;        // 指向整型的常量指针
// const 双限定
const int* const cp_ci; // 指向整型常量的常量指针
```

`const` 与非 `const` 指针间的转换：指向非 ```const``` 类型的指针能隐式转换成指向同一或兼容类型的 ```const``` 限定版本的指针。能用类型强制转换进行逆向转换。

```c
int* p = 0;
const int* cp = p;  // 添加限定符，int 隐式转换到 const int
p = cp;             // ERROR：舍弃限定符（const int 到 int）
p = (int*)cp;       // 强制转换
```

指向指向 ```T``` 指针的指针不可转换为指向指向 ```const T``` 指针的指针；对于要兼容的二个类型，其限定必须等同。

```c
char *p = 0;
const char **cpp = &p; 	// ERROR： char* 与 const char* 不是兼容类型
char * const *pcp = &p; // 添加限定符（ char * 到 char *const ）
```

> *`const` 两种声明方式*

```c
void Func(char* const c);
// 等价于
void Func(char c[const]);
```

#### volatile

```volatile``` 类型说明符可用于提供对特定内存位置的可靠访问。
```volatile``` 限定告知计算机，代理（不是变量所在的程序）可以修改该变量的值，一般用于硬件地址以及在其他程序或同时运行的线程中共享数据。

```c
volatile int vol;
void f(double x[volatile], const double y[volatile]);
void f(double * volatile x, const double * volatile y);
```

一个非 ```volatile``` 值到 ```volatile``` 值的转换是无效果的。欲使用 ```volatile``` 语义访问非 ```volatile``` 对象，必须先将其地址转换成指向 ```volatile``` 类型的指针，再通过该指针访问该对象。

```c
int vol;
// 转变为易变对象
volatile int* pVol = &vol;
```

任何通过非 ```volatile``` 左值结果，对拥有 ```volatile``` 限定类型的对象尝试读或写会导致未定义行为。

```c
volatile int n = 1; // volatile 限定类型
int* p = (int*)&n;
int val = *p; // 未定义行为
```

```volatile``` 限定的结构体或联合体类型，其成员会自动获取其所属类型的限定。以 ```volatile``` 类型限定符声明数组类型（通过使用 ```typedef``` ），数组类型无 ```volatile``` 限定，但其元素成员有。
`const volatile` 限定：一个项可以同时是 ```const``` 和 ```volatile```，在这种情况下，此项不能被它自己的程序以合法方式修改，但能被一些异步进程修改（例如系统时钟）。
 
 ```c
volatile const int loc;
const volatile int * ploc;
```

> *`volatile` 禁用优化策略*

```c
val1 = x;
//do...不使用 x 的代码
val2 = x;
```

一些编译器会将 x 的值保存在寄存器，当 val2 使用 x 时，并不会从原始内存位置的读取 x 的值，会从寄存器上读取 x，目的是为了程序优化（此过程称为高速缓存 caching）。
但如果其他的代理在 val1 与 val2 改变了 x 的值，编译器并不知道这类事发生，安全起见，使用 ```volatile``` 限定的变量不会采用高速缓存的方式读取 x 的值。

#### restrict

```restrict``` 关键字允许编译器优化某部分代码以更好地支持计算，只能用于指针，表明该指针是访问数据对象的唯一且初始的方式。它限定指针，而不是它指向的内容。若对标记为 ```restrict``` 的指针使用了别名，则结果是不确定的。

 ```c
// 用于函数形参，限定仅能从 restrict 指针变量访问数据
void test(int* restrict first, int* restrict second, int* val)
{
    *first += *val;
    *second += *val;
}
// 将 union 成员标记为 restrict 告诉编译器在任何作用域中只有 z.x 或 z.y 可被访问
union z
{
    int* restrict x;
    double* restrict y;
};
```

文件作用域的 ```restrict``` 限定指针必须在程序运行期间指向单个数组的元素。文件作用域 ```restrict``` 指针对访问动态分配的全局数组很有用

```c
/* 作用于文件作用域 */
float * restrict a, * restrict b;
float c[100];

int init(int n) {
   float * t = malloc(2*n*sizeof(float));
   a = t;      // a 引用前半
   b = t + n;  // b 引用后半
}
// 编译器可以从 restrict 限定符推断 a 、 b 和 c 都没有潜在的别名引用
```

> *`restrict` 优化策略*

```c
int* restrict restar = (int *) malloc(10 * sizeof(int));
// 指针 restar 是访问由 malloc() 所分配内存的唯一且初始化的方式

restar[0] += 5;
restar[0] += 3;
// 由于 restar 唯一指定访问方式, 编译器处于优化考虑, 会采用 restar[0] += 8 进行替换

//------------------- 一般模式 -------------------
int ar[10];
int * par = ar;

par[0] += 5;
ar[0] *= 2;
par[0] += 3;
/*
  par 未使用 restrict 限定, 编译器就必须假设最坏的方式(其他标识符可能已经改变该地址的值),
不能用 par[0] += 8 进行替换
*/
```

> *`restrict` 的两种声明方式*

```c
void Func(int* restrict n);
// 等价于
void Func(int* n[restrict]);
```

#### _Atomic


并发程序设计把程序执行分成可以同时执行的多个线程, 因此如何管理访问相同数据的不同线程，C11 通过包含可选的头文件 ```stdatomic.h```，提供了一些可选的（不是必须实现的）管理方法。

> *`_Atomic` 用作类型说明符或类型限定符*

- 当 ```_Atomic``` 用作类型说明符，指代新的原子类型；当用作类型限定符，指代类型名的原子版本。在此作用中，它可以与 ```const```、```volatile``` 及 ```restrict``` 混合使用（尽管不同于其他限定符，类型名的原子版本可能拥有不同的大小、对齐以及对象表示）。
- 若编译器定义了宏常量 ```__STDC_NO_ATOMICS__``` ，则不提供关键词 ```_Atomic```。

```c
_Atomic const int * p1;  // p 是指向 _Atomic const int 的指针
const atomic_int * p2;   // 同上
const _Atomic(int) * p3; // 同上
```

> *原子类型解释说明：*

- 原子类型的对象是仅有的免除数据竞争的对象，即它们可以被两个线程共时修改，或先被一个修改再被另一个读取。
- 每个原子对象都拥有关联于其自身的修改顺序，即对该对象的完整修改顺序（若从某个线程的视角来看，对于某原子对象 M 的修改 A 发生先于同一原子对象 M 的修改 B，则在 M 的修改顺序中 A 的出现先于 B）。
- 不同线程可能会观测到不同原子对象有相异的修改顺序，对于所有原子运算，保证有四种连贯：
  - **写写连贯**：若原子对象 M 的修改操作 A 先发生于 M 的修改操作 B，则 M 的修改顺序中 A 出现早于 B。
  - **读读连贯**：若原子对象 M 的值计算 A 先发生于 M 的值计算 B ，且从 M 上的副作用 X 求得 A 值，则 B 所计算得的值要么是 X 所存储的值，要么是 M 上的副效应 Y 所存储的值，其中 Y 在 M 的修改顺序中出现后于 X。
  - **读写连贯**：若原子对象 M 的值计算 A 先发生于 M 上的操作 B ，则从 M 上的副效应 X 求得 A 值，这里 X 在 M 的修改顺序中出现先于 B 。
  - **写读连贯**：若在原子对象 M 上的副效应 X 先发生于 M 的值计算 B ，则求值 B 从 X，或从在 M 的修改顺序中出现后于 X 的副效应 Y 求得其值。

- 原子属性仅对左值表达式有意义。左值到右值转换（模仿从原子区域到 CPU 寄存器的内存读取）会把原子性及其他限定符剥去。

```c
#include <stdio.h>
#include <threads.h>
#include <stdatomic.h>

atomic_int acnt;
int cnt;

int f(void* thr_data)
{
    for(int n = 0; n < 1000; ++n) {
        ++cnt;
        ++acnt;
        // 对于此例，宽松内存顺序是足够的，例如
        // atomic_fetch_add_explicit(&acnt, 1, memory_order_relaxed);
    }
    return 0;
}

int main(void)
{
    thrd_t thr[10];
    for(int n = 0; n < 10; ++n)
        thrd_create(&thr[n], f, NULL);
    for(int n = 0; n < 10; ++n)
        thrd_join(thr[n], NULL);

    printf("The atomic counter is %u\n", acnt);
    printf("The non-atomic counter is %u\n", cnt);
}
/* 可能的输出
	The atomic counter is 10000
	The non-atomic counter is 8644
*/
```

---
### 类型声明

#### 整数数值类型

```c
// 1. short >>> 16 bits
    short int num1;
    short num2;
// 2. int   >>> 16/32 bits
    signed int num1;
    int num2;
// 3. long(L)  >>> 32 bits
    long int num1;
    long num2;
// 4. long long(LL) >>> 64 bits
    long long int num1;
    long long num2;
// 5. unsigned
    unsigned int ui;
    unsigned u;  // U 后缀
    unsigned short us;
    unsigned long ul; // UL 后缀
```

> *整型进制转换*

```c
printf("%d");       // 显示十进制数字
printf("%o");       // 以八进制显示数字
printf("%x");       // 以十六进制显示数字
// 显示进制数字前缀
printf("%#o");      // %#o、%#x、%#X,
```

> *整型可移植: ```stdint.h```*

- C99 新增了两个头文件 ```stdint.h``` 和 ```inttypes.h```，以确保 C 语言的类型在各系统中的功能相同。
* 在 ```stdint.h``` 头文件中，```int32_t``` 表示 32 位的有符号整数类型
  - 在 32 位 ```int``` 的系统中，```int32_t``` 作为 ```int``` 的别名
  - 在 ```int``` 为 16 位、```long``` 为 32 位的系统会把 ```int32_t``` 作为 ```long``` 的别名
- 使用 ```int32_t``` 类型编写程序，并包含 ```stdint.h``` 头文件时，编译器会把 ```int``` 或 ```long``` 替换成与当前系统匹配的类型。

```c
// 1. 精确宽度整数类型
typedef signed char             int8_t;
typedef short                   int16_t;
typedef int                     int32_t;
typedef long long               int64_t;
typedef unsigned char           uint8_t;
typedef unsigned short          uint16_t;
typedef unsigned int            uint32_t;
typedef unsigned long long      uint64_t;
// 2. 至少有指定宽度的最小整数类型
typedef signed char             int_least8_t;
typedef short                   int_least16_t;
typedef int                     int_least32_t;
typedef long long               int_least64_t;
typedef unsigned char           uint_least8_t;
typedef unsigned short          uint_least16_t;
typedef unsigned int            uint_least32_t;
typedef unsigned long long      uint_least64_t;
// 3. 最快最小宽度类型
typedef signed char             int_fast8_t;
typedef int                     int_fast16_t;
typedef int                     int_fast32_t;
typedef long long               int_fast64_t;
typedef unsigned char           uint_fast8_t;
typedef unsigned int            uint_fast16_t;
typedef unsigned int            uint_fast32_t;
typedef unsigned long long      uint_fast64_t;
// 4. 系统的最大整数类型
typedef long long               intmax_t;
typedef unsigned long long      uintmax_t;
```

```int_least8_t``` 是可容纳 8 位有符号整数值的类型中宽度最小的类型的一个别名。如果某系统的最小整数类型是 16 位，可能不会定义 ```int8_t``` 类型。该系统仍可使用 ```int_least8_t``` 类型，但可能把该类型转换为 16 位的整数类型。
```int_fast8_t``` 被定义为系统中对 8 位有符号值而言运算最快的整数类型的别名。
C99 定义了最大的有符号整数类型 ```intmax_t```，可储存任何有效的有符号整数值。类似地，```unitmax_t``` 表示最大的无符号整数类型。这些类型有可能比 ```long long``` 和 ```unsigned long``` 类型更大。

#### char 字符

```char``` 用于储存字符，技术层面本质是整数类型。```wchar_t``` 是 ```char``` 的宽字符版本。计算机使用数字编码来处理字符，用特定的整数表示特定的字符（常用编码 ASCII）
常规 ```char``` 字符类型的宽度为 8 位，代表执行字符集；宽字符常量的宽度为 16 位，用于指定扩展执行字符集的成员，多字节字符是由一个或多个字节的序列构成的字符，常用于日文、中文等字符集字符表示。宽字符使用 L 前缀标明字符类型

 ```c
// 声明字符类型
	char c = 'A';
// char 小整数
	unsigned char c_num = 1;
	signed char c_num = -2;
// 宽字符
	wchar_t CN_Str = L'宽';
```

转义序列被视为单个字符，是有效的字符常量。通常用于指定操作

```
\a      警报
\b      退格
\f      换页
\n      换行
\r      回车
\t      水平制表符
\v      垂直制表符
\\      反斜杠
\'      单引号
\"      双引号
\?      问号
\o nn   八进制表示法的 ASCII 字符
\x hh   十六进制表示法的 ASCII 字符
\x hhhh 十六进制表示法的 Unicode 字符
```

> *双标符（替用记号）与三标符*

```c
// 双标符
{	<%		}	%>
[	<:		]	:>
# 	%:		##	%:%:

// 三标符
{	??<		}	??>
[	??(		]	??)
#	??=		\	??/
^	??'		|	??!
~	??-

//---------------------------
%:include <stdlib.h>
%:include <stdio.h>
%:include <iso646.h>

int main(int argc, char** argv)
??<
    if (argc > 1 and argv<:1:> not_eq NULL)
    <%
       printf("Hello%s\n", argv<:1:>);
    %>

    return EXIT_SUCCESS;
??>
```

#### _Bool 类型

C99 标准添加 ```_Bool``` 类型，表示布尔值；1 表示 ```true```，0 表示 ```false```。```_Bool``` 类型实际上是一种整数类型，仅占用 1 bit。

```c
#include <stdbool.h>

_Bool t = true;    // 1
bool f = false;    // 0
```

#### 浮点数值类型

```float``` 类型必须至少能表示 6 位有效数字，且取值范围至少为 10<sup>-37</sup>～10<sup>+37</sup>

```double``` 双精度浮点类型，最小取值范围与 ```float``` 相同，最少能表示 10 位有效数字，占用大小 64 位，32 位表示指数部分，32 位表示非指数部分。```double``` 的值至少有 13 位有效数字

当浮点值出现上溢（overflow）时，```printf``` 数值会显示为 ```inf``` 或 ```infinity```。下溢时（underflow），可能会发生精度丢失。关于浮点数的未定义行为，例如被 0 除，将返回 ```NaN```

```c
// 1. 单精度浮点数
   	float num1 = 3.14f;
// 2. 双精度浮点数
   	double num2 = 3.1415;
// 3. 长浮点数, 至少与 double 精度相同
	long double num3 = 3.14L;
// 4. 有效浮点数声明
	3.14, .2, 4e16, .8e55, 99.
```

> *十六进制浮点数（C99）*

- 0x 作为前缀，用 p 和 P 代替 e 和 E，用 2 的幂代替 10 的幂（P 计数法）
- 并非所有的编译器都支持 C99 的这一特性。

```c
double num = 0xa.1fp10;
/*
	a   ---- 10
	.1f ---- 1/16 + 15/256
	p10 ---- 2^10
*/
0xa.1fp10 = (10 + 1/16 + 15/256) * 2^10 = 10364.0
```

#### 枚举类型

枚举（enumerated type）由一组命名整数常量构成，它定义了一组已命名的整数标识符；枚举项关联常量值默认从 0 开始, 后面的成员依次递增；指定常量值时，顺次项依次递增。枚举项可以进行自增自减运算

```c
enum DAY{
    saturday,
    sunday = 0,
    monday,
    tuesday,
    wednesday,
    thursday,
    friday
} workday;
```

#### 结构类型

“结构声明” 用于为类型命名和指定一系列可具有不同类型的变量值（称为结构的 “成员” 或 “字段”），描述了一个组织布局。结构的声明有模板声明与类型声明，模板声明可以不含有标记

当两个结构变量的类型相同，可以将一个结构赋值给另一个结构（与简单数据结构相同的行为，数组不可以）

```c
#include <stdio.h>
struct book{
	const char * Name;
	int cost;
};
int main(void){
// 1. 外部声明
	struct book myBook;
	myBook.Name = "Ychao";
	myBook.cost = 99;
// 2. 块初始化
	struct book myBook2 = {
		"Ychao",99,
	};
// 3. 指定初始化器
	struct book mBook3 ={
		.Name = "Ychao",
		.cost = 99,
	};
// 4. 无标识符结构变量
	struct{
		const char * Name;
		int cost;
	} MBook = {
		.Name = "Ychao",
		.cost = 99,
	};
}
```

嵌套结构可以访问，就像它们是在文件范围级别声明的一样

```c
// 嵌套结构
struct a{
    int x;
    struct b
    {
      int y;
    } var2;
} var1;
// 合法声明
struct a var3;
struct b var4;
/*-------- 匿名结构 -------*/
struct{
    int x;
    int y;
} mystruct;
```

> *结构成员的填充与对齐:*

结构成员按其声明顺序进行存储，第一个成员的内存地址最低，最后一个成员的内存地址最高

> *结构体的对齐步骤：*

结构体各成员对齐 ➡ 结构体总体对齐

> *结构体对齐规则：*

第一个数据成员存放的地址为结构体变量偏移量为 0 的地址处

其他结构体成员自身对齐时，存放的地址为 min { 有效对齐值为自身对齐值，对齐系数 } 的最小整数倍的地址处（其中，自身对齐值表示成员的自身大小；**对齐系数**指宏定义 pack 指定值或机器位数）

总体对齐时，结构体字节大小为 min { 所有成员中自身对齐值最大的，对齐系数 } 的整数倍

> *对齐系数：*

对齐系数：宏 ```#pragma pack(N)``` 指定的值，N 一定是 2 的幂次方，1、2、4 等

默认指定对齐值：32 位 Linux 主机的默认对齐值为 4；64 位为 8；AMR CPU 默认指定对齐值为 8

```#pragma pack(N)``` 每个特定平台上的编译器都有自己的默认 “对齐系数”（也叫对齐模数），可以自定义为编译器指定对齐系数

> *对齐实例：*

 ```c
//此代码在 64 位 Linux 下编写，默认系数为 8
typedef struct _st_struct1
{
	char 	a;		// 1
	short   b;		// 2
	int		c;		// 4
} st_struct1;

printf("%ld\n",sizeof(st_struct1)); // size = 8
/* PS
1. a 是 char 类型，占 1 个字节，第一个数据成员，放在结构体变量偏移量为 0 的地址处
2. b 是 short 类型，占 2 个字节，b 的有效对齐值为 min{2, 8}=2；
   依次查看 2 的整数倍地址是否可以存放 2 个字节；
   	【2×0 = 0】 此地址处已经存放 a
   	【2×1 = 2】 此地址为空，可以将 b 存放在地址偏移量为 2 和 3 处.
3. c 是 int 类型，占 4 个字节，c 的有效对齐值为 4
   对齐到 4 的整数倍地址，即地址偏移量为 4 处.在内存中存放的位置为 4,5,6,7

4. 结构体总对齐字节大小为 min{4, 8}=4 的整数倍，此时内存中共占 8 个字节，正好是 4 的整数倍，所以 sizeof(st_struct1) = 8
*/

//此代码在 64 位 Linux 下编写
typedef struct _st_struct2
{
 	char    a;
	int     c;
	short   b;
} st_struct2;

printf("%ld\n",sizeof(st_struct2));	// size = 12
```

> *指定对齐值实例：*

使用 ```#pragma pack(N)``` 设置结构体边界时，最好使用一次 ```#pragma unpack()```， 否则在它之后定义的所有结构体都会按 N 字节对齐

```c
//此代码在64位Linux下编写
#pragma pack(1)
/*
    对齐遵循始终寻址为 1 的倍数的地址，根据对齐规则，总体的结构体大小为 7
*/

typedef struct _st_struct3
{
 	char    a;
	int     c;
	short   b;
} st_struct3;

printf("%ld\n", sizeof(st_struct3)); // 7

#pragma unpack()
// 恢复系统默认的对齐特性
```

> *把结构内容保存在文件中：*

由于结构可以储存不同类型的信息，所以它是构建数据库的重要工具。数据库文件可以包含任意数量的此类数据对象。储存在一个结构中的整套信息被称为记录（record），单独的项被称为字段（field）。

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAXTITL 40
#define MAXAUTL 40
#define MAXBKS 10 /* 最大书籍数量 */
char *s_gets(char *st, int n);
struct book /* 建立 book 模板 */
{
    char title[MAXTITL];
    char author[MAXAUTL];
    float value;
};
int main(void)
{
    struct book library[MAXBKS]; /* 结构数组 */
    int count = 0;
    int index, filecount;
    FILE *pbooks;
    int size = sizeof(struct book);
// 1. fopen 二进制读写 a 模式
    if ((pbooks = fopen("book.dat", "a+b")) == NULL)
    {
        fputs("Can't open book.dat file\n", stderr);
        exit(1);
    }
// 2. 定位到文件开始
    rewind(pbooks);
// 3. 预先 fread 读取 book.dat 中的二进制数据 (library: 并输出)
    while (count < MAXBKS && fread(&library[count], size, 1, pbooks) == 1)
    {
    // 读取 book 并赋值给 library 数组中的结构体
        if (count == 0)
            // 打印当前 book 中的数据
            puts("Current contents of book.dat:");
        printf("%s by %s: $%.2f\n", library[count].title,
                library[count].author, library[count].value);
        count++;
    }
    filecount = count;
    // 验证当前 book 容量是否满
    if (count == MAXBKS)
    {
        fputs("The book.dat file is full.", stderr);
        exit(2);
    }
// 4. 输入数据并保存在 book.dat 中
    puts("Please add new book titles.");
    puts("Press [enter] at the start of a line to stop.");
    while (count < MAXBKS && s_gets(library[count].title, MAXTITL) != NULL && library[count].title[0] != '\0')
    {
        puts("Now enter the author.");
        s_gets(library[count].author, MAXAUTL);
        puts("Now enter the value.");
        scanf("%f", &library[count++].value);
	    while (getchar() != '\n')
            continue; /* 清理输入行 */
        if (count < MAXBKS)
            puts("Enter the next title.");
    }
// 5. 输入结束输出 book.dat 内容
    if (count > 0)
    {
        puts("Here is the list of your books:");
        for (index = 0; index < count; index++)
            printf("%s by %s: $%.2f\n", library[index].title,
                    library[index].author, library[index].value);
        fwrite(&library[filecount], size, count - filecount,
                pbooks);
    }
    else
        puts("No books? Too bad.\n");
    puts("Bye.\n");
    fclose(pbooks);
    return 0;
}
char *s_gets(char *st, int n)
{
    char *ret_val;
    char *find;
    ret_val = fgets(st, n, stdin);
    if (ret_val)
    {
        // 查找换行符
        find = strchr(st, '\n');
        // 如果地址不是 NULL，
        if (find)
            // 在此处放置一个空字符
            *find = '\0';
        else
            // 清理输入行
            while (getchar() != '\n')
                continue;
    }
    return ret_val;
}
```

#### 位域

除了结构或联合的成员的声明符外，结构声明符也可以是指定数目的位，称为 “位域”。其长度从字段名称的声明符到冒号。位域被解释为整型类型。

在 ANSI C 标准下，位字段的类型只能是 ```unsigned int```、```signed int``` 和 ```int``` 的一种（包括 ```char```、```short```），C99 和 C11 新增了 ```_Bool``` 类型的位字段

位字段通过一个结构声明来建立，该结构声明为每个字段提供标签，并确定该字段的宽度


```c
struct{
	unsigned int first:4	// 表明该字段占用的 bit
	unsigned int second:2
	unsigned int third:8
} BitDomain[10]
/*
	first 位字段占用 4 个位
	三个位字段保存在一个 int 大小的内存单元中
	单个 BitDomain 元素只是用其中的 14 位
	数组对象使用了 （10 * sizeof int）大小的内存空间
 */
```

在 ANSI C 标准下，```sizeof``` 不能操作 BitDomain 的位字段，带有位字段的结构提供一种记录设置的方便途径，位字段的储存顺序自低位到高位方向

ANSI C 标准规定，位域的宽度不能超过它所依附的数据类型的长度。通俗地讲，成员变量都是有类型的，这个类型限制了成员变量的最大长度。例如 int 位字段的最大长度不能超过 32

为位字段赋值，不能超过字段可容纳的范围，例如 BitDomain.first 的大小为 4 bits，它的赋值范围为 0~2<sup>4</sup>-1

```c
struct{
	unsigned int first : 4; // 表明该字段占用的 bit
	unsigned int second : 2;
	unsigned int third : 8;
} BitDomain = {
	.first = 0b0010,
	.second = 0b10,
	.third = 0b10100101
};
```

声明的总位数超过一个 ```unsigned int``` 的大小时，会自动溢出到下一个 ```unsigned int``` 类型的存储位置

一个字段不允许跨越两个 ```unsigned int``` 之间的边界，编译器会自动移动跨界的字段，从而保持 ```unsigned int``` 之间的边界对齐

```c
struct
{
    unsigned int first : 9;
    unsigned int second : 7;
    unsigned int may_straddle : 30;
    unsigned int last : 18;
} Bits;

printf("%zd", sizeof Bits); // 防止跨越，将为 12 B
```

> *位字段的填充和对齐*

- 使用一个宽度为 0 的未命名字段迫使下一个字段与下一个整数对齐
- 当未命名字段宽度大于 0 时，会使两个字段之间产生一个不可访问的未命名位字段填充

```c
struct {
	unsigned int field_0;   // 成员 field_0 没有限制，占用 4B;
	unsigned int field_1 : 1 ;
	unsigned int : 2 ;      // 2 位的填充
	unsigned int field_2 : 1 ;
	unsigned int : 0 ;      // 迫使下一个位字段与 int 边界对齐
	unsigned int field_3 : 1 ;
} BitDomain;
```

> *位域的存储*

- 当相邻成员的类型相同时，如果它们的位宽之和小于类型的 ```sizeof``` 大小，那么后面的成员紧邻前一个成员存储，直到不能容纳为止；
- 当它们的位宽之和大于类型的 ```sizeof``` 大小，那么后面的成员将从新的存储单元开始，其偏移量为类型大小的整数倍。
- 当相邻成员的类型相同时，成员之间会趋向紧凑排列；当不同时，顺位成员会进行偏移存储，并遵循结构体的对齐原则

#### 联合类型

“联合声明” 指定一组变量值和（可选）一个命名联合的标记。变量值称为联合的 “成员”，并且可以具有不同的类型，能在同一个内存空间中储存不同的数据类型（不是同时储存）。联合的字节大小与成员中的最大字节数相同。使用联合未初始化的成员时的行为是不确定的（存在精度损失问题），应使用被初始化的成员对象

联合可以具有位域，但不能包含不完整类型、类型 ```void``` 或函数类型。成员不可以是联合的实例，但可以声明联合类型的指针


> *联合的存储*

- 与联合变量关联的存储是联合的最大成员所需的存储。
- 在存储较小的成员时，联合变量可以包含未使用的内存空间。
- 所有成员都存储在同一内存空间中并以相同的地址开始。每次将值赋给不同的成员时，都会重写存储的值

> *联合的声明与初始化*

```c
// 声明
union sign
{
    int svar;
    unsigned uvar;
};	// size = 4

union{ 		// 具有位域的联合
	unsigned int a:1;
	unsigned int b:4;
	int value;
} BitUnion;	// size = 4

// 初始化
union sign digit = {99}; 	// 默认初始化第一个元素
union sign digit2 = digit;	// 用另一个联合初始化
union sign val = {.uvar = 100};	// 指定初始化器
```

> *联合常嵌套在一个结构中*

```c
struct x
{
    int type_tag;
    union
    {
      int x;
      float y;
    };
};
```

#### 数组类型

“数组声明” 将命名数组并指定其元素的类型，其特征是元素的类型相同。数组类型的变量被视为指向数组首元的指针

一般地，声明数组时需要指定数组的长度，初始化器初始化数组时，元素数目不能超过声明数组的长度；当初始化列表中的值少于数组元素个数时，编译器会把剩余的元素都初始化为类型默认值。C 数组不允许声明零长度数组，试探性声明的数组默认为具有一个数值为 0 的类型数组

```c
// 1. 数组的声明包括数据类型与数组大小
	int IntArr[COUNT];
// 2. 初始化
	int Arr[5] = {0,1,2,3,4};           // 初始化器传统方式
	char Str[] = "This is a String";    // 自动确定长度
	int Arr[5] = {[2] = 2};             // 指定初始化器

//------ 试探性声明 ------
int[] a;  // 行为被暂认为是 a = {0}
```

> *多维数组*

```c
int Arr[length0][length1];
int Arr[3][3][3][3];  //......多维数组
int Array[4][4] = {
	{1,2,3,4},
    {10,20,30,40},
    {100,200,300,400},
    {0,0,0,0}
}
int arr[2][3] = {1,2,3,4,5,6};  // 顺序初始化
```

> *结构中的伸缩型数组成员（C99）*

- C99 新增了一个特性：伸缩型数组成员（flexible array member），该结构的最后一个成员具有一些特性
- 该数组不会立即存在，使用这个伸缩型数组成员可以编写合适的代码，就好像它确实存在并具有所需数目的元素一样

```c
struct flex{
	int count;
	double average;
	double scores[];
// 伸缩型数组成员, 要求不声明大小, 必须是最后一个, 结构中至少有一个非伸缩数组成员
}
```

- 声明一个 ```struct flex``` 类型的结构变量时，不能用 ```flex.scores``` 做任何事，因为没有给这个数组预留存储空间
- C99 意图声明一个指向 ```struct flex``` 的指针, 然后用 ```malloc``` 分配足够的空间, 以存储 ```struct flex``` 结构的常规内容与伸缩型数组成员所需的额外空间
- 不可以将带有伸缩型数组的结构赋值给同类型结构变量

```c
struct flex * pf;
pf = malloc(sizeof(struct flex) + 5 * sizeof(double));
// 分配一个内含 5 个 double类型的数组的 flex
```

#### 指针类型

“指针声明” 可命名指针变量并指定该变量所指向的对象的类型。声明为指针的变量保留了一个内存地址；可以为任何基本、结构或联合类型、函数、数组和其他指针对象创建关联指针

指针的默认类型是 ```void*```，声明为指向 ```void``` 的指针的变量可用于指向任何类型的对象。除 ```char*``` 类型外，```void``` 指针转换为其他类型的指针时需要类型强制转换

指针类型可以是 ```const``` 和/或 ```volatile```，分别指定指针不能被程序本身修改，或指针可以被超出程序的控制范围的某进程以合法方式修改

在同一 CPU 架构下，不同类型的指针变量所占用的存储单元是相同的，但存放数据的变量因数据的类型不同，所占用的存储空间长度也不同。指针描述了数据在内存中的位置，标示了一个占据存储空间的实体，其特点是可对存储数据的变量地址进行操作

创建一个指针时，系统只分配了储存指针本身的内存，并未分配储存数据的内存。在使用指针之前，必须先用已分配的地址初始化它。之后才可以进行解引用的操作

```c
// 【&】地址运算符用于获取类型的内存地址
// 【*】解引用运算符用于获取指针变量指向地址的值
int number = 10;
int *pN = &number;

int rt = *pN;	// 10

// ---- 不可解引用未初始化的指针 ----
int * pt;	// 未初始化的指针，其值不确定
*pt = 5; 	// ERROR：未定义行为
```

> *按字节寻址系统（如 PC）*

- 变量的名称、地址和变量的值之间关系密切，指针获取变量的机器码地址，变量保存数据的类型，数据的类型决定了值在内存中的字节大小，在该内存位置保存变量的值。
- 普通变量把值作为基本量，把地址作为通过 ```&``` 运算符获得的派生量；而指针变量把地址作为基本量，把值作为通过 ```*``` 运算符获得的派生量。

> *指针与地址的关系*

- 指针的值是它所指向对象的地址。地址的表示方式依赖于计算机内部的硬件。
- 许多计算机（包括 PC 和 Mac）都是按字节编址，意思是内存中的每个字节都按顺序编号。
- 一个较大对象的地址（如 ```double``` 类型的变量）通常是该对象第一个字节的地址。
- 在指针前面使用 ```*``` 运算符可以得到该指针所指向对象的值。
- 指针加 1，指针的值递增它所指向类型的大小（以字节为单位）。

> *指针基本操作*

```c
#include <stdio.h>
int main(void)
{
	int urn[5] = { 100, 200, 300, 400, 500 };
	int* ptr1, * ptr2, * ptr3;
	ptr1 = urn;				// 把一个地址赋给指针
	ptr2 = &urn[2];			// 把一个地址赋给指针
	printf("pointer value, dereferenced pointer, pointer address : \n");
// 1. 解引用指针，以及获得指针的地址
	printf("ptr1 = %p, *ptr1 = %d, &ptr1 = %p\n", ptr1, *ptr1, &ptr1);
	printf("ptr2 = %p, *ptr2 = %d, &ptr2 = %p\n", ptr2, *ptr2, &ptr2);
// 2. 指针加法
	ptr3 = ptr1 + 4;
	printf("\nadding an int to a pointer:\n");
	printf("ptr1 + 4 = %p, *(ptr1 + 4) = %d\n", ptr1 + 4, *(ptr1 + 4));
// 3. 递增指针
	ptr1++;
	printf("\nvalues after ptr1++:\n");
	printf("ptr1 = %p, *ptr1 = %d, &ptr1 = %p\n", ptr1, *ptr1, &ptr1);
// 4. 递减指针
	ptr2--;
	printf("\nvalues after ptr2--:\n");
	printf("ptr2 = %p, *ptr2 = %d, &ptr2 = %p\n", ptr2, *ptr2, &ptr2);
	--ptr1; // 恢复为初始值
	++ptr2; // 恢复为初始值
	printf("\nPointers reset to original values:\n");
	printf("ptr1 = %p, ptr2 = %p\n", ptr1, ptr2);
// 5. 一个指针减去另一个指针
	printf("\nsubtracting one pointer from another:\n");
	printf("ptr2 = %p, ptr1 = %p, ptr2 - ptr1 = %td\n", ptr2, ptr1, ptr2 - ptr1);
// 6. 一个指针减去一个整数
	printf("\nsubtracting an int from a pointer:\n");
	printf("ptr3 = %p, ptr3 - 2 = %p\n", ptr3, ptr3 - 2);

	return 0;
}
/*
	pointer value, dereferenced pointer, pointer address :
	ptr1 = 010FFC9C, *ptr1 = 100, &ptr1 = 010FFC90
	ptr2 = 010FFCA4, *ptr2 = 300, &ptr2 = 010FFC84

	adding an int to a pointer:
	ptr1 + 4 = 010FFCAC, *(ptr1 + 4) = 500

	values after ptr1++:
	ptr1 = 010FFCA0, *ptr1 = 200, &ptr1 = 010FFC90

	values after ptr2--:
	ptr2 = 010FFCA0, *ptr2 = 200, &ptr2 = 010FFC84

	Pointers reset to original values:
	ptr1 = 010FFC9C, ptr2 = 010FFCA4

	subtracting one pointer from another:
	ptr2 = 010FFCA4, ptr1 = 010FFC9C, ptr2 - ptr1 = 2

	subtracting an int from a pointer:
	ptr3 = 010FFCAC, ptr3 - 2 = 010FFCA4
*/
```

> *指向结构的指针*

- 像指向数组的指针比数组本身更容易操控（如, 排序问题），指向结构的指针通常比结构本身更容易操控，在函数中传递结构指针比传递结构本身效率更高
- 在一些早期的 C 实现中，结构不能作为参数传递给函数，但是可以传递指向结构的指针
- 一些用于表示数据的结构中包含指向其他结构的指针

```c
struct book{
	int cost;
} bp;
struct book * pbook = &bp;
pbook->cost = 99;		// -> 访问指针关联结构成员，等价于 bp.cost

pbook->cost = (*pbook).cost = bp.cost
```

> *结构中的字符数组和字符指针*

```c
// 1. 字符串数组作为成员
struct name{
	char first[LEN];
	char last[LEN];
};
// 2. 字符指针作为成员
struct pname{
	char * first;
	char * last;
};
struct name veep = {"Talia", "Summers"};
struct pname treas = {"Brad", "Fallingjaw"};
```

- name 结构将两个固定大小的数组用于储存姓名, 字符串储存在结构内部
- pname 结构保存了两个指针变量, 它使用的是储存在别处的字符串 (字符串常量或数组中的字符串)
- 由于 pname 中的指针是未初始化的变量, 因此地址可以是任何值, 为其赋值可能会修改掉原有的程序数据, 直接赋值操作可能会导致程序的崩溃
- 因此，如果要用结构储存字符串，用字符数组作为成员比较保险。用指向 ```char``` 的指针也行，但是误用会导致严重的问题，可以预先使用 ```malloc``` 分配空闲内存。

> *指针和数组的关系*

- 数组标识符实质上指向了数组首元素的地址。数组内相邻元素地址对应关系：```&arr[n+1] = &arr[n]+1```
- 指针类型加 1 表示增加一个存储单元，对于组数表示下一个元素地址，而不是表示下一个字节地址，因此这就要求指针与指向对象类型相对应（例如，pti 的类型是 ```short``` 类型，```pti + 1```，其值每次递增 2 字节）
- 在数组中，定义 ```arr[n]``` 的含义是 ```*(arr + n)``` （其中 ```arr = &arr[0]```）

```c
int arr[10] = {99};
if (arr == &arr[0])
{
	// arr 值等于 &arr[0]
	printf("\n%d",*arr);	// 99
}

int *pArr = arr;
// 等价于
int *pArr = &arr[0];
```

> *指针表示法与数组表示法*

- 处理数组的函数实际上用指针作为参数，但是在编写这样的函数时，可以选择是使用数组表示法还是指针表示法。
- 对于 ```int Arr[Size]``` 数组，```*(Arr+i)``` 与 ```Arr[i]``` 等价，但指针表示法（尤其与增量运算符一起使用时）更接近于机器语言，编译时能够生成效率更高的代码

> *指向多维数组的指针*


```c
int main(void) {
	int(Arr[2])[3] = {		// 二维数组
		{1,2,3},
		{2,3,4}
	};
	int Arr1[] = { 1,2,3,4 };

	int* pr[2] = { Arr1, &Arr1[1] };	// pr 是一个包含两个指针元素的数组

	int(*pr1)[3] = Arr;				// pr1 指向一个内含两个 int 类型值的数组

	for (size_t i = 0; i < 2; i++)
	{
		printf("%p\n", pr1[i]);
		printf("%p\n", Arr[i]);
	}
}

// 对于 ```Arr[n][m][i][l]...``` 数组

int Arr[a][b][c][d];
int(*pr)[b][c][d] = Arr;

Arr[0][0][0][0] = ****pr = pr[0][0][0][0];
```

#### 字符串与字符串字面量

“字符串字面量” 是封闭在双引号内的源字符集中的字符序列，用于表示可一起构成以 ```\0``` 结尾的字符串的字符序列。宽字符串文本前需要添加 L 前缀。转义序列在字符串文本中仍然有效

> *字符串字面量的类型*

- 字符串字面量是具有 ```char``` 的类型数组（宽字符字符串是具有 ```wchar_t```  的类型数组）
- 文本字符串的字符将按顺序存储在连续内存位置，```null``` 字符（```\0```）自动追加到每个字符串并标记该字符串的末尾
- **编译器无法在两个不同的地址存储两个相同的字符串**，```/GF```（消除重复的字符串，编译器优化策略）强制编译器将相同字符串的单个副本置于可执行文件中。

```c
char *str1 = "Hello";
char *str2 = "Hello";

int main(void)
{
	printf("pStr1: %p\n",str1);
	printf("pStr2: %p\n",str2);
}
/*
pStr1: 0000000000404000
pStr2: 0000000000404000
*/
```

若要形成占用多行的字符串文本，则可以将两个字符串串联起来。为此，请键入反斜杠

```c
/* 串联一 */
"Long strings can be bro\
ken into two or more pieces."
  >>> 等价于
"Long strings can be broken into two or more pieces."

/* 串联二 */
char *string = "This is the first half of the string, "
               "this is the second half";
```

ANSI C 兼容性要求编译器在串联后接受字符串中最多 509 个字符。

Microsoft C 允许的字符串的最大长度约为 2048 个字节，若字符串由多个双引号部分构成，对于串联的每个行，预处理器会将一个额外的字节添加到总字节数。若使用行继续符（```\```）代替双引号，则预处理器不会为每个行添加一个额外字符

> *格式转换说明符*

```powershell
%a，%A      浮点数、十六进制数和p，P计数法（C99，C11）
%c          单个字符
%d          有符号十进制数
%e，%E      浮点数，e计数法
%f          浮点数，十进制
%g，%G      自动选择%f 或 %e
%i          有符号十进制整数
%o          无符号八进制整数
%p          指针
%s          字符串
%u          无符号十进制整数
%x，%X      无符号十六进制整数，使用十六进制数 0f，0F
%%          打印一个百分数符号 %
```

格式字符串中的转换说明一定要与后面的每个项相匹配，若忘记这个基本要求会导致严重的后果。如果只打印短语或句子，就不需要使用任何转换说明。

> *转换说明修饰符*

  在 ```%``` 和转换字符之间插入修饰符可修饰基本的转换说明。

```c
标记        -、+、空格、#、0，可以不使用标记或使用多个标记
数字        表示最小字段宽度

.数字       精度：%e、%E、%f转换表示小数位位数
                %g、%G转换表示有效数字的最大位数
                %s转换表示待打印字符的最大数量
                整型转换，表示待打印数字的最小位数
                只使用 . 表示其后紧随一个0, %.f 等同于 %.0f;

h           与整型转换说明一起使用，表示 (unsigned) short int
hh          与整型转换说明一起使用，表示 signed char 或 unsigned char
j           与整型，表示 intmax_t 和 uintmax_t 类型
l           与整型，表示 (unsigned) long int
ll          与整型，表式 (unsigned) long long int
L           与浮点型，表示 long double
t           与整型，表示 ptrdiff_t (两个指针差值)
z           与整型，表示 size_t 类型，为 sizeof 返回类型
```

```%zd```  返回的类型规定为无符号整数，不同系统中，可能使用 ```%u```，```%ul```，```%ull```

> *printf 中的标记*
 
 ```c
-       待打印项左对齐
+       显示数值符号，符号为正显示 +，符号为负显示 -
空格    有符号值若为正，在值前面显示前导空格；负则显示减号；+ 覆盖标记空格

%o      显示八进制前缀, 结果以 0 开始
%xX     显示十六进制前缀, 结果以 0x、0X 开始
%gG	    防止结果后面的 0 被删除(近似数)
%#      无数字，打印一个小数点字符
0       数值类型，用前导 0 代替空格填充字段宽度
整数    出现 - 左对齐标记或者指定精度，则忽略 0
```

> *格式输出案例*

- 字符宽度

```c
#include <stdio.h>
#define PAGES 959
int main(void)
{
    printf("*%d*\n", PAGES);
    printf("*%2d*\n", PAGES);
    printf("*%10d*\n", PAGES);
    printf("*%-10d*\n", PAGES);

    return 0;
}
/*
    *959*
    *959*
    *       959*
    *959       *
*/
```

- 一些浮点型修饰符的组合

```c
#include <stdio.h>
int main(void)
{
    const double RENT = 3852.99; // const变量
    printf("*%f*\n", RENT);
    printf("*%e*\n", RENT);
    printf("*%4.2f*\n", RENT);
    printf("*%3.1f*\n", RENT);
    printf("*%10.3f*\n", RENT);
    printf("*%10.3E*\n", RENT);
    printf("*%+4.2f*\n", RENT);
    printf("*%010.2f*\n", RENT);
    return 0;
}
/*
    *3852.990000*
    *3.852990e+03*
    *3852.99*
    *3853.0*
    *  3852.990*
    * 3.853E+03*
    *+3852.99*
    *0003852.99*
 */
```

- 一些格式标记

```c
#include <stdio.h>
int main(void)
{
    printf("%x %X %#x\n", 31, 31, 31);
    printf("**%d**% d**% d**%+d**\n", 42, 42, -42, 42);
    printf("**%5d**%5.3d**%05d**%05.3d**\n", 6, 6, 6, 6);
    return 0;
}
/*
    1f 1F 0x1f
    **42** 42**-42**+42**
    **    6**  006**00006**  006**
*/
```

- 字符串格式

```c
#include <stdio.h>
#define BLURB "Authentic imitation!"
int main(void)
{
	// 最小2宽度
    printf("[%2s]\n", BLURB);
	// 最小24宽度
    printf("[%24s]\n", BLURB);
    // 最小24宽度, 5字符宽度
	printf("[%24.5s]\n", BLURB);
	// 左对齐,最小24宽度,5字符宽度
    printf("[%-24.5s]\n", BLURB);
    return 0;
}
/*
    [Authentic imitation!]
    [    Authentic imitation!]
    [                   Authe]
    [Authe                   ]
*/
```

> *转换说明参数传递机制*

参数传递机制因实现而异
- 就 ```printf("%ld %ld %ld %ld\n", n1, n2, n3, n4)```，对于 ```float``` n1、n2，系统仍会将 ```float (4B)``` 转换成 ```double (8B)``` 储存在 stack 中，n3、n4 紧随压入栈中，
- ```%ld``` 转换说明，取参数读取栈中数据应读取 4 字节的 ```long``` 类型，但将 n1 的前半部分作为第一个参数，后半部分作为第二个参数。因此出现 ```printf``` 读错了字节导致转换说明出错。

---
### 复杂声明解释

#### 抽象声明符

抽象声明符是没有标识符的声明符，由一个或多个指针、数组或函数修饰符组成

指针修饰符 【```*```】 始终在声明符中的标识符前面

数组 【```[ ]```】 和函数 【```()```】 修饰符紧跟在标识符后面

抽象声明符常表示函数原型的形参或返回类型

```c
int *           指针声明
int *[3]        指向 int 的 3 个指针组成的数组
int (*) [5]     指向 5 个 int 类型数组的指针
int *()         一个没有参数说明的函数，返回一个指向 int 的指针
int (*)(void)   指向不接受实参并返回整型值的函数的指针
int (*const []) (unsigned int, ...)    特定函数类型 const 指针数组
```

#### 解释复杂的声明符

复杂声明符是由多个数组、指针或函数修饰符限定的标识，可以将数组、指针和函数修饰符的各种组合应用于单个标识符。通常 ```typedef``` 可用来简化声明

在解释复杂声明符时，方括号和圆括号（即，标识符右侧的修饰符）优先于星号（即，标识符左侧的修饰符）。方括号和圆括号具有相同的优先级并且都是从左到右关联

> *解释复杂声明符的一般步骤*

1. 从标识符开始并直接查找方括号或圆括号（如果有）的右侧。
2. 解释这些方括号或圆括号，然后查找星号的左侧。
3. 如果在任何阶段遇到一个右圆括号，请返回并将规则 1 和 2 应用于圆括号内的所有内容。
4. 应用类型说明符

> *解释复杂声明符*

```C
char *( *(*var)() )[10];
 ^   ^  ^ ^ ^   ^    ^
 7   6  4 2 1   3    5

/*
  1. 标识符 var 声明为
  2. 指向以下内容的指针
  3. 返回以下内容的函数
  4. 指向以下内容的指针
  5. 包含 10 个元素的数组，这些元素分别为
  6. 指向以下内容的指针
  7. char 值

TOTAL: 标识符 var 声明为 (指向 (返回 (指向 (包含 10 个元素的数组，
这些元素分别为 (指向 (char 值) 的指针) ) 的指针) 的函数) 的指针)
*/
```

#### 复杂的声明符举例

```c
int *var[5];		/* 声明为指向 int 的指针数组 */
int (*var)[5];		/* 声明为指向 int 数组的指针 */
long *var(long, long);		/* 声明为返回 long 指针的函数 */
long (*var)(long, long);	/* 声明为指向返回 long 的函数指针 */

struct both{
    int a;
    char b;
} (*var[5])(struct both, struct both);
/* 声明为指向返回结构 both 的函数的指针数组 */

struct both *var[5](struct both, struct both);
/* 非法：声明函数数组 */

unsigned int* (*const *name[5][10])(void);
/* 声明为指向常量指针的指针的二维数组，这些常量指针指向返回 unsigned int* 的函数 */

double (*var(double(*)[3]))[3];
/* 声明为返回指向包含 3 个 double 数组指针的函数，其形参是指向包含 3 个 double 数组的指针 */

union sign{
     int x;
     unsigned y;
} **var[5][5];
/* 声明为指向指针的指针二维数组，这些指针指向具有两个成员的联合的指针 */

union sign *(*var[5])[5];
/* 声明为一个五元素指针数组，数组元素指向联合的五元素指针数组 */
```

#### 不完整类型

**不完整类型** 是一种用于描述标识符但缺少确定该标识符的大小所需的信息的类型。不完整类型不能用于定义变量，但是用不完全类型定义指针或者引用是合法的

“不完整类型” 可以是：尚未指定其成员的结构类型、联合类型或未指定其维度的数组类型

在使用不完整类型前必须确保该类型被完成定义。```void``` 类型是无法完成的不完整类型，特殊用于函数的参数与函数返回等

> *不完整类型应用于*

- 指向不完整类型的指针
- 不完整类型的引用
- 不完整类型的 ```typedef``` 名称
- 返回不完整类型的函数和函数原型的抽象声明类型

#### 复合字面量

- C99 新增了复合字面量（Compound Literal）。字面量是除符号常量外的常量。
- 5 是 ```int``` 类型字面量，81.3 是 ```double``` 类型的字面量，```'Y'``` 是 ```char``` 类型的字面量，```"elephant"``` 是字符串字面量。
- 对于数组，复合字面量类似数组初始化列表，前面是用括号括起来的类型名

```c
  int arr[2] = {1,2};     // 常规数组声明
  (int[2]){1,2}   //复合字面量
  // (int[2])  即为数组复合字面量的类型名(匿名)
  // 也可省略数组大小     即 (int[]){1,2}
```

- 因为复合字面量是匿名的，所以不能先创建然后再使用它，必须在创建的同时使用它
- 也可使用指针记录地址  >>  ```int* ptr = (int[2]){1,2}```
- 多维复合字面量: ```(int[2][1]){{1},{2}}```

```c
fun((int[2]) { 10,20 }, 3);

void fun(int* arr, int size) {
	for (size_t i = 0; i < size; i++)
	{
		printf("%d", arr[i]);
	}
}
```

- 复合字面量是提供只临时需要的值的一种手段。复合字面量具有块作用域，这意味着一旦离开定义复合字面量的块，程序将无法保证该字面量是否存在。


---
### 类型初始化

#### 初始化标量类型

> *初始化任何类型的变量，遵循的下列规则*

- 在文件范围级别声明的变量可初始化，未显示初始化的外部级别变量将自动初始化为 0，指针类型分配为 ```null``` 指针（其值为 0）
- 常数表达式可用于初始化使用 ```static``` 声明的任何全局变量
- 使用 ```auto``` 或 ```register``` 存储类说明符声明的变量在每次执行控制传递给声明它们的块时进行初始化
- 在 ```auto``` 或 ```register``` 变量的声明中省略初始值设定项，则变量的初始值是未定义的（栈存储的特征，它的值是包含之前定义的值的任何表达式，甚至是函数调用）
- 外部变量声明和所有 ```static``` 变量（无论是外部还是内部变量）的初始值必须是常数表达式，```auto``` 变量的地址不能用作静态初始值设定项，因为它不是常量
- 如果标识符的声明具有块范围，并且标识符具有外部链接，则该声明不能具有初始化（函数或结构、枚举、联合的模板声明）

#### 初始化聚合类型

聚合类型是结构、联合或数组类型。如果聚合类型包含聚合类型的成员，则初始化规则将以递归方式进行。

> *聚合对象的初始化列表*

- 初始化列表是一个用逗号分隔的初始值设定项的列表，列表的每个初始值设定项是常量表达式或内嵌初始值设定项列表。
- 对于每个初始值设定项列表，常量表达式的值将按顺序赋给聚合变量的相应成员
- 列表具有的值少于聚合类型时，聚合的其余成员会初始化为 0（指针为 ```null```）；列表具有的值多于聚合类型会导致错误
- 未显式初始化的自动标识符的初始值是不确定的

> *聚合类型初始时的规则*

- 结构的初始值设定项要么是同一类型的表达式，要么是其成员包含在大括号 ```{ }``` 中的初始值设定项的列表。未命名的位域成员是未初始化的
- 如果数组的大小未知，则初始值设定项的数目将确定数组的大小
- 初始化器列表不能为空

> *嵌套的初始化设定项列表*

```c
int P[4][3] =
{
    { 1, 1, 1 },
    { 2, 2, 2 },
    { 3, 3, 3,},
    { 4, 4, 4,},
};
```

如果聚合成员没有嵌入的初始值设定项列表，则只会按顺序将值赋给子聚合的每个成员

```c
int P[4][3] =
{
   1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4
};
```

> *联合的初始化设定项列表*

```c
union
{
    char x[2][3];
    int i, j, k;
} y = {
	{
        {'1'},
        {'4'}
    }
};
```

- 该联合的第一个元素是数组，因此该初始值设定项是聚合初始值设定项。
- 初始值设定项列表 {'1'} 将值赋给数组的第一行。由于列表中仅显示一个值，因此，第一列中的元素将初始化为字符 1，而该行中的其余两个元素将初始化为值 0（默认值）。
- 同样，x 的第二行的第一个元素将初始化为字符 4，而该行中的其余两个元素将初始化为值 0

#### 初始化字符串

可以使用字符串文本（或宽字符串文本）初始化字符（或宽字符）的数组

```c
char code[ ] = "abc";
// 等同于
char s[]  = {'a', 'b', 'c', '\0'};
```

标识符列表的长度值只能与要初始化的标识符的数量相同。如果指定短于字符串的数组大小，则会忽略多余字符

```c
// 只有初始值设定项的前三个字符将分配给 code，字符 d 和字符串终止 null 字符将被丢弃
char code[3] = "abcd";
// 等同于
char s[3] = {'a', 'b', 'c'};
```

---
### typedef 声明

使用 ```typedef``` 声明为已由 C 定义的类型或用户自定义类型构造更短和更有意义的名称。

```typedef``` 声明不会创建类型，而是创建现有类型的同义词或可通过其他方式指定的类型的名称

当使用 ```typedef``` 名称作为类型说明符时，可以将其与特定的类型说明符组合，但不可以将其与其他类型说明符组合。可接受的修饰符包括 ```const``` 和 ```volatile。```

```typedef``` 与通常标识符（例如枚举项、变量或函数）共享命名空间

```c
typedef void fv(int), (*pfv)(int);

void (*signal(int, void(*) (int)))(int);
// use fv
fv* signal(int, fv*);
// use pfv
pfv signal(int, pfv);
```

> *typedef 实例*

```c
// 定义声明
typedef struct{
	int count;
	float cost;
} book;
// 声明类型对象
book mbook = {.count = 10,.cost = 10* 1.5f};

// const 说明
typedef char* const ConstString;	// 指向常量字符串的指针
ConstString str = "HelloWorld";
typedef const char* ConstpStr;		// 指向字符串的常量指针
```

> *typedef 声明 VLA 数组*

对 VLA 的 ```typedef``` 只能出现在块作用域内，数组长度会在每次控制流经过 ```typedef``` 声明时求值

```c
void F(int n){
    typedef int Array[n];	// Array 是 VLA ，其长度为 n ，现在求值
    n += 1;
    Array a; 				// a 的长度是 +=1 前的 n
    int b[n]; 				// a 和 b 长度不同
}
```

---
### 属性说明符（C23）（未整理完成）

- 对类型、对象、表达式等引入实现定义的属性。属性为各种由实现定义的语言扩展（例如 GNU 与 IBM 的语言扩展 ```__attribute__((...))```，微软的语言扩展 ```__declspec()``` 等）提供了统一化的语法
- 属性可用在 C 程序中的几乎所有位置，而且可应用于几乎所有事物：类型、变量、函数、名字、代码块、整个翻译单元

#### attribute

#### declspec

#### C23 标准

```c
[[attr]]
[[attr1, attr2, attr3(args)]]
[[属性前缀::attr(arg)]]
[[属性前缀::attr]]
/*
标准属性			例如 [[fallthrough]]
属性前缀::标识符	有命名空间的属性，例如 [[gnu::unused]]，C++
标准属性(实参列表)	有实参的标准属性
属性前缀::标识符(实参列表)
*/
```

#### deprecated 弃用

```c
[[deprecated]]
[[deprecated("reason")]]

[[deprecated("Use NewFun instead.")]]
void Fun(void);
```

指示允许使用声明有此属性的名称或实体，但因 reason 而不鼓励使用
声明时未弃用的名字可被重声明为 deprecated。声明为 deprecated 的名字不能通过重声明它而不带此属性变为未弃用

#### fallthrough 贯穿抑制警告

指示从前一标号直落是有意的，而在发生贯穿（直落）时给出警告的编译器不应诊断它。仅可用于 switch 语句中，指示从前一标号直落是有意的，而在发生直落时给出警告的编译器不应诊断它

```c
[[fallthrough]]
[[__fallthrough__]]

switch (n) {
    case 1:
    case 2:
      g();
     [[fallthrough]];
    case 3: 	// 贯穿时不警告
      h();
    case 4: 	// 编译器可在发生贯穿时警告
	  if(n < 3) {
          i();
          [[fallthrough]]; 	// OK
      }
      else {
          return;
      }
    case 5:
      while (false) {
        [[fallthrough]]; 	// 谬构：下一语句不是同一迭代的一部分
      }
    case 6:
      [[fallthrough]]; 		// 谬构：下一语句不是同一迭代的一部分
}
```

#### nodiscard 弃值表达式警告

- 出现于函数声明、枚举声明或结构体/联合体声明
- 若从转型到 void 以外的弃值表达式（调用声明为 nodiscard 的函数，或调用返回声明 nodiscard 的结构体/联合体/枚举的函数）则鼓励编译器发出警告
- 弃值表达式，返回值放弃接收

```c
[[nodiscard]]
[[__nodiscard__]]	(1)
[[nodiscard(字符串字面量)]]
[[__nodiscard__(字符串字面量)]]

struct [[nodiscard]] S {int status;};
struct S returnStruct(){
	return (struct S){0};
}

[[nodiscard("No Discard")]] int Mrix(int a, int b){
	return a ^ b;
}

int main(void){
	returnStruct(); /* warning */
	int rt = Mrix(1,2);	/* legal */
}
```

#### maybe_unused 抑制对未使用实体的警告

若编译器对未使用实体发布警告，则对任何声明为 maybe_unused 的实体抑制该警告

```c
[[maybe_unused]]
[[__maybe_unused__]]
```

#### noreturn 函数不返回调用方

函数被调用后，控制权不返回调用方。_Noreturn 函数说明符被弃用。应该用 `[[noreturn]]` 属性代替。宏 noreturn 亦被弃用（C23）

```c
[[noreturn]]  /* 同 _Noreturn */
```

---