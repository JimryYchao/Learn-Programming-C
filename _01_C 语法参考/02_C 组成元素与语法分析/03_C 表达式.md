## C 表达式

---
### 操作数与表达式

“操作数” 是运算符作用于的实体。“表达式” 是用于执行以下操作的任意组合的一系列运算符和操作数：计算值、指定对象或函数、生成副作用（对数据对象或文件的修改）。
C 中的操作数包括常量、标识符、字符串、函数调用、下标表达式、成员选择表达式以及通过将操作数与运算符组合或将操作数括在括号中而形成的复杂表达式。

#### 左值与右值表达式

数据对象：用于储存值的数据存储区域统称为数据对象（data object）。

> *左值*

- 引用内存位置的表达式称为 “左值” 表达式，可以出现在等号 (```=```) 的左侧。
- 左值（lvalue）用于标识特定数据对象的名称或表达式，通常是标识符。可修改的左值不能具有数组类型、不完整类型或包含 ```const``` 特性的类型。
- 要使结构和联合成为可修改的左值，它们必须没有任何包含 ```const``` 特性的成员。
- 标识符的名称表示存储位置，而变量的值是存储在该位置的值。

> *左值表达式*

- 整型、浮点、指针、结构或联合类型的标识符；
- 计算结果不为数组的下标 (```[ ]```) 表达式；
- 成员选择表达式（```->``` 或 ```.```）；
- 不引用数组的一元间接寻址 (```*```) 表达式；
- 包含在括号内的左值表达式；
- ```const``` 对象（不可修改的左值）。

> *右值*

- 术语 “右值” （rvalue）有时用于描述表达式的值以及将其与左值区分开来。所有左值都是右值，但并不是所有右值都是左值。

> *Microsoft C 专用*

- Microsoft C 包括对 ANSI C 标准的扩展，该扩展允许将左值的转换用作左值，只要对象的大小不通过转换来扩展即可。使用 ```/Za``` 编译器选项禁用这些扩展。

```c
char *p ;
short  i;
long l;

(long *) p = &l ;       /* Legal cast   */
(long) i = l ;          /* Illegal cast */
```

#### 常量表达式

常量表达式将在编译时而不是运行时计算，并且可在可使用常量的任何位置使用。常量表达式的计算结果必须是位于该类型的可表示值范围内的常量。
常量表达式的操作数可以是整数常量、字符常量、浮点常量、枚举常量、类型强制转换、```sizeof``` 表达式和其他常量表达式。

#### 表达式计算

涉及赋值、一元递增、一元递减或调用函数的表达式可能具有其计算附带的结果（副作用）。
“副作用” 是由表达式的计算引起的更改。只要表达式计算更改变量的值，就会出现副作用。所有赋值运算都具有副作用。

> *副作用*

表达式的计算顺序由特定实现定义，函数调用的参数可按任意顺序进行计算。

```c
add( i + 1, i = j + 2 );
/*
	表达式 i + 1 可以在 i = j + 2 前计算，
	或者 i = j + 2 可以在 i + 1 前计算，每种情况下的结果都不同
*/

x[i] = i++;
/*
	修改后的 x 值不可预知。 下标的值可以是 i 的新值或旧值。
	结果因编译器或优化级别而异
*/
```

> *C 序列点*

在表达式计算过程中，当达到 “序列点” 时，确保对序列点后面的任何内容执行计算之前已计算序列点前面的所有内容（包括任何副作用）。完全计算当前序列点时，在继续下一个序列点之前将完成当前的所有副作用。在连续的 “序列点” 之间，仅能通过表达式修改一次对象的值。

C 定义的序列点：
  - 逻辑 “与” 运算符 (```&&```) 的左操作数：左操作数结果为 ```false```，则不计算右操作数。
  - 逻辑 “或” 运算符 (```||```) 的左操作数：左操作数结果为 ```true```，则不计算右操作数。
  - 逗号运算符的左操作数：完全计算逗号运算符的左操作数，并在继续之前完成所有副作用。
  - 函数调用运算符：在输入函数前完成所有副作用。函数参数之间的计算顺序不确定。
  - 条件运算符的第一个操作数。
  - 完全初始化表达式的末尾。
  - 表达式语句中的表达式。
  - 选择语句（```if``` 或 ```switch```）中的控制表达式：完全计算该表达式，并在执行依赖于选择的代码之前完成所有副作用。
  - ```while``` 或 ```do``` 语句的控制表达式，```for``` 的三个表达式：下一个迭代之前。
  - ```return``` 语句中的表达式：完全计算该表达式，并在控制返回调用函数之前完成所有副作用。

>---
### 运算符

#### 算数运算符

```c
// 1. 赋值运算符
	int num1 = 1;
	int num2,num3,num4;
	num2 = num3 = num4 = num1;
// 2. 加法运算符
	num2 = num2 + num1;
	num2 += num1;
// 3. 减法运算符
	num3 = num3 - num1;
	num3 -= num1;
// 4. 乘法运算符
	num4 = num4 * num1;
	num4 *= num1;
// 5. 除法运算符
	num5 = num5 / num1;
	num5 /= num1;
// 6. 取余运算符
	num6 = num6 % num1;
	num6 %= num1;
// 7. 递增递减运算符
	num7++;
	++num7;
	num7--;
	--num7;
```

- 递增递减运算符的操作数必须具有原子、限定或非限定的实数或指针类型，并且必须是可修改的左值。
- 每个操作数都应具有算数类型，`%` 运算符的操作数应为整数类型。如果任一操作数具有十进制浮点类型，则另一个操作数不应具有标准浮点类型、复数类型或虚数类型。整数除法的结果是代数商，小数部分被丢弃。

<br>

#### sizeof

```sizeof``` 运算符提供了存储操作数或表达式的类型的对象所需的存储空间量（以字节为单位），返回类型是 ```size_t```。`sizeof` 的操作数不能是函数类型或不完整类型的表达式。

 ```c
	size_t num_size = sizeof num;
	size_t num_size = sizeof(num);
	size_t i_size = sizeof(int);
	size_t i_size = sizeof int;
```

```sizeof``` 运算符的操作数是不求值的表达式（除非它们是 VLA） (C99 起)。例如 ```size_t n = sizeof(printf("%d", 4));``` 不会进行控制台输出。

<br>

#### typeof

```typeof``` 是 GUN C 提供的一种特性，可以取得变量的类型，或者表达式的类型；需要引用 ```stdlib.h```。

> *获取函数的返回类型*

```c
#include <stdio.h>
#include <stdlib.h>

double (*Func(double (*)[3]))[3];
double (*Func(double (*DArr)[3]))[3]
{
	double(*Arr)[3] = (double(*)[3])malloc(3 * sizeof(double *));
	for (size_t i = 0; i < 2; i++)
		for (size_t j = 0; j < 3; j++)
			Arr[i][j] = DArr[i][j] + 10.0;
	return Arr;
}

int main(void)
{
	static double arr[2][3] = {1.0, 2.1, 3.2, 1.1, 2.2, 3.3};
	double(*DArr)[3] = arr;
	typeof(Func(NULL)) rt;	// 反射获取函数的返回类型

	rt = Func(DArr);

	printf("%p\n", rt);

	for (size_t i = 0; i < 2; i++)
		printf("%p %.2f\n", rt[i], rt[i][0]);
	return 0;
}
```

> *在宏定义中动态获取相关结构体成员的类型*

```c
#define max(x, y) ({                \
    typeof(x) _max1 = (x);          \
    typeof(y) _max2 = (y);          \
    (void) (&_max1 == &_max2);      \
    _max1 > _max2 ? _max1 : _max2; })

int main(int argc, char *argv[])
{
	int a = 3;
	int b = 4;
	int r = max(a, b);

	printf("r:%d\n", r);
	return 0;
}
/* a,b 类型不一致时编译时将发出警告 */
```

<br>

#### 对齐 alignas 和 alignof

对齐：C 的低级功能之一是能够指定内存中对象的精确对齐方式，以最大限度利用硬件体系结构。当数据存储在成倍数据大小的地址中时，CPU 会更有效地读取和写入内存。例如，如果数据存储在倍数为 4 的地址中，则会更有效地访问 4 字节整数。如果数据未对齐，则 CPU 需要执行更多地址计算工作来访问数据。
将常用数据与处理器的缓存行大小对齐，可以提高缓存性能，编译器通常在基于目标处理器和数据大小的自然边界上对齐数据。

> *alignas*

使用 ```alignas``` 或 ````_Alignas```` 来指定变量或用户定义类型的自定义对齐方式。它们可以应用于结构、联合、枚举或变量。

```c
#include <stdalign.h>

alignas(TYPE_SIZE) <type> <identifier>
_Alignas(TYPE_SIZE) <type> <identifier>
```

```_Alignas``` 不能在 ```typedef```、位域、函数、函数参数或使用 ```register``` 寄存器说明符声明的对象的声明中使用。
指定幂为 2（如 1、2、4、8、16 等）的对齐方式。不要使用小于类型本身大小的值。
```struct``` 和 ```union``` 类型的对齐方式与任何成员的最大对齐方式相等。在 ```struct``` 中添加填充字节，以确保满足各个成员的对齐要求。

> *alignof*

```_Alignof``` 和别名 ```alignof``` 返回指定类型的对齐方式（以字节为单位）。它返回类型为 ```size_t``` 的值。`alignof` 的操作数不能是函数类型或不完整类型。

 ```c
#include <stdalign.h>

alignof(type);
_Alignof(type);
```

> *对齐实例*

- ```alignas``` / ```_Alignas``` 设置对齐特性。
- ```alignof``` / ```_Alignof``` 获取对齐特性。

```c
#include <stdalign.h>

typedef struct{
	int value;
	alignas(32) char alignedMemory[32];
} cache;

int main(void)
{
	printf("sizeof(cache): %zd\n", sizeof(cache)); 	// 64
    printf("alignof(cache): %zd\n", alignof(cache)); // 32

	return 0;
}
```

<br>

#### 类型转换运算

- 升级（promotion）：较小类型转换成较大类型。
- 降级（demotion）：把一种类型转换成更低级别的类型。

通常，在语句和表达式中应使用类型相同的变量和常量。但是，如果使用混合类型，C 会采用自动类型转换规则。

> *类型级别的顺序（降序）*

```long double```、```double```、```float```、```unsigned long long``` 或 ```long long```、```unsigned long``` 或 ```long```、```unsigned int``` 或 ```int```、`unsigned short` 或 `short`。

> *待赋值的值与目标类型不匹配时*

目标类型是无符号整数，且待赋的值是整数时，额外的位将被忽略（目标类型是 8 位 ```unsigned char```，待赋的值是原始值求模 256）。
如果目标类型是一个有符号整型，且待赋的值是整数，结果因实现而异；如果目标类型是一个整型，且待赋的值是浮点数，该行为是未定义的。当浮点类型被降级为整数类型时，原来的浮点值会被截断。

> *强制类型转换符*

 ```c
  // (type) value
  int num;
  long long num1 = 10000000000L;
  long long num2 = 10000000000L;
  num = (int)num1 + (int)num2;
```

> *指针显式转换规则*

- 任何整数能被转型到任何指针类型，结果可能对齐不准确，可能不指向所引用类型的对象。
- 任何指针类型可以被转型到任何整数类型。
- 任何指向对象的指针能被转型成指向任何其他对象类型的指针。若其值未为目标类型正确对齐，则行为未定义。
- 任何指向函数的指针能被转型成指向任何其他函数类型的指针。若转换结果指针回原类型，则它与原值比较相等。若将转换所得指针用作函数调用，则行为未定义（除非函数类型兼容）。
- 在指针间转换（指向对象或指向函数的）时，若原值是其类型的空指针值，则结果是目标类型的正确空指针值（null to null）。

> *不建议的指针转换*

- 没有指针和浮点类型间的转换。
- 没有指向函数指针和指向对象指针（含 void* ）间的转换。（**```PS```**：函数指针与对象指针间的转换被许多编译器作为扩展接受。）

```c
// 检验对象表示是转型的合法使用
    double d = 3.14;
    printf("The double %.2f(%a) is: ", d, d);
    for(size_t n = 0; n < sizeof d; ++n)
        printf("0x%02x ", ((unsigned char*)&d)[n]);
/* Output：
	The double 3.14(0x1.91eb851eb851fp+1) is: 0x1f 0x85 0xeb 0x51 0xb8 0x1e 0x09 0x40
*/
    struct S {int x;} s;
//  (struct S)s; 	// 错误；非标量类型，尽管转型到相同类型什么都不做
    (void)s; 		// 转换任何类型到 void 都合法
```

> *严格别名使用*

  给定一个拥有有效类型 T1 的对象，使用相异类型的 T2 左值表达式（典型的是解引用指针）访问它是未定义行为，除非：
  - T2 和 T1 是兼容类型。
  - T2 是与 T1 兼容的类型的 cvr 限定版本。
  - T2 是与 T1 兼容的类型的有符号或无符号版本。
  - T2 是聚合体或联合体类型，其成员中包含一个前述 T1 类型（包括子聚合体或被包含联合体的成员）。
  - T2 是字符类型（```char```、```signed char``` 或 ```unsigned char``` ）。

```c
int i = 7;
char* pc = (char*)(&i);
if(pc[0] == '\x7') {
// 通过 char 别名使用是允许的
    puts("This system is little-endian");
} else {
    puts("This system is big-endian");
}

float* pf = (float*)(&i);
float d = *pf;
// ERROR： float 左值 *pf 不能用来访问 int

struct S { int a, b; };
// int* 和 struct S* 可以别名使用，因为 S 拥有 int 类型的成员
```

<br>

#### 关系与相等运算符

```c
  <   	小于
  <=  	小于等于
  >   	大于
  >=  	大于等于
  ==  	相等
  !=  	不等
```

关系运算符用于构建控制语句中的条件判断表达式（关系表达式）。关系表达式 **不能用于比较字符串的大小，不能自动比较结构体对象**。不能用关系运算符比较复数和虚数。由于浮点数精度的问题, 比较浮点数的大小尽量使用 `<` 和 `>` , 使用 ```fabs()``` 函数返回浮点值的绝对值。
关系表达式的返回值：返回非 0 （例如 1）表示 ```true```，返回 0 表示 ```false```。

如果任一操作数具有十进制浮点类型，则另一个操作数不应具有标准浮点类型、复数类型或虚数类型。

> *关系运算符优先级*

- 高优先级: <、<=、>、>=
- 低优先级: ==、!=

> *指针比较*

若 lhs 和 rhs 是指针类型表达式，则它们必须都是指向兼容类型对象的指针，除了忽略被指向对象上的限定:
  - 指向非数组元素的指针被当做如同它是指向有一个元素的数组的首元素的指针；
  - 若二个指针指向同一对象，或都指向同一数组的中的同一位置，则它们比较相等；
  - 若二个数组指向同一数组的不同元素，则指向有较大下标的元素的指针比较大于另一者；
  -	若二个指针指向同一结构体的成员，则指向结构体声明中较后声明的成员的指针，比较时大于指向较先声明的成员的指针；
  - 指向同一联合体成员的指针比较相等；
  - 所有其他指针比较引起未定义行为。

> *浮点数比较*

- IEEE-754 标准规定了浮点数存储的格式，浮点数的存储存在精度误差的问题。例如一个浮点数与 0.0 比较不能简单的使用 ```==```，实质上可以依靠 ```EPSILON``` （较小的正数）。```EPSILON``` 被规定为是最小误差。
- 如果正数 d 小于 ```EPSILON```，那么 d 和 1.0 相加，计算机就认为还是等于 1.0。

```c
#include <math.h>
#include <float.h>
/* 浮点数 D 与 0 作比较 */

if(fabs(D - 0.0) < DBL_EPSILON)
	puts("D 与 0.0 相等");
```

<br>

#### 逻辑运算符

```c
    &&      与
    ||      或
    !       非
```

逻辑运算符的结果类型是 `int`。每个操作数都应具有标量类型。

> *运算法则*

```c
    true && true = true
    false && false = false
	false && true = false

    true || false = true
	true || true = true
    false || false = false

	!false = true
```

> *优先级*

非 ( ```!``` ) > 与 ( ```&&``` ) > 或 ( ```||``` )

> *短路机制*

当 ```&&``` 左侧不满足结果为 ```true``` 的条件时，右侧表达式不会被计算。
当 ```||``` 左侧满足结果为 ```true``` 时，右侧表达式不会被计算。

<br>

#### 条件运算符

  C 提供条件表达式（conditional expression）作为表达 ```if-else``` 语句的一种便捷方式，该表达式使用 ``` ? : ``` 条件运算符。

```C
x = condition ? expression-true : expression-false

//等价于
if(condition)
	x = expression-true;
else
    x = expression-false;
```

第一个操作数应具有标量类型。第二和第三操作数 ```expression-true``` 和 ```expression-false```，仅允许下列表达式：
  - 两个任何算术类型的表达式；
  - 两个相同结构体或联合体类型的表达式；
  - 两个 ```void``` 类型表达式；
  - 两个指针类型表达式，指向兼容的类型，忽略 `const`、`volatile`、`restrict` 限定符；
  - 两个操作数都有 `nullptr_t` 类型；
  - 一个表达式是指针而另一个是空指针常量（例如 ```NULL```，`nullptr_t` ）；
  - 一个表达式是指向对象指针而另一个是指向 ```void``` 的限定或非限定版本的指针。
  - 如果第二个或第三个操作数中的任何一个具有十进制浮点类型，则另一个操作数不应具有标准浮点类型、复数类型或虚数类型。

<br>

#### 顺序计算运算符（逗号运算符）

逗号运算符按从左到右的顺序计算其两个操作数。该运算的结果与右操作数具有相同的值和类型。

```c
int a = 1, b = 2;
int num = (a++, a+b);

/* 求解过程
	1. 计算 a++
	2. 计算 a+b
	3. a+b 的值赋值给 num
*/
```

<br>

#### 位运算符

##### 二进制数的表示

> *二进制数与有符号整数*

十进制与二进制之间的转换。

```powershell
123 = 2^6 + 2^5 + 2^4 + 2^3 + 2^1 + 2^0
123(10) = 01111011(2)
```

> *二进制整数*

通常，1 字节包含 8 位。C 语言用字节（byte）表示储存系统字符集所需的大小，所以 C 字节可能是 8 位、16 位或其他值。

```powershell
            高阶位----------------------低阶位
位编号 >>>>>  7   6   5   4   3   2   1   0
            | 0 | 1 | 0 | 0 | 1 | 0 | 0 | 0 |
位值   >>>>> 128  64  32  16  8   4   2   1

      # 该表示的数值是 64 + 8 = 72
```

该位可以表示的范围是 ```0b00000000 ~ 0b11111111```，根据不同的方式解释位组合 (bit pattern)。
通常 ```unsigned char``` 用 1 字节表示的范围是 0～255，而 ```signed char``` 用 1 字节表示的范围是 -128～+127。

> *有符号整数*

二进制下如何表示有符号整数取决于硬件，而不是 C 语言。
一种方式是将高阶位的 0 表示正数, 1 表示负数，符号位之后的所有位表示数字，8 位能够表示的范围是 -127～+127。但是有两个 +0 和 -0 的现象。
另一种是二进制补码（two’s-complement）方法，是当今最常用的系统。二进制补码用 1 字节中的后 7 位表示 0～127，高阶位设置为 0。二进制补码符号判定与第一种方式相同，但区别在于如何确定负值。
二进制补码确定负值的量：从一个 9 位组合 100,000,000（256 的二进制形式）减去一个负数的位组合，结果是该负值的量，可以表示的范围是 -128~127。

```powershell
# 第一种方式
    00000000 与 10000000 分别表示 +0 与 -0，
    # 能表示的范围是 11111111(-127) ~ 01111111(127)

# 第二种方式
    1. 对于一个负值的位组合 10000000 (无符号表示为 128)
    2. 但 10000000 有符号时表示一个负数
    3. 100000000(补码) - 10000000 = 10000000 (确定负数的值 128)
    # 因此这个二进制表示的数为 -128

       100000000
     -  10101101    10101101 表示为十进制
    --------------	>>>>   -(2^6+2^4+2^1+2^0)
        1010011
```

第三种方式是二进制反码（one’s-complement），通过反转位组合中的每一位形成一个负数，如 00000001 为 1，则 11111110 是 -1。这种方法也有一个 −0：11111111。该方法能表示 -127～+127 之间的数。

> *其他进制数*

计算机界通常使用八进制记数系统和十六进制记数系统。八进制（octal）是指八进制记数系统；十六进制（hexadecimal 或 hex）是指十六进制记数系统（0-9, A-F = 10~15）。

```powershell
# 八进制	0451(8)
	4*8^2 + 5*8^1 + 1*8^0 = 297(10)
# 八进制与二进制之间的转换
	0 >>> 000		4 >>> 100
	1 >>> 001		5 >>> 101
	2 >>> 010		6 >>> 110
	3 >>> 011		7 >>> 111

	0173(8) >>> 0000,0111,1011(2)

# 十六进制	A3F(16)
	10*16^2 + 3*16^1 + 15*16^0 = 2623(10)
# 十六进制和等价的二进制
	0 >>> 0000		8 >>> 1000
	1 >>> 0001		9 >>> 1001
	2 >>> 0010		A >>> 1010
	3 >>> 0011		B >>> 1011
	4 >>> 0100		C >>> 1100
	5 >>> 0101		D >>> 1101
	6 >>> 0110		E >>> 1110
	7 >>> 0111		F >>> 1111
```

##### 按位运算符

按位运算符都用于整数类型，包括 ```char```。按位（bitwise）运算，这些操作都是针对每一个位进行，不影响它左右两边的位。按位运算符除按位取反 ```~``` 均支持复合运算。

```powershell
# 1. 按位取反: 1->0, 0->1
	~(10010101) = 01101010
# 2. 按位与:  1&1=1, 0&0=0, 1&0=0
	11010110 & 01101011 = 01000000
# 3. 按位或:  1|1=1, 0|1=1, 0|0=0
	10101110 | 01001010 = 11101110
# 4. 按位异或: 1^1=0，0^1=1 0^0=0
	10101101 ^ 01011101 = 
	
# 5. 复合赋值
	a &= 1;     // a = a & 1;
	a |= 1;		// a = a | 1;
	a ^= 1;		// a = a ^ 1; 
```

##### 移位运算符

左移运算符（```<<```）将其左侧运算对象每一位的值向左移动其右侧运算对象指定的位数，左侧运算对象移出左末端位的值丢失，用 0 填充空出的位置。

```c
	(10110100) << 2
  10 110100__          高位丢失，低位 0 补齐
	 11010000

>>>> 10110100 << 2 = 11010000
>>>> val <<= 2  >>>>  val = val << 2
```

右移运算符（```>>```）将其左侧运算对象每一位的值向右移动其右侧运算对象指定的位数。左侧运算对象移出右末端位的值丢失。对于无符号数，用 0 补齐高位空出的地方；对于有符号数，其结果取决于机器。空出的位置可用 0 填充，或者用符号位（即，最左端的位）的副本填充。

```powershell
# 有符号值表示
	(10001010) >> 2
	(00100010) 		# 在某些系统中的结果值, 0 填充
	(10001010) >> 2
	(11100010) 		# 在另一些系统上的结果值, 符号位 1 填充

# 无符号值表示
	(10001010) >> 2
	(00100010) 		# 所有系统都得到该结果值
```

移位运算符针对 2 的幂提供快速有效的乘法和除法：

```powershell
	number << n    # number 乘以 2 的 n 次幂
	number >> n    # 如果 number 为非负，则用 number 除以 2 的 n 次幂
```

移位运算符的复合赋值：

```c
	a >>= 1;   // a = a >> 1;
	a <<= 1;   // a = a << 1;
```

<br>

#### 替用运算符（iso646.h）

```c
&&		and
&=		and_eq
&		bitand
|		bitor
~		compl
!		not
!=		not_eq
||		or
|=		or_eq
^		xor
^=		xor_eq
```

>---
### 位运算应用

#### 掩码

按位与运算符常用于掩码（mask）。所谓掩码指的是一些设置为开（1）或关（0）的位组合。

> *掩码操作*

1. 假定符号常量 MASK 为 2（00000010）。
2. ```flags &= MASK```：表示将 flags 除 1 号位以外的所有位都设置为 0（无论 flags 的一号位是 0 或 1，其他位都会变成 0）。
3. 把掩码中的 0 看作不透明，1 看作透明，表达式 ```flags & MASK``` 相当于用掩码覆盖在 flags 的位组合上，只有 MASK 为 1 的位才可见。

```powershell
# flags &= MASK >>>>>>> 将非 1 位清 0
	MASK  >>>  00000010  >>>  ______1_
	按位与         &
	flags >>>  10010110  >>>  10010110
	             掩码
	flags >>>  ______1_  >>>  00000010
```

<br>

#### 打开位(设置位)

有时，需要打开一个值中的特定位，同时保持其他位不变。

```powershell
# flags |= MASK >>>>>>> 将 1 位设置为 1
	MASK  >>>  00000010  >>>  ______1_
	按位或	       |
	flags >>>  10101001  >>>  10101001
	            打开位
	flags >>>  ______1_  >>>  10101011
```

<br>

#### 关闭位(清空位)

```powershell
# flags &= ~MASK >>>>>>> 将 1 位关闭为 0
	MASK  >>>  10110110
	按位取反       ~
	MASK  >>>  01001001  >>>  _1__1__1
	按位与         &
	flags >>>  00001111  >>>  00001111
	            关闭位
	flags >>>  0_00_00_  >>>  00001001
```

<br>

#### 切换位

切换位指的是打开已关闭的位，或关闭已打开的位。可以使用按位异或运算符（^）切换位。

```powershell
# flags ^= MASK >>>>>>> 将指定的位取反，0➡1，1➡0
	MASK  >>>  00110010  >>>  __11__1_
	按位异或       ^
	flags >>>  10101001  >>>  10101001
	            切换位
	flags >>>  __01__1_  >>>  10011011
```

<br>

#### 检查位的值

有时，需要检查某位的值。例如，flags 中 1 号位是否被设置为 1？。检查指定位时需要将其他无关的位掩码（flags & MASK）。

```c
if((flags & MASK) == MASK)
// 10110101 & 10000000 ?= 10000000
// flags 指定位的值不会被修改，与 MASK 对比指定位是否相等，可以获取到当前位的值
// 相等表示校验位为 1，否则为 0
```

<br>

#### 位字段和按位运算符

在同类型的编程问题中，位字段和按位运算符是两种可替换的方法，用哪种方法都可以。可以通过一个联合把结构方法和位方法放在一起。

```c
struct box
{
	unsigned int n1 : 8;
	unsigned int n2 : 8;
	unsigned int n3 : 8;
	unsigned int n4 : 8;
};
union
{
	struct box Switch;
	unsigned int _Switch;
} BOX;
// 无论是 BOX.Switch 还是 BOX._Switch, 它们的地址都指向联合类型 BOX
```

>---
### 不求值表达式

```sizeof``` 运算符的操作数是不求值的表达式（除非它们是 VLA），```sizeof(printf("%d", 4));``` 不会进行控制台输出。
```_Alignof``` 运算符的操作数、泛型选择的控制表达式及作为 ```_Alignof``` 的操作数的 VLA 的大小表达式亦为不求值的表达式。

>---
### 泛型选择

在程序设计中，泛型编程（generic programming）指那些没有特定类型，但是一旦指定一种类型，就可以转换成指定类型的代码。
C++ 在模板中可以创建泛型算法，然后编译器根据指定的类型自动使用实例化代码；C 没有这种功能。
C11 新增了泛型选择表达式（generic selection expression），根据表达式的类型选择一个值，泛型表达式常用于 ```#define``` 宏定义的一部分。一个泛型选择最多只能有一个 `default` 关联。

```c
// 泛型表达式
_Generic(assign-expr, generic-assoc-list)
// Example cbrt
#define cbrt(X) _Generic((X), 			      \
					     long double: cbrtl,  \
						 default: cbrt,		  \
						 float: cbrtf		  \
						 )(X)
```

X 表示一个表达式，该表达式匹配哪个标签，就返回哪个标签后面的值，与 ```switch``` 语句相似。

> *泛型表达式与 define 组合 ```_Generic (控制表达式 , 关联列表)```*

```c
#include <stdio.h>
#define MYTYPE(X) _Generic((X),
		int: "int",
		float : "float",
		double: "double",
		default: "other"
		)
int main(void)
{
	int d = 5;
	printf("%s\n", MYTYPE(d));
	// d 是 int 类型
	printf("%s\n", MYTYPE(2.0*d));
	// 2.0 * d 是 double 类型
	printf("%s\n", MYTYPE(3L));
	// 3L 是 long 类型
	printf("%s\n", MYTYPE(&d));
	// &d 的类型是 int *
	return 0;
}
/*
	int
	double
	other
	other
*/
```

---